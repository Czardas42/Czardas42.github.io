<!DOCTYPE html>
<html>

<head>
  <meta charset="UTF-8" />

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
<meta name="keywords" content="Gridea静态个人博客">
<meta name="description" content="世界那么大，我想去看看">
<meta name="theme-color" content="#343a40">
<title>Chapter5数据结构一：5.1 向量 | Czardas</title>
<link rel="shortcut icon" href="/favicon.ico?v=1621772093709">
<link rel="stylesheet" href="/media/css/pisces.css">
<link rel="stylesheet" href="/media/fonts/font-awesome.css">
<link
  href="//fonts.googleapis.com/css?family=Monda:300,300italic,400,400italic,700,700italic|Roboto Slab:300,300italic,400,400italic,700,700italic|Rosario:300,300italic,400,400italic,700,700italic|PT Mono:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext"
  rel="stylesheet" type="text/css">

<link href="/media/hljs/styles/default.css"
  rel="stylesheet">

<link rel="stylesheet" href="/styles/main.css">

<script src="/media/hljs/highlight.js"></script>
<script src="https://cdn.jsdelivr.net/npm/velocity-animate@1.5.0/velocity.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/velocity-animate@1.5.0/velocity.ui.min.js"></script>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/katex.min.css"
  integrity="sha384-zB1R0rpPzHqg7Kpt0Aljp8JPLqbXI3bhnPWROx27a9N0Ll6ZP/+DiW/UqRcLbRjq" crossorigin="anonymous">


<script defer src="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/katex.min.js"
  integrity="sha384-y23I5Q6l+B6vatafAwxRu/0oK/79VlbSz7Q9aiSZUvyWYIYsd+qj+o24G5ZU2zJz" crossorigin="anonymous"></script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/contrib/auto-render.min.js"
  integrity="sha384-kWPLUVMOks5AQFrykwIup5lo0m3iMkkHrD0uJ4H5cjeGihAutqP0yW0J6dpFiVkI" crossorigin="anonymous"
  onload="renderMathInElement(document.body);"></script>





  <meta name="description" content="Chapter5数据结构一：5.1 向量" />
  <meta name="keywords" content="机试准备" />
</head>

<body>
  <div class="head-top-line"></div>
  <div class="header-box">
    
<div class="pisces">
  <header class="header  ">
    <div class="blog-header box-shadow-wrapper bg-color " id="header">
      <div class="nav-toggle" id="nav_toggle">
        <div class="toggle-box">
          <div class="line line-top"></div>
          <div class="line line-center"></div>
          <div class="line line-bottom"></div>
        </div>
      </div>
      <div class="site-meta">       
        <div class="site-title">
          
            <a href="/" class="brand">
              <span>Czardas</span>
            </a>  
          
        </div>
        
          <p class="subtitle">The world is not in your books and maps, it&#39;s out there.</p>
        
      </div>
      <nav class="site-nav" id="site_nav">
        <ul id="nav_ul">
          
            
            
              
            
            <li class="nav-item ">
              
              
                <a href="/" target="_self">
                  <i class="fa fa-home"></i> 首页
                </a>
              
            </li>
          
            
            
              
            
            <li class="nav-item ">
              
              
                <a href="/archives/" target="_self">
                  <i class="fa fa-archive"></i> 归档
                </a>
              
            </li>
          
            
            
              
            
            <li class="nav-item ">
              
              
                <a href="/post/about/" target="_self">
                  <i class="fa fa-user"></i> 关于
                </a>
              
            </li>
          
            
            
              
            
            <li class="nav-item ">
              
              
                <a href="/tag/daily_record/" target="_self">
                  <i class="fa fa-globe"></i> 日常学习&amp;踩坑
                </a>
              
            </li>
          
            
            
              
            
            <li class="nav-item ">
              
              
                <a href="/tag/programming_tests/" target="_self">
                  <i class="fa fa-globe"></i> 机试准备
                </a>
              
            </li>
          
            
            
              
            
            <li class="nav-item ">
              
              
                <a href="/tag/paper_reading/" target="_self">
                  <i class="fa fa-globe"></i> 论文阅读
                </a>
              
            </li>
          
            
            
              
            
            <li class="nav-item ">
              
              
                <a href="/tag/projects/" target="_self">
                  <i class="fa fa-globe"></i> 课设&amp;项目
                </a>
              
            </li>
          
            
            
              
            
            <li class="nav-item ">
              
              
                <a href="/tag/notes/" target="_self">
                  <i class="fa fa-globe"></i> 随笔
                </a>
              
            </li>
          
            
            
              
            
            <li class="nav-item ">
              
              
                <a href="/tag/mywork/" target="_self">
                  <i class="fa fa-globe"></i> 文章&amp;同人
                </a>
              
            </li>
          
          
            
              <li class="nav-item ">
                <a href="/friends/" target="_self">
                  
                    <i class="fa fa-address-book"></i> 友情链接
                  
                </a>
              </li>
            
          
          
            <li id="fa_search" class="nav-item">
              <a href="javascript:void(0);">
                <i class="fa fa-search"></i> <span class="language" data-lan="search">搜索</span>
              </a>
            </li>
          
        </ul>
      </nav>
    </div>
  </header>
</div>

<script type="text/javascript"> 
 
  let showNav = true;

  let navToggle = document.querySelector('#nav_toggle'),
  siteNav = document.querySelector('#site_nav');
  
  function navClick() {
    let sideBar = document.querySelector('.sidebar');
    let navUl = document.querySelector('#nav_ul');
    navToggle.classList.toggle('nav-toggle-active');
    siteNav.classList.toggle('nav-menu-active');
    if (siteNav.classList.contains('nav-menu-active')) {
      siteNav.style = "height: " + (navUl.children.length * 42) +"px !important";
    } else {
      siteNav.style = "";
    }
  }

  navToggle.addEventListener('click',navClick);  
</script>
  </div>
  <div class="main-continer">
    
    <div
      class="section-layout pisces ">
      <div class="section-layout-wrapper">
        

<div class="sidebar">
  
    <div class="sidebar-box box-shadow-wrapper bg-color right-motion" id="sidebar">
      
        <div class="post-list-sidebar">
          <div class="sidebar-title">
            <span id="tocSideBar" class="sidebar-title-item sidebar-title-active language" data-lan="index">文章目录</span>
            <span id="metaSideBar" class="sidebar-title-item language" data-lan="preview">站点概览</span>
          </div>
        </div>
      
      <div class="sidebar-body pisces" id="sidebar_body">
        
          
            <div class="post-side-meta" id="post_side_meta">
              
<div class="sidebar-wrapper box-shadow-wrapper bg-color">
  <div class="sidebar-item">
    <img class="site-author-image right-motion" src="/images/avatar.png"/>
    <p class="site-author-name">Czardas</p>
    
    <div class="site-description right-motion">
      
      
      
        <p>世界那么大，我想去看看</p>
      
      
    </div>
    
  </div>
  <div class="sidebar-item side-item-stat right-motion">
    <div class="sidebar-item-box">
      <a href="/archives/">
        
        <span class="site-item-stat-count">25</span>
        <span class="site-item-stat-name language" data-lan="article">文章</span>
      </a>
    </div>
    <div class="sidebar-item-box">
      <a href="">
        <span class="site-item-stat-count">5</span>
        <span class="site-item-stat-name language" data-lan="category">分类</span>
      </a>
    </div>
    <div class="sidebar-item-box">
      <a href="/tags/">
        <span class="site-item-stat-count">5</span>
        <span class="site-item-stat-name language" data-lan="tag">标签</span>
      </a>
    </div>
  </div>
  
    
  
  



</div>
            </div>
            <div class="post-toc sidebar-body-active" id="post_toc" style="opacity: 1;">
              <div class="toc-box right-motion">
  <div class="toc-wrapper auto-number auto"
    id="toc_wrapper">
    <ul class="markdownIt-TOC">
<li>
<ul>
<li><a href="#%E5%90%91%E9%87%8F%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C">向量基本操作</a></li>
<li><a href="#%E5%AE%8C%E6%95%B0%E4%B8%8E%E7%9B%88%E6%95%B0"><strong>完数与盈数</strong></a>
<ul>
<li><a href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0"><strong>题目描述</strong></a></li>
<li><a href="#%E8%A6%81%E7%82%B9"><strong>要点</strong></a></li>
<li><a href="#%E6%8F%90%E4%BA%A4%E5%9C%B0%E5%9D%80">提交地址</a></li>
<li><a href="#%E4%BB%A3%E7%A0%81">代码</a></li>
</ul>
</li>
</ul>
</li>
</ul>

  </div>
</div>

<script>

  let lastTop = 0, lList = [], hList = [], postBody, lastIndex = -1;
  let active = 'active-show', activeClass = 'active-current';
  let tocWrapper = document.querySelector('#toc_wrapper');
  let tocContent = tocWrapper.children[0];
  let autoNumber = tocWrapper && tocWrapper.classList.contains('auto-number');

  function addTocNumber(elem, deep) {
    if (!elem) {
      return;
    }
    let prop = elem.__proto__;

    if (prop === HTMLUListElement.prototype) {
      for (let i = 0; i < elem.children.length; i++) {
        addTocNumber(elem.children[i], deep + (i + 1) + '.');
      }
    } else if (prop === HTMLLIElement.prototype) {
      // 保存li元素
      if (elem.children[0] && elem.children[0].__proto__ === HTMLAnchorElement.prototype) {
        lList.push(elem);
      }
      for (let i = 0; i < elem.children.length; i++) {
        let cur = elem.children[i];
        if (cur.__proto__ === HTMLAnchorElement.prototype) {
          if (autoNumber) {
            cur.text = deep + ' ' + cur.text;
          }
        } else if (cur.__proto__ === HTMLUListElement.prototype) {
          addTocNumber(cur, deep);
        }
      }
    }
  }

  function removeParentActiveClass() {
    let parents = tocContent.querySelectorAll('.' + active)
    parents.forEach(function (elem) {
      elem.classList.remove(active);
    });
  }

  function addActiveClass(index) {
    if (index >= 0 && index < hList.length) {
      lList[index].classList.add(activeClass);
    }
  }

  function removeActiveClass(index) {
    if (index >= 0 && index < hList.length) {
      lList[index].classList.remove(activeClass);
    }
  }

  function addActiveLiElemment(elem, parent) {
    if (!elem || elem === parent) {
      return;
    } else {
      if (elem.__proto__ === HTMLLIElement.prototype) {
        elem.classList.add(active);
      }
      addActiveLiElemment(elem.parentElement, parent);
    }
  }

  function showToc() {
    if (tocWrapper) {
      postBody = document.querySelector('#post_body');
      for (let i = 0; i < postBody.children.length; i++) {
        if (postBody.children[i].__proto__ === HTMLHeadingElement.prototype) {
          hList.push(postBody.children[i]);
        }
      }
      if (tocWrapper.classList.contains('compress')) {
        tocContent.classList.add('closed');
      } else if (tocWrapper.classList.contains('no_compress')) {
        tocContent.classList.add('expanded');
      } else {
        if (hList.length > 10) {
          active = 'active-hidden'
          tocContent.classList.add('closed');
        } else {
          tocContent.classList.add('expanded');
        }
      }
    }
  }

  (function () {
    // 处理不是从#一级标题开始目录
    if (tocContent.children.length === 1 && tocContent.children[0].__proto__ === HTMLLIElement.prototype) {
      let con = tocContent.children[0].children[0];
      tocContent.innerHTML = con.innerHTML;
    }
    let markdownItTOC = document.querySelector('.markdownIt-TOC');
    let innerHeight = window.innerHeight;
    markdownItTOC.style = `max-height: ${innerHeight - 80 > 0 ? innerHeight - 80 : innerHeight}px`
    addTocNumber(tocContent, '');
  })();

  document.addEventListener('scroll', function (e) {
    if (lList.length <= 0) {
      return;
    }
    let scrollTop = document.scrollingElement.scrollTop + 10;
    let dir;

    if (lastTop - scrollTop > 0) {
      dir = 'up';
    } else {
      dir = 'down';
    }

    lastTop = scrollTop;
    if (scrollTop <= 0) {
      if (lastIndex >= 0 && lastIndex < hList.length) {
        lList[lastIndex].classList.remove(activeClass);
      }
      return;
    }

    let current = 0, hasFind = false;
    for (let i = 0; i < hList.length; i++) {
      if (hList[i].offsetTop > scrollTop) {
        current = i;
        hasFind = true;
        break;
      }
    }
    if (!hasFind && scrollTop > lList[lList.length - 1].offsetTop) {
      current = hList.length - 1;
    } else {
      current--;
    }
    if (dir === 'down') {
      if (current > lastIndex) {
        addActiveClass(current);
        removeActiveClass(lastIndex)
        lastIndex = current;
        removeParentActiveClass();
        lList[current] && addActiveLiElemment(lList[current].parentElement, tocContent);
      }
    } else {
      if (current < lastIndex) {
        addActiveClass(current);
        removeActiveClass(lastIndex);
        lastIndex = current;
        removeParentActiveClass();
        lList[current] && addActiveLiElemment(lList[current].parentElement, tocContent);
      }
    }
  });


  window.addEventListener('load', function () {
    showToc();
    document.querySelector('#sidebar').style = 'display: block;';
    tocWrapper.classList.add('toc-active');
    setTimeout(function () {
      if ("createEvent" in document) {
        let evt = document.createEvent("HTMLEvents");
        evt.initEvent("scroll", false, true);
        document.dispatchEvent(evt);
      }
      else {
        document.fireEvent("scroll");
      }
    }, 500)
  })

</script>
            </div>
          
        
      </div>
    </div>
  
</div>
<script>
  const SIDEBAR_TITLE_ACTIVE = 'sidebar-title-active';
  const SIDEBAR_BODY_ACTIVE = 'sidebar-body-active';
  const SLIDE_UP_IN = 'slide-up-in';

  let sidebar = document.querySelector('#sidebar'),
  tocSideBar = document.querySelector('#tocSideBar'),
  metaSideBar = document.querySelector('#metaSideBar'),
  postToc = document.querySelector('#post_toc'),
  postSiteMeta = document.querySelector('#post_side_meta'),
  sidebarTitle = document.querySelector('.sidebar-title'),
  sidebarBody = document.querySelector('#sidebar_body');

  tocSideBar && tocSideBar.addEventListener('click', (e) => {
    toggleSidebar(e);
  });

  metaSideBar && metaSideBar.addEventListener('click', (e) => {
    toggleSidebar(e);
  });

  function toggleSidebar(e) {
    let currentTitle = document.querySelector("."+SIDEBAR_TITLE_ACTIVE);
    if (currentTitle == e.srcElement) {
      return ;
    }
    let current, showElement, hideElement;
    if (e.srcElement == metaSideBar) {
      showElement = postSiteMeta;
      hideElement = postToc;
    } else if (e.srcElement == tocSideBar){
      showElement = postToc;
      hideElement = postSiteMeta;
    }
    currentTitle.classList.remove(SIDEBAR_TITLE_ACTIVE);
    e.srcElement.classList.add(SIDEBAR_TITLE_ACTIVE);

    window.Velocity(hideElement, 'stop');
    window.Velocity(hideElement, 'transition.slideUpOut', {
      display: 'none',
      duration: 200,
      complete: function () {
        window.Velocity(showElement, 'transition.slideDownIn', {
          duration: 200
        });
      }
    })
    hideElement.classList.remove(SIDEBAR_BODY_ACTIVE);
    showElement.classList.add(SIDEBAR_BODY_ACTIVE);
  }

  postToc && postToc.addEventListener('transitionend', function() {
    this.classList.remove(SLIDE_UP_IN);
  });

  if (sidebarBody) {
    if (sidebarBody.classList.contains('pisces') || sidebarBody.classList.contains('gemini')) {
      let hasFix = false;
      let scrollEl = document.querySelector('.main-continer');
      let limitTop = document.querySelector('#nav_ul').children.length * 42 + 162;
      window.addEventListener('scroll', function(e) {
        if (document.scrollingElement.scrollTop >= limitTop) {
          if (!hasFix) {
            sidebar.classList.add('sidebar-fixed');
            hasFix = true;
          }
        } else {
          if (hasFix) {
            sidebar.classList.remove('sidebar-fixed');
            hasFix = false;
          }
        }
      });
    }
  }
  
</script>
        <div class="section-box box-shadow-wrapper">
          <div class="section bg-color post post-page">
            <section class="post-header">
  <h1 class="post-title">
    <a class="post-title-link" href="https://Czardas42.github.io/post/chapter5_5.1/">
      Chapter5数据结构一：5.1 向量
    </a>
  </h1>
  <div class="post-meta">
    
    <span class="meta-item pc-show">
      <i class="fa fa-calendar-o"></i>
      <span class="language" data-lan="publish">发布于</span>
      <span class="publish-time" data-t="2021-05-05 15:44:06">2021-05-05</span>
      <span class="post-meta-divider pc-show">|</span>
    </span>
    
    <span class="meta-item">
      <i class="fa fa-folder-o"></i>
      <span class="pc-show language" data-lan="category-in">分类于</span>
      
      
      <a href="https://Czardas42.github.io/tag/programming_tests/">
        <span>机试准备</span>
      </a>
      
      
    </span>
    <span class="post-meta-divider">|</span>
    
    <span class="meta-item">
      <i class="fa fa-clock-o"></i>
      <span>2<span class="language" data-lan="minute">分钟</span></span>
    </span>
    <span class="meta-item">
      <span class="post-meta-divider">|</span>
      <i class="fa fa-file-word-o"></i>
      <span>284<span class="pc-show language" data-lan="words">字数</span></span>
    </span>
    
  </div>
</section>
            <div class="post-body next-md-body" id="post_body">
              <h2 id="向量基本操作">向量基本操作</h2>
<h2 id="完数与盈数"><strong>完数与盈数</strong></h2>
<h3 id="题目描述"><strong>题目描述</strong></h3>
<p>一个数如果恰好等于它的各因子（该数本身除外）子和，如：6=3+2+1，则称其为“完数”；若因子之和大于该数，则称其为“盈数”。求出2 到60 之间所有“完数”和“盈数”，并以如下形式输出： E: e1 e2 e3 ......(ei 为完数) G: g1 g2 g3 ......(gi 为盈数)</p>
<h3 id="要点"><strong>要点</strong></h3>
<ol>
<li><code>vector.pop_back()</code>是弹出最后一个元素</li>
<li>vector遍历方法：<code>vector.size()</code></li>
<li>求因子的方法：<code>num % i == 0</code></li>
</ol>
<h3 id="提交地址">提交地址</h3>
<p><a href="https://www.nowcoder.com/practice/df0d850e41894d06a165bf445ec8a8b4?tpId=40&amp;qru=%2Fta%2Ftsing-kaoyan%2Fquestion-ranking&amp;tab=answerKey">https://www.nowcoder.com/practice/df0d850e41894d06a165bf445ec8a8b4?tpId=40&amp;qru=%2Fta%2Ftsing-kaoyan%2Fquestion-ranking&amp;tab=answerKey</a></p>
<h3 id="代码">代码</h3>
<pre><code class="language-c++">#include &lt;iostream&gt;
#include &lt;cstdio&gt;
#include &lt;vector&gt;

using namespace std;

int Sum(int num)
{
    int sum = 0;
    for (int i=1; i&lt;num; i++)
    {
        if (num % i == 0)
        {
            sum += i;
        }
    }
    return sum;
};

int main()
{
    vector&lt;int&gt; E, G;
    for (int i=2; i&lt;=60; i++)
    {
        int sum = Sum(i);
        if (i == sum)
        {   
            E.push_back(i);
        }
        else if (i &lt; sum)
        {
            G.push_back(i);
        }
    }
    //输出E
    cout &lt;&lt; &quot;E:&quot;;
    for (int j=0; j&lt;E.size(); j++)
    {
        cout &lt;&lt; &quot; &quot; &lt;&lt; E[j];
    }
    //输出G
    cout &lt;&lt; &quot; G:&quot;;
    for (int j=0; j&lt;G.size(); j++)
    {
        cout &lt;&lt; &quot; &quot; &lt;&lt; G[j];
    }
    cout &lt;&lt; endl;
}
</code></pre>

            </div>
            
            
              <div class="post-footer">
  <ul class="post-copyright">
    <li class="post-copyright-author">
      <strong class="language" data-lan="author">本文作者：</strong>
      Czardas
    </li>
    <li class="post-copyright-link">
      <strong class="language" data-lan="link">本文链接：</strong>
      <a href="https://Czardas42.github.io/post/chapter5_5.1/" title="Chapter5数据结构一：5.1 向量">https://Czardas42.github.io/post/chapter5_5.1/</a>
    </li>
    <li class="post-copyright-license">
      <strong class="language" data-lan="copyright">版权声明： </strong>
      本博客所有文章除特别声明外，均采用<a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="noopener" target="_blank"><i class="fa fa-fw fa-creative-commons"></i> BY-NC-SA</a> 许可协议。转载请注明出处！
    </li>
  </ul>
  <div class="tags">
    
      <a href="https://Czardas42.github.io/tag/programming_tests/"># 机试准备</a>
    
  </div>
  <div class="nav">
    <div class="nav-prev">
      
        <i class="fa fa-chevron-left"></i>
        <a class="nav-pc-next" title="Chapter5数据结构一：5.2 队列" href="https://Czardas42.github.io/post/chapter5_5.2/">Chapter5数据结构一：5.2 队列</a class="nav-pc-next">
        <a class="nav-mobile-prev" title="Chapter5数据结构一：5.2 队列" href="https://Czardas42.github.io/post/chapter5_5.2/">上一篇</a>
      
    </div>
    <div class="nav-next">
      
        <a class="nav-pc-next" title="Chapter4字符串：4.3 字符串匹配" href="https://Czardas42.github.io/post/chapter4_4.3/">Chapter4字符串：4.3 字符串匹配</a>
        <a class="nav-mobile-next" title="Chapter4字符串：4.3 字符串匹配" href="https://Czardas42.github.io/post/chapter4_4.3/">下一篇</a>
        <i class="fa fa-chevron-right"></i>
      
    </div>
  </div>
</div>
            
            
  

          </div>
        </div>
      </div>
    </div>
    <div class="footer-box">
  <footer class="footer">
    <div class="copyright">
      Powered by <a href="https://github.com/getgridea/gridea" target="_blank">Gridea</a> | © 2019-2020 Theme By <a
        href="https://github.com/hsxyhao/gridea-theme-next" target="_blank">HsxyHao</a>
    </div>
    <div class="poweredby">
      Powered by <a href="https://github.com/getgridea/gridea" target="_blank">Gridea</a>
    </div>
  </footer>
  
  
  <div class="pisces back-to-top" id="back_to_top">
    <i class="fa fa-arrow-up"></i>
    
    <span class="scrollpercent">
      <span id="back_to_top_text">0</span>%
    </span>
    
  </div>
  
  
  
  <div class="bg-img">
    <img src="/media/images/1.jfif" />
  </div>
  
  
  
  
</div>
<script>

  let sideBarOpen = 'sidebar-open';
  let body = document.body;
  let back2Top = document.querySelector('#back_to_top'),
    back2TopText = document.querySelector('#back_to_top_text'),
    drawerBox = document.querySelector('#drawer_box'),
    rightSideBar = document.querySelector('.sidebar'),
    viewport = document.querySelector('body');

  function scrollAnimation(currentY, targetY) {

    let needScrollTop = targetY - currentY
    let _currentY = currentY
    setTimeout(() => {
      const dist = Math.ceil(needScrollTop / 10)
      _currentY += dist
      window.scrollTo(_currentY, currentY)
      if (needScrollTop > 10 || needScrollTop < -10) {
        scrollAnimation(_currentY, targetY)
      } else {
        window.scrollTo(_currentY, targetY)
      }
    }, 1)
  }

  back2Top.addEventListener("click", function (e) {
    scrollAnimation(document.scrollingElement.scrollTop, 0);
    e.stopPropagation();
    return false;
  });

  window.addEventListener('scroll', function (e) {
    let percent = document.scrollingElement.scrollTop / (document.scrollingElement.scrollHeight - document.scrollingElement.clientHeight) * 100;
    if (percent > 1 && !back2Top.classList.contains('back-top-active')) {
      back2Top.classList.add('back-top-active');
    }
    if (percent == 0) {
      back2Top.classList.remove('back-top-active');
    }
    if (back2TopText) {
      back2TopText.textContent = Math.floor(percent);
    }
  });


  let hasCacu = false;
  window.onresize = function () {
    calcuHeight();
  }

  function calcuHeight() {
    // 动态调整站点概览高度
    if (!hasCacu && back2Top.classList.contains('pisces') || back2Top.classList.contains('gemini')) {
      let sideBar = document.querySelector('.sidebar');
      let navUl = document.querySelector('#site_nav');
      sideBar.style = 'margin-top:' + (navUl.offsetHeight + navUl.offsetTop + 15) + 'px;';
      hasCacu = true;
    }
  }
  calcuHeight();

  let open = false, MOTION_TIME = 300, RIGHT_MOVE_DIS = '320px';

  if (drawerBox) {
    let rightMotions = document.querySelectorAll('.right-motion');
    let right = drawerBox.classList.contains('right');

    let transitionDir = right ? "transition.slideRightIn" : "transition.slideLeftIn";

    let openProp, closeProp;
    if (right) {
      openProp = {
        paddingRight: RIGHT_MOVE_DIS
      };
      closeProp = {
        paddingRight: '0px'
      };
    } else {
      openProp = {
        paddingLeft: RIGHT_MOVE_DIS
      };
      closeProp = {
        paddingLeft: '0px'
      };
    }

    drawerBox.onclick = function () {
      open = !open;
      window.Velocity(rightSideBar, 'stop');
      window.Velocity(viewport, 'stop');
      window.Velocity(rightMotions, 'stop');
      if (open) {
        window.Velocity(rightSideBar, {
          width: RIGHT_MOVE_DIS
        }, {
          duration: MOTION_TIME,
          begin: function () {
            window.Velocity(rightMotions, transitionDir, {});
          }
        })
        window.Velocity(viewport, openProp, {
          duration: MOTION_TIME
        });
      } else {
        window.Velocity(rightSideBar, {
          width: '0px'
        }, {
          duration: MOTION_TIME,
          begin: function () {
            window.Velocity(rightMotions, {
              opacity: 0
            });
          }
        })
        window.Velocity(viewport, closeProp, {
          duration: MOTION_TIME
        });
      }
      for (let i = 0; i < drawerBox.children.length; i++) {
        drawerBox.children[i].classList.toggle('muse-line');
      }
      drawerBox.classList.toggle(sideBarOpen);
    }
  }

  // 链接跳转
  let newWindow = 'false'
  if (newWindow === 'true') {
    let links = document.querySelectorAll('.post-body a')
    links.forEach(item => {
      if (!item.classList.contains('btn')) {
        item.setAttribute("target", "_blank");
      }
    })
  }

  let faSearch = document.querySelector('#fa_search');
  faSearch.addEventListener('click', function () {
    document.querySelector('#search_mask').style = ''
  })

  // 代码高亮
  hljs.initHighlightingOnLoad();
  
  // 离开当前页title变化
  var leaveTitle = "";
  if (leaveTitle) {
    document.addEventListener('visibilitychange', function () {
      if (document.visibilityState == 'hidden') {
        normal_title = document.title;
        document.title = leaveTitle;
      } else {
        document.title = normal_title;
      }
    });
  }

</script>

<link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css" />
<script src="https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js"></script>

<script>
  let images = document.querySelectorAll('.section img');
  console.log(images);
  images.forEach(image => {
    var parent = image.parentElement;
    var next = image.nextElementSibling;
    parent.removeChild(image);
    var aelem = document.createElement('a');
    aelem.href = image.src;
    aelem.dataset['fancybox'] = 'images';
    aelem.dataset['rel'] = 'fancybox-button';
    aelem.classList.add('fancybox');
    aelem.appendChild(image);
    parent.insertBefore(aelem, next);
  })
</script>
    <div class="reward-mask" style="display: none;">
  <div class="reward-relative">
    <span class="close" aria-hidden="true">x</span>
    <div class="reward-body">
      <h2>感谢您的支持，我会继续努力的!</h2>
      <div class="reward-img-box">
        <div style="position: relative; width: 140px; height: 140px;">
          
          
          
        </div>
      </div>
      <p class="reward-word">扫码打赏，你说多少就多少</p>
      <p class="reward-tip">打开微信扫一扫，即可进行扫码打赏哦</p>
    </div>
    <div class="bottom">
      
      
    </div>
  </div>
</div>
<style>
  .reward-mask {
    position: fixed;
    z-index: 99999;
    top: 0;
    bottom: 0;
    left: 0;
    right: 0;
    background-color: #00000054;
  }

  .reward-relative {
    position: relative;
    width: 480px;
    text-align: center;
    margin: 0 auto;
    border-radius: 5px;
    background-color: #fff;
    top: 50%;
    margin-top: -205px;
  }

  .reward-relative .close {
    position: absolute;
    right: 10px;
    font-weight: normal;
    font-size: 16px;
    color: #929292;
  }

  .reward-body {
    padding: 40px 20px 20px;
  }

  .bottom {
    display: flex;
  }

  .reward-btn {
    text-align: center;
  }

  .reward-btn-text {
    display: inline-block;
    cursor: pointer;
    width: 60px;
    height: 60px;
    line-height: 60px;
    border-radius: 50%;
    background-color: #ff9734;
    color: #FFF;
    margin-top: 20px;
  }

  .pay-text {
    margin-top: 10px;
    padding: 10px;
    flex: 1;
    transition: all .2s linear;
  }

  .pay-text:hover {
    background-color: #a5a5a536;
  }

  .reward-body h2 {
    padding-top: 10px;
    text-align: center;
    color: #a3a3a3;
    font-size: 16px;
    font-weight: normal;
    margin: 0 0 20px;
  }

  .reward-body h2:after,
  .reward-body h2:before {
    font-family: Arial, Helvetica, sans-serif;
    background: 0 0;
    width: 0;
    height: 0;
    font-style: normal;
    color: #eee;
    font-size: 80px;
    position: absolute;
    top: 20px;
  }

  .reward-body h2:before {
    content: '\201c';
    left: 50px;
  }

  .reward-body h2:after {
    content: '\201d';
    right: 80px;
  }

  .reward-img-box {
    display: inline-block;
    padding: 10px;
    border: 6px solid #ea5f00;
    margin: 0 auto;
    border-radius: 3px;
    position: relative;
  }

  .reward-img {
    position: absolute;
    left: 0px;
    top: 0px;
    width: 100%;
    height: 100%;
  }

  @media (max-width: 767px) {
    .reward-relative {
      height: 100%;
      top: 0px;
      margin-top: 0;
      width: auto;
    }

    .reward-relative .bottom {
      flex-direction: column;
    }

    .reward-relative .pay-text {
      width: 80%;
      margin: 5px auto;
      border: 1px solid silver;
      padding: 6px;
      border-radius: 4px;
    }

    .reward-body h2:after {
      right: 40px;
    }

    .reward-body h2:after,
    .reward-body h2:before {
      font-size: 60px;
    }

    .reward-body h2:before {
      left: 20px;
    }
  }
</style>
<script>
  !function () {
    var mask = document.querySelector('.reward-mask');
    let close = document.querySelector('.reward-relative .close');
    let rewardBtn = document.querySelector('.reward-btn');

    let zfb = document.querySelector('#zfb'),
      wx = document.querySelector('#wx'),
      zfbBtn = document.querySelector('#zfbBtn'),
      wxBtn = document.querySelector('#wxBtn');

    if (zfbBtn && wxBtn) {
      zfbBtn.addEventListener('click', () => {
        window.Velocity(zfb, 'transition.slideLeftIn', {
          duration: 400
        });
        window.Velocity(wx, 'transition.slideRightOut', {
          display: 'none',
          duration: 400
        });
      });

      wxBtn.addEventListener('click', () => {
        window.Velocity(wx, 'transition.slideRightIn', {
          duration: 400
        });
        window.Velocity(zfb, 'transition.slideLeftOut', {
          display: 'none',
          duration: 400
        });
      });
    }

    rewardBtn.addEventListener('click', (e) => {
      window.Velocity(mask, 'transition.slideDownIn', {
        duration: 400
      })
    });

    close.addEventListener('click', (e) => {
      e.preventDefault();
      window.Velocity(mask, 'transition.slideUpOut', {
        duration: 400
      })
    })
  }()
</script>

  </div>
</body>

<div class="search-mask" id="search_mask" style="display: none;">
  <div class="search-box">
    <div class="search-title">
      <i class="fa fa-search"></i>
      <div class="input-box">
        <input id="search" type="text" class="language" data-lan="search" placeholder="搜索">
      </div>
      <i id="close" class="fa fa-times-circle"></i>
    </div>
    <div class="stat-box">
      <span id="stat_count">0</span><span class="language" data-lan="stat">条相关条目，使用了</span><span id="stat_times">0</span><span class="language" data-lan="stat-time">毫秒</span>
      <hr>
    </div>
    <div class="result" id="result">
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://Czardas42.github.io/post/rank-emotion-cause-2020/"" data-c="
          &lt;p&gt;阅读笔记：&lt;/p&gt;
">Rank-Emotion-Cause</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://Czardas42.github.io/post/chapter8_8.2/"" data-c="
          &lt;h2 id=&#34;分治法&#34;&gt;分治法&lt;/h2&gt;
&lt;p&gt;不断把问题分为规模更小的问题&lt;/p&gt;
&lt;h2 id=&#34;1-斐波那契额数列&#34;&gt;1.  斐波那契额数列&lt;/h2&gt;
&lt;h3 id=&#34;题目描述&#34;&gt;&lt;strong&gt;题目描述&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;The Fibonacci Numbers{0,1,1,2,3,5,8,13,21,34,55...} are defined by the recurrence:   F0=0 F1=1 Fn=Fn-1+Fn-2,n&amp;gt;=2   Write a program to calculate the Fibonacci Numbers.&lt;/p&gt;
&lt;h3 id=&#34;要点&#34;&gt;要点&lt;/h3&gt;
&lt;p&gt;递归的写法&lt;/p&gt;
&lt;h3 id=&#34;提交地址&#34;&gt;提交地址&lt;/h3&gt;
&lt;p&gt;https://www.nowcoder.com/practice/17ad6908e36a49f4b06ea96936e8bb25?tpId=40&amp;amp;tab=answerKey&lt;/p&gt;
&lt;h3 id=&#34;代码&#34;&gt;代码&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;#include &amp;lt;bits/stdc++.h&amp;gt;

using namespace std;

int Fibonacci(int i)
{
    if (i == 0)
        return 0;
    else if (i == 1)
        return 1;
    else
        return Fibonacci(i-1) + Fibonacci(i-2);
    
}

int main()
{
    int num;
    while (cin &amp;gt;&amp;gt; num)
    {
        cout &amp;lt;&amp;lt; Fibonacci(num) &amp;lt;&amp;lt; endl;
    }
    return 0;
}

&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;2-二叉树&#34;&gt;2.  二叉树&lt;/h2&gt;
&lt;h3 id=&#34;题目描述-2&#34;&gt;&lt;strong&gt;题目描述&lt;/strong&gt;&lt;/h3&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://Czardas42.github.io//post-images/1621394733656.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;如上所示，由正整数1，2，3……组成了一颗特殊二叉树。我们已知这个二叉树的最后一个结点是n。现在的问题是，结点m所在的子树中一共包括多少个结点。   比如，n = 12，m = 3那么上图中的结点13，14，15以及后面的结点都是不存在的，结点m所在子树中包括的结点有3，6，7，12，因此结点m的所在子树中共有4个结点。&lt;/p&gt;
&lt;h3 id=&#34;要点-2&#34;&gt;&lt;strong&gt;要点&lt;/strong&gt;&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;二叉树的规律：左子节点id = 父节点id*2&lt;/li&gt;
&lt;li&gt;递归的终止条件：&lt;code&gt;m &amp;gt; n&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;提交地址-2&#34;&gt;提交地址&lt;/h3&gt;
&lt;p&gt;https://www.nowcoder.com/practice/f74c7506538b44399f2849eba2f050b5?tpId=40&amp;amp;tab=answerKey&lt;/p&gt;
&lt;h3 id=&#34;代码-2&#34;&gt;代码&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;#include &amp;lt;bits/stdc++.h&amp;gt;

using namespace std;

int nodeCount(int m, int n)
{
    if (m &amp;gt; n)
        return 0;
    else
        return nodeCount(2*m, n) + nodeCount(2*m+1, n) + 1;
}

int main()
{
    int m, n;
    while (cin &amp;gt;&amp;gt; m &amp;gt;&amp;gt;n)
    {
        if (m==0)
            break;        
        cout &amp;lt;&amp;lt; nodeCount(m, n) &amp;lt;&amp;lt; endl;
    }
    
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;3-2的幂次方&#34;&gt;3.  2的幂次方&lt;/h2&gt;
&lt;h3 id=&#34;题目描述-3&#34;&gt;&lt;strong&gt;题目描述&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;Every positive number can be presented by the exponential form.For example, 137 = 2^7 + 2^3 + 2^0。   Let&#39;s present a^b by the form a(b).Then 137 is presented by 2(7)+2(3)+2(0). Since 7 = 2^2 + 2 + 2^0 and 3 = 2 + 2^0 , 137 is finally presented by 2(2(2)+2 +2(0))+2(2+2(0))+2(0).    Given a positive number n,your task is to present n with the exponential form which only contains the digits 0 and 2.&lt;/p&gt;
&lt;h3 id=&#34;要点-3&#34;&gt;&lt;strong&gt;要点&lt;/strong&gt;&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;十进制到二进制的转换&lt;/p&gt;
&lt;p&gt;停止条件&lt;code&gt;num == 0&lt;/code&gt;, 不是&lt;code&gt;num / 2 == 0&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;递归的思想：&lt;/p&gt;
&lt;p&gt;输入，转换为二进制，有效位+位置序号判断&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;“+”位置的出现&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;提交地址-3&#34;&gt;提交地址&lt;/h3&gt;
&lt;p&gt;https://www.nowcoder.com/practice/7cf7b0706d7e4b439481f53e5fdac6e7?tpId=40&amp;amp;tab=answerKey&lt;/p&gt;
&lt;h3 id=&#34;代码-3&#34;&gt;代码&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;#include &amp;lt;bits/stdc++.h&amp;gt;

using namespace std;

vector&amp;lt;int&amp;gt; convert(int num)
{
    vector&amp;lt;int&amp;gt; res;
    while(num != 0)
    {
        res.push_back(num % 2);
        num = num / 2;
    }
    
    return res;
}

void print(int num)
{
    vector&amp;lt;int&amp;gt; res = convert(num);
    bool begin = true;
    for(int i=res.size()-1; i&amp;gt;=0; i--)
    {
        if (res[i] == 1)//有效位
        {
            if (begin == true)
                begin = false;
            else
                cout &amp;lt;&amp;lt; &amp;quot;+&amp;quot;;
            
            if (i == 0)
                cout &amp;lt;&amp;lt; &amp;quot;2(0)&amp;quot;;
            else if (i == 1)
                cout &amp;lt;&amp;lt; &amp;quot;2&amp;quot;;
            else if (i == 2)
                cout &amp;lt;&amp;lt; &amp;quot;2(2)&amp;quot;;
            else
            {
                cout &amp;lt;&amp;lt; &amp;quot;2(&amp;quot;;
                print(i);
                cout &amp;lt;&amp;lt; &amp;quot;)&amp;quot;;
            }
        }
    }
}

int main()
{
    int num;
    while (cin &amp;gt;&amp;gt; num)
    {
        print(num);
        cout &amp;lt;&amp;lt; endl;
    }
    return 0;  
}
    
&lt;/code&gt;&lt;/pre&gt;
">Chapter8递归与分治：8.2分治</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://Czardas42.github.io/post/chapter8_8.1/"" data-c="
          &lt;h2 id=&#34;递归策略&#34;&gt;递归策略&lt;/h2&gt;
&lt;h2 id=&#34;1-n的阶乘&#34;&gt;1.  n的阶乘&lt;/h2&gt;
&lt;h3 id=&#34;题目描述&#34;&gt;&lt;strong&gt;题目描述&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;输入一个整数n，输出n的阶乘（每组测试用例可能包含多组数据，请注意处理）&lt;/p&gt;
&lt;h3 id=&#34;要点&#34;&gt;&lt;strong&gt;要点&lt;/strong&gt;&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;递归思想&lt;/li&gt;
&lt;li&gt;结果的数据范围：&lt;code&gt;long long&lt;/code&gt;类型&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;提交地址&#34;&gt;提交地址&lt;/h3&gt;
&lt;p&gt;https://www.nowcoder.com/practice/97be22ee50b14cccad2787998ca628c8?tpId=40&amp;amp;tab=answerKey&lt;/p&gt;
&lt;h3 id=&#34;代码&#34;&gt;代码&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;#include &amp;lt;bits/stdc++.h&amp;gt;

using namespace std;

long long Factorial(int n)
{
    if (n == 1)
        return 1;
    else
    {
        return n * Factorial(n-1);
    }
}
int main()
{
    int num;
    while(cin &amp;gt;&amp;gt; num)
    {
        cout &amp;lt;&amp;lt; Factorial(num) &amp;lt;&amp;lt; endl;
    }
    
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;2-汉诺塔问题&#34;&gt;2.  汉诺塔问题&lt;/h2&gt;
&lt;p&gt;移动规律：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;F(n) = F(n-1) + 1 + F(n-1) + 1 + F(n-1)&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;F(n) = 3 * F(n-1) + 2&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;终止条件：&lt;code&gt;n=1&lt;/code&gt;时，的移动次数&lt;/p&gt;
&lt;h2 id=&#34;3-杨辉三角形&#34;&gt;3.  杨辉三角形&lt;/h2&gt;
&lt;h3 id=&#34;题目描述-2&#34;&gt;&lt;strong&gt;题目描述&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;使用代理服务器能够在一定程度上隐藏客户端信息，从而保护用户在互联网上的隐私。我们知道n个代理服务器的IP地址，现在要用它们去访问m个服务器。这 m 个服务器的 IP 地址和访问顺序也已经给出。系统在同一时刻只能使用一个代理服务器，并要求不能用代理服务器去访问和它 IP地址相同的服务器（不然客户端信息很有可能就会被泄露）。在这样的条件下，找到一种使用代理服务器的方案，使得代理服务器切换的次数尽可能得少。&lt;/p&gt;
&lt;h3 id=&#34;要点-2&#34;&gt;&lt;strong&gt;要点&lt;/strong&gt;&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;杨辉三角性质：&lt;code&gt;func(m, n) = func(m-1, n-1) + func(m-1, n);&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;递归函数：返回杨辉三角指定行列的值&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;提交地址-2&#34;&gt;提交地址&lt;/h3&gt;
&lt;p&gt;https://www.nowcoder.com/practice/1284469ee94a4762848816a42281a9e0?tpId=40&amp;amp;tab=answerKey&lt;/p&gt;
&lt;h3 id=&#34;代码-2&#34;&gt;代码&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;#include &amp;lt;bits/stdc++.h&amp;gt;

using namespace std;

int func(int m, int n)
{
    if(n==0)
        return 1;
    else if(m==n)
        return 1;
    else
        return func(m-1, n-1) + func(m-1, n);
}

int main()
{
    int num;
    while (cin &amp;gt;&amp;gt; num)
    {
        for(int i=0; i&amp;lt;num; i++)
        {
            for (int j=0; j&amp;lt;=i; j++)
            {
                if(j==i)
                    cout &amp;lt;&amp;lt; func(i, j) &amp;lt;&amp;lt; endl;
                else
                    cout &amp;lt;&amp;lt; func(i, j) &amp;lt;&amp;lt; &amp;quot; &amp;quot;;
            }
        }
    }
    
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;3-全排列&#34;&gt;3.  全排列&lt;/h2&gt;
&lt;h3 id=&#34;题目描述-3&#34;&gt;&lt;strong&gt;题目描述&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;给定一个由不同的小写字母组成的字符串，输出这个字符串的所有全排列。 我们假设对于小写字母有&#39;a&#39; &amp;lt; &#39;b&#39; &amp;lt; ... &amp;lt; &#39;y&#39; &amp;lt; &#39;z&#39;，而且给定的字符串中的字母已经按照从小到大的顺序排列。&lt;/p&gt;
&lt;h3 id=&#34;要点-3&#34;&gt;&lt;strong&gt;要点&lt;/strong&gt;&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;STL库的使用：&lt;code&gt;next_permutation(str.begin(),str.end())&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;do while&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;提交地址-3&#34;&gt;提交地址&lt;/h3&gt;
&lt;p&gt;https://www.nowcoder.com/practice/5632c23d0d654aecbc9315d1720421c1?tpId=40&amp;amp;tab=answerKey&lt;/p&gt;
&lt;h3 id=&#34;代码-3&#34;&gt;代码&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;#include &amp;lt;bits/stdc++.h&amp;gt;

using namespace std;

int main ()
{
    string str;
    while(cin &amp;gt;&amp;gt; str)
    {
        sort(str.begin(), str.end());
        do{
            cout &amp;lt;&amp;lt; str &amp;lt;&amp;lt; endl;
        }
        while(next_permutation(str.begin(),str.end()));
    }
    
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
">Chapter8递归与分治：8.1递归</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://Czardas42.github.io/post/chapter7_7.2/"" data-c="
          &lt;h2 id=&#34;贪心策略&#34;&gt;贪心策略&lt;/h2&gt;
&lt;h2 id=&#34;1-今年暑假不ac&#34;&gt;1.  今年暑假不AC&lt;/h2&gt;
&lt;h3 id=&#34;题目描述&#34;&gt;&lt;strong&gt;题目描述&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;“今年暑假不AC？”&lt;br&gt;
“是的。”&lt;br&gt;
“那你干什么呢？”&lt;br&gt;
“看世界杯呀，笨蛋！”&lt;br&gt;
“@#$%^&amp;amp;*%...”&lt;/p&gt;
&lt;p&gt;确实如此，世界杯来了，球迷的节日也来了，估计很多ACMer也会抛开电脑，奔向电视了。&lt;br&gt;
作为球迷，一定想看尽量多的完整的比赛，当然，作为新时代的好青年，你一定还会看一些其它的节目，比如新闻联播（永远不要忘记关心国家大事）、非常6+7、超级女生，以及王小丫的《开心辞典》等等，假设你已经知道了所有你喜欢看的电视节目的转播时间表，你会合理安排吗？（目标是能看尽量多的完整节目）&lt;/p&gt;
&lt;p&gt;输入数据包含多个测试实例，每个测试实例的第一行只有一个整数n(n&amp;lt;=100)，表示你喜欢看的节目的总数，然后是n行数据，每行包括两个数据Ti_s,Ti_e (1&amp;lt;=i&amp;lt;=n)，分别表示第i个节目的开始和结束时间，为了简化问题，每个时间都用一个正整数表示。n=0表示输入结束，不做处理。&lt;/p&gt;
&lt;h3 id=&#34;要点&#34;&gt;&lt;strong&gt;要点&lt;/strong&gt;&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;贪心策略：以节目结束时间为标准&lt;/li&gt;
&lt;li&gt;排序的写法&lt;/li&gt;
&lt;li&gt;判断条件：该节目开始时间晚于或&lt;strong&gt;等于&lt;/strong&gt;标记时间&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;提交地址&#34;&gt;提交地址&lt;/h3&gt;
&lt;p&gt;http://acm.hdu.edu.cn/showproblem.php?pid=2037&lt;/p&gt;
&lt;h3 id=&#34;代码&#34;&gt;代码&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;#include &amp;lt;iostream&amp;gt;
#include &amp;lt;cstdio&amp;gt;
#include &amp;lt;algorithm&amp;gt;

using namespace std;

struct program
{
	int begin;
	int end;
};

program list[100];

bool Compare(program a, program b)
{
	return a.end &amp;lt; b.end;
};

int main()
{
	int count;
	while (cin &amp;gt;&amp;gt; count)
	{
		if (count == 0)
			break;

		for (int i = 0; i &amp;lt; count; i++)
		{
			cin &amp;gt;&amp;gt; list[i].begin &amp;gt;&amp;gt; list[i].end;
		}
		//完成输入

		//排序
		sort(list, list + count, Compare);

		//判断
		int time = 0; //当前标记时间
		int result = 0; //结果记录
		for (int i = 0; i &amp;lt; count; i++)
		{
			if (list[i].begin &amp;gt;= time) //若该节目开始时间晚于或等于标记时间
			{
				result++; //观看节目+1
				time = list[i].end; //标记时间变为该节目的结束时间
			}
		}
		cout &amp;lt;&amp;lt; result &amp;lt;&amp;lt; endl;	
	}
	return 0;
}

&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;2-to-fill-or-not-to-fill&#34;&gt;2.  To Fill or Not to Fill&lt;/h2&gt;
&lt;h3 id=&#34;题目描述-2&#34;&gt;&lt;strong&gt;题目描述&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;With highways available, driving a car from Hangzhou to any other city is easy. But since the tank capacity of a car is limited, we have to find gas stations on the way from time to time. Different gas station may give different price. You are asked to carefully design the cheapest route to go.&lt;/p&gt;
&lt;h3 id=&#34;要点-2&#34;&gt;&lt;strong&gt;要点&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;倦了，一个下午没通过。。。。。。&lt;/p&gt;
&lt;h3 id=&#34;提交地址-2&#34;&gt;提交地址&lt;/h3&gt;
&lt;p&gt;https://www.nowcoder.com/practice/f7eba38f7cd24c45982831e0f38518f9?tpId=40&amp;amp;tab=answerKey&lt;/p&gt;
&lt;h3 id=&#34;代码-2&#34;&gt;代码&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;/*
核心思路:利用贪心策略,从最便宜的加油站开始,每个加油站加的油最多能走cmax*davg路程.
利用一个30000大小的flag数组记录是否有重合区域
*/
#include&amp;lt;cstdio&amp;gt;
#include&amp;lt;algorithm&amp;gt;
using namespace std;

struct sta{
    double pi;
    int di;
    bool operator &amp;lt; (const sta&amp;amp; b) const{
        return pi&amp;lt;b.pi;
    }
}a[501];

int main(){
    int cmax, d, davg, n;
    double sum;
    while(scanf(&amp;quot;%d %d %d %d&amp;quot;, &amp;amp;cmax, &amp;amp;d, &amp;amp;davg, &amp;amp;n)!=EOF){
        for(int i=0; i&amp;lt;n; i++) scanf(&amp;quot;%lf %d&amp;quot;, &amp;amp;a[i].pi, &amp;amp;a[i].di);
        sort(a, a+n);
        //
        sum = 0;//记录花费
        int flag[30001]={0}, max = cmax*davg, tmp, cnt;
        for(int i=0; i&amp;lt;n; i++){
            tmp = (a[i].di+max&amp;lt;d?max:d-a[i].di);    //如果到终点距离&amp;lt;max,只需加上足够走到终点的油
            cnt = 0;    //记录有多长距离需要该加油站的油
            for(int j=a[i].di; j&amp;lt;a[i].di+tmp; j++){
                if(flag[j]==0){
                    flag[j] = 1;
                    cnt++;
                }
            }
            sum += cnt/(davg*1.0)*a[i].pi;    //加上在该加油站的花销
        }
        //check
        int i;
        for(i=0; i&amp;lt;d; i++){
            //有的路程没有被覆盖到说明走不到这里
            if(flag[i]==0){
                printf(&amp;quot;The maximum travel distance = %.2lf\n&amp;quot;, (double)i);
                break;
            }
        }
        if(i==d){
            printf(&amp;quot;%.2lf\n&amp;quot;,sum);
        }
    }
    return 0;
}

&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;2-代理服务器&#34;&gt;2.  代理服务器&lt;/h2&gt;
&lt;h3 id=&#34;题目描述-3&#34;&gt;&lt;strong&gt;题目描述&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;使用代理服务器能够在一定程度上隐藏客户端信息，从而保护用户在互联网上的隐私。我们知道n个代理服务器的IP地址，现在要用它们去访问m个服务器。这 m 个服务器的 IP 地址和访问顺序也已经给出。系统在同一时刻只能使用一个代理服务器，并要求不能用代理服务器去访问和它 IP地址相同的服务器（不然客户端信息很有可能就会被泄露）。在这样的条件下，找到一种使用代理服务器的方案，使得代理服务器切换的次数尽可能得少。&lt;/p&gt;
&lt;h3 id=&#34;要点-3&#34;&gt;&lt;strong&gt;要点&lt;/strong&gt;&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;#include&amp;lt;bits/stdc++.h&amp;gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;strcmp(proxy[i], server[j])&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;提交地址-3&#34;&gt;提交地址&lt;/h3&gt;
&lt;p&gt;https://www.nowcoder.com/practice/1284469ee94a4762848816a42281a9e0?tpId=40&amp;amp;tab=answerKey&lt;/p&gt;
&lt;h3 id=&#34;代码-3&#34;&gt;代码&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;#include&amp;lt;bits/stdc++.h&amp;gt;
using namespace std;

int main(){
    int n;
    while(cin &amp;gt;&amp;gt; n){
        char proxy[n][16];  // proxy服务器
        for(int i = 0; i &amp;lt; n; i++)
            cin &amp;gt;&amp;gt; proxy[i];
        int m;
        cin &amp;gt;&amp;gt; m;
        char server[m][16];
        for(int i = 0; i &amp;lt; m; i++)
            cin &amp;gt;&amp;gt; server[i];  // 被访问的服务器
        //以上都是输入的内容
        int index=0, count=0, flag=1;  //flag用来标志代li失败的状况
        while(flag &amp;amp;&amp;amp; index != m)
        {  //当游标index遍历到m时表示遍历结束
            int max = 0;
            for(int i = 0; i &amp;lt; n; i++){  //这个for是让每个proxy服务器尽可能大的遍历服务器
                int j = index;  //每次从游标开始遍历服务器
                while(strcmp(proxy[i], server[j]) &amp;amp;&amp;amp; j &amp;lt; m)  //尽可能的访问服务器
                    j++;
                if(j - index &amp;gt; max)
                    max = j - index;  //最大访问服务器个数
            }
            if(max == 0)  //遍历失败
                flag = 0;
            count++;
            index += max;
        }
        if(flag)
            cout &amp;lt;&amp;lt; count - 1 &amp;lt;&amp;lt; endl;  //因为第一次不算转换
        else cout &amp;lt;&amp;lt; &amp;quot;-1&amp;quot; &amp;lt;&amp;lt; endl;
    }
}
&lt;/code&gt;&lt;/pre&gt;
">Chapter7贪心算法：7.2区间贪心</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://Czardas42.github.io/post/chapter7_7.1/"" data-c="
          &lt;h2 id=&#34;贪心策略&#34;&gt;贪心策略&lt;/h2&gt;
&lt;h2 id=&#34;1-鸡兔同笼&#34;&gt;1.  鸡兔同笼&lt;/h2&gt;
&lt;h3 id=&#34;题目描述&#34;&gt;&lt;strong&gt;题目描述&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;一个笼子里面关了鸡和兔子（鸡有2只脚，兔子有4只脚，没有例外）。已经知道了笼子里面脚的总数a，问笼子里面至少有多少只动物，至多有多少只动物。&lt;/p&gt;
&lt;h3 id=&#34;要点&#34;&gt;&lt;strong&gt;要点&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;只有偶数脚时，答案才不是0 0&lt;/p&gt;
&lt;h3 id=&#34;提交地址&#34;&gt;提交地址&lt;/h3&gt;
&lt;p&gt;https://www.nowcoder.com/practice/fda725b4d9a14010bb145272cababef1?tpId=40&amp;amp;tab=answerKey&lt;/p&gt;
&lt;h3 id=&#34;代码&#34;&gt;代码&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;#include &amp;lt;iostream&amp;gt;
#include &amp;lt;cstdio&amp;gt;

using namespace std;

int Find_least(int num)
{
    int rabbit, chicken;
    rabbit = num / 4;
    int temp = num % 4;
    if (temp != 0)
        chicken = temp / 2;
    
    return rabbit + chicken;
};

int Find_most(int num)
{
    int rabbit = 0, chicken = 0;
    chicken = num / 2;
    
    return rabbit + chicken;
};

int main()
{

    int num;
    while (cin &amp;gt;&amp;gt; num)
    {
        if (num % 2 != 0)
        {
            cout &amp;lt;&amp;lt; &amp;quot;0 0&amp;quot; &amp;lt;&amp;lt; endl;
            continue;
        }
        else
        {
            int most = Find_most(num);
            int least = Find_least(num);
            cout &amp;lt;&amp;lt; least &amp;lt;&amp;lt; &amp;quot; &amp;quot; &amp;lt;&amp;lt; most &amp;lt;&amp;lt; endl;
        }
           
    }
    
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;2-fatmouse-trade&#34;&gt;2.  FatMouse&#39; Trade&lt;/h2&gt;
&lt;h3 id=&#34;题目描述-2&#34;&gt;&lt;strong&gt;题目描述&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;FatMouse prepared M pounds of cat food, ready to trade with the cats guarding the warehouse containing his favorite food, JavaBean.&lt;br&gt;
The warehouse has N rooms. The i-th room contains J[i] pounds of JavaBeans and requires F[i] pounds of cat food. FatMouse does not have to trade for all the JavaBeans in the room, instead, he may get J[i]* a% pounds of JavaBeans if he pays F[i]* a% pounds of cat food. Here a is a real number. Now he is assigning this homework to you: tell him the maximum amount of JavaBeans he can obtain.&lt;/p&gt;
&lt;h3 id=&#34;要点-2&#34;&gt;&lt;strong&gt;要点&lt;/strong&gt;&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;计算性价比&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;排序&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;sort(arr, srr+n, Compare);
bool Compare(a, b) //降序
{
	return a &amp;gt; b;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;提交地址-2&#34;&gt;提交地址&lt;/h3&gt;
&lt;p&gt;暂无&lt;/p&gt;
&lt;h3 id=&#34;代码-2&#34;&gt;代码&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;2-代理服务器&#34;&gt;2.  代理服务器&lt;/h2&gt;
&lt;h3 id=&#34;题目描述-3&#34;&gt;&lt;strong&gt;题目描述&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;使用代理服务器能够在一定程度上隐藏客户端信息，从而保护用户在互联网上的隐私。我们知道n个代理服务器的IP地址，现在要用它们去访问m个服务器。这 m 个服务器的 IP 地址和访问顺序也已经给出。系统在同一时刻只能使用一个代理服务器，并要求不能用代理服务器去访问和它 IP地址相同的服务器（不然客户端信息很有可能就会被泄露）。在这样的条件下，找到一种使用代理服务器的方案，使得代理服务器切换的次数尽可能得少。&lt;/p&gt;
&lt;h3 id=&#34;要点-3&#34;&gt;&lt;strong&gt;要点&lt;/strong&gt;&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;#include&amp;lt;bits/stdc++.h&amp;gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;strcmp(proxy[i], server[j])&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;提交地址-3&#34;&gt;提交地址&lt;/h3&gt;
&lt;p&gt;https://www.nowcoder.com/practice/1284469ee94a4762848816a42281a9e0?tpId=40&amp;amp;tab=answerKey&lt;/p&gt;
&lt;h3 id=&#34;代码-3&#34;&gt;代码&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;#include&amp;lt;bits/stdc++.h&amp;gt;
using namespace std;

int main(){
    int n;
    while(cin &amp;gt;&amp;gt; n){
        char proxy[n][16];  // proxy服务器
        for(int i = 0; i &amp;lt; n; i++)
            cin &amp;gt;&amp;gt; proxy[i];
        int m;
        cin &amp;gt;&amp;gt; m;
        char server[m][16];
        for(int i = 0; i &amp;lt; m; i++)
            cin &amp;gt;&amp;gt; server[i];  // 被访问的服务器
        //以上都是输入的内容
        int index=0, count=0, flag=1;  //flag用来标志代li失败的状况
        while(flag &amp;amp;&amp;amp; index != m)
        {  //当游标index遍历到m时表示遍历结束
            int max = 0;
            for(int i = 0; i &amp;lt; n; i++){  //这个for是让每个proxy服务器尽可能大的遍历服务器
                int j = index;  //每次从游标开始遍历服务器
                while(strcmp(proxy[i], server[j]) &amp;amp;&amp;amp; j &amp;lt; m)  //尽可能的访问服务器
                    j++;
                if(j - index &amp;gt; max)
                    max = j - index;  //最大访问服务器个数
            }
            if(max == 0)  //遍历失败
                flag = 0;
            count++;
            index += max;
        }
        if(flag)
            cout &amp;lt;&amp;lt; count - 1 &amp;lt;&amp;lt; endl;  //因为第一次不算转换
        else cout &amp;lt;&amp;lt; &amp;quot;-1&amp;quot; &amp;lt;&amp;lt; endl;
    }
}
&lt;/code&gt;&lt;/pre&gt;
">Chapter7贪心算法：7.1简单贪心</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://Czardas42.github.io/post/chapter6_6.4/"" data-c="
          &lt;h2 id=&#34;质因数分解&#34;&gt;质因数分解&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;把一个合数用质因数相乘的形式表示出来，叫做分解质因数&lt;/strong&gt;。&lt;/p&gt;
&lt;p class=&#39;katex-block&#39;&gt;&lt;span class=&#34;katex-display&#34;&gt;&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;x&lt;/mi&gt;&lt;mo&gt;=&lt;/mo&gt;&lt;msubsup&gt;&lt;mi&gt;p&lt;/mi&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;mrow&gt;&lt;mi&gt;e&lt;/mi&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;/mrow&gt;&lt;/msubsup&gt;&lt;mo&gt;∗&lt;/mo&gt;&lt;msubsup&gt;&lt;mi&gt;p&lt;/mi&gt;&lt;mn&gt;2&lt;/mn&gt;&lt;mrow&gt;&lt;mi&gt;e&lt;/mi&gt;&lt;mn&gt;2&lt;/mn&gt;&lt;/mrow&gt;&lt;/msubsup&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;.&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;.&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;.&lt;/mi&gt;&lt;msubsup&gt;&lt;mi&gt;p&lt;/mi&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mrow&gt;&lt;mi&gt;e&lt;/mi&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;/mrow&gt;&lt;/msubsup&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;x = p_1^{e1} * p_2^{e2} ...p_n^{en}
&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.43056em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;x&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mrel&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1.1111079999999998em;vertical-align:-0.247em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;p&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.8641079999999999em;&#34;&gt;&lt;span style=&#34;top:-2.4530000000000003em;margin-left:0em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;1&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;top:-3.113em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;&lt;span class=&#34;mord mathdefault mtight&#34;&gt;e&lt;/span&gt;&lt;span class=&#34;mord mtight&#34;&gt;1&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.247em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mbin&#34;&gt;∗&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1.1111079999999998em;vertical-align:-0.247em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;p&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.8641079999999999em;&#34;&gt;&lt;span style=&#34;top:-2.4530000000000003em;margin-left:0em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;2&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;top:-3.113em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;&lt;span class=&#34;mord mathdefault mtight&#34;&gt;e&lt;/span&gt;&lt;span class=&#34;mord mtight&#34;&gt;2&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.247em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;p&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.7143919999999999em;&#34;&gt;&lt;span style=&#34;top:-2.4530000000000003em;margin-left:0em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mathdefault mtight&#34;&gt;n&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;top:-3.113em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;&lt;span class=&#34;mord mathdefault mtight&#34;&gt;e&lt;/span&gt;&lt;span class=&#34;mord mathdefault mtight&#34;&gt;n&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.247em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h2 id=&#34;1-质因数个数&#34;&gt;1.  质因数个数&lt;/h2&gt;
&lt;h3 id=&#34;题目描述&#34;&gt;&lt;strong&gt;题目描述&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;求正整数N(N&amp;gt;1)的质因数的个数。 相同的质因数需要重复计算。如120=2&lt;em&gt;2&lt;/em&gt;2&lt;em&gt;3&lt;/em&gt;5，共有5个质因数。&lt;/p&gt;
&lt;h3 id=&#34;要点&#34;&gt;&lt;strong&gt;要点&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;算法步骤：（输入1&amp;lt;N&amp;lt;M）&lt;/p&gt;
&lt;p&gt;&lt;code&gt;MAXN = sqrt(M) + 1&lt;/code&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;素数筛法求出0-MAXN所有素数，存好；&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;（N至多只存在一个大于MAXN的质因数，否则两个相乘会大于N）&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;输入N；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;依次遍历素数组，判断是否能整除；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;不断用该素数除N，直到不能被整除为止，记录幂次；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;遍历完成之后，若N&amp;gt;1，则证明存在一个大于MAXN且幂次为1的质因数&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;提交地址&#34;&gt;提交地址&lt;/h3&gt;
&lt;p&gt;https://www.nowcoder.com/practice/20426b85f7fc4ba8b0844cc04807fbd9?tpId=40&amp;amp;qru=%2Fta%2Ftsing-kaoyan%2Fquestion-ranking&amp;amp;tab=answerKey&lt;/p&gt;
&lt;h3 id=&#34;代码&#34;&gt;代码&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;#include &amp;lt;iostream&amp;gt;
#include &amp;lt;cmath&amp;gt;
#include &amp;lt;cstdio&amp;gt;
#include &amp;lt;vector&amp;gt;

using namespace std;

const int MAXN = 31623; // sqrt(1e9) + 1

bool isPrime[MAXN];
vector&amp;lt;int&amp;gt; prime;

void Initial() //素数筛法
{
    for(int i=0; i&amp;lt;MAXN; i++)
        isPrime[i] = true;
    isPrime[0] = false;
    isPrime[1] = false;
    
    for (int i=0; i&amp;lt;MAXN; i++)
    {
        if (isPrime[i] == true)
        {
            prime.push_back(i);
            for (int j=i*i; j&amp;lt;MAXN; j=j+i)
                isPrime[j] = false;
        }
    }
};

int main()
{
    Initial();
    
    int num;
    while (cin &amp;gt;&amp;gt; num)
    {
        int result = 0;
        for (int i=0; i&amp;lt;prime.size(); i++)
        {
            int temp = prime[i];
            while (num % temp == 0)
            {
                result++;
                num = num / temp;
            }
            
            if (num == 1) //除尽就跳出循环
                break;
        }
        
        if (num &amp;gt; 1) //存在一个大于sqrt(1e9) + 1的素因数，且幂次为1
            result++;
        
        cout &amp;lt;&amp;lt; result &amp;lt;&amp;lt; endl;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;2-约数的个数&#34;&gt;2.  约数的个数&lt;/h2&gt;
&lt;h3 id=&#34;题目描述-2&#34;&gt;&lt;strong&gt;题目描述&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;输入n个整数,依次输出每个数的约数的个数&lt;/p&gt;
&lt;h3 id=&#34;要点-2&#34;&gt;&lt;strong&gt;要点&lt;/strong&gt;&lt;/h3&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;D:%5CTJU%5C%E4%BF%9D%E7%A0%94%5C%E6%9C%BA%E8%AF%95%5Cimage-20210506133135936.png&#34; alt=&#34;image-20210506133135936&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;也就是求出质因数之后前面的组合乘上现在的因子加1&lt;/p&gt;
&lt;h3 id=&#34;提交地址-2&#34;&gt;提交地址&lt;/h3&gt;
&lt;p&gt;https://www.nowcoder.com/practice/04c8a5ea209d41798d23b59f053fa4d6?tpId=40&amp;amp;qru=%2Fta%2Ftsing-kaoyan%2Fquestion-ranking&amp;amp;tab=answerKey&lt;/p&gt;
&lt;h3 id=&#34;代码-2&#34;&gt;代码&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;#include &amp;lt;iostream&amp;gt;
#include &amp;lt;cstdio&amp;gt;
#include &amp;lt;cmath&amp;gt;
#include &amp;lt;vector&amp;gt;

using namespace std;

vector&amp;lt;bool&amp;gt; isPrime;
vector&amp;lt;int&amp;gt; prime;
const int MAXN = sqrt(1e9) + 1;

void Initial()
{
    for (int i=0; i&amp;lt;MAXN; i++)
        isPrime.push_back(true);
    isPrime[0] = false;
    isPrime[1] = false;
    
    for (int i=0; i&amp;lt;MAXN; i++)
    {
        if (isPrime[i] == true)
        {
            prime.push_back(i);
            for (int j = i*i; j&amp;lt;MAXN; j+=i)
                isPrime[j] = false;
        }
    }
};

int main()
{
    int count;
    Initial();
    while (cin &amp;gt;&amp;gt; count)
    {
        int num;
        for (int i=0; i&amp;lt;count; i++)
        {
            cin &amp;gt;&amp;gt; num;           
            int answer = 1;           

            for (int i=0; i&amp;lt;prime.size(); i++)
            {
                int temp = prime[i];
                int result = 0;
                                
                while (num % temp == 0)
                {
                    num = num / temp;
                    result++;
                }
                
                answer = (result+1) * answer;
                
                if (num == 1)
                    break;
            }
            
            if (num &amp;gt; 1)
                answer *= 2;
            
            cout &amp;lt;&amp;lt; answer &amp;lt;&amp;lt; endl;                  
        }
    }
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
">Chapter6数学问题：6.4分解质因数</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://Czardas42.github.io/post/prometheus/"" data-c="
          &lt;h4 id=&#34;集群监控策略&#34;&gt;集群监控策略：&lt;/h4&gt;
&lt;p&gt;Prometheus监控Kubernetes集群监控的各个维度以及策略：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;目标&lt;/th&gt;
&lt;th&gt;服务发现模式&lt;/th&gt;
&lt;th&gt;&lt;strong&gt;监控方法&lt;/strong&gt;&lt;/th&gt;
&lt;th&gt;&lt;strong&gt;数据源&lt;/strong&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;从集群各节点kubelet组件中获取节点kubelet的基本运行状态的监控指标&lt;/td&gt;
&lt;td&gt;node&lt;/td&gt;
&lt;td&gt;白盒监控&lt;/td&gt;
&lt;td&gt;kubelet&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;从集群各节点kubelet内置的cAdvisor中获取，节点中运行的容器的监控指标&lt;/td&gt;
&lt;td&gt;node&lt;/td&gt;
&lt;td&gt;白盒监控&lt;/td&gt;
&lt;td&gt;kubelet&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;从部署到各个节点的Node Exporter中采集主机资源相关的运行资源&lt;/strong&gt;（本次实验使用方法）&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;node&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;白盒监控&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;node exporter&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;对于内置了Promthues支持的应用，需要从Pod实例中采集其自定义监控指标&lt;/td&gt;
&lt;td&gt;pod&lt;/td&gt;
&lt;td&gt;白盒监控&lt;/td&gt;
&lt;td&gt;custom pod&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;获取API Server组件的访问地址，并从中获取Kubernetes集群相关的运行监控指标&lt;/td&gt;
&lt;td&gt;endpoints&lt;/td&gt;
&lt;td&gt;白盒监控&lt;/td&gt;
&lt;td&gt;api server&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;获取集群中Service&lt;u&gt;的访问地址&lt;/u&gt;，并通过Blackbox Exporter获取网络探测指标&lt;/td&gt;
&lt;td&gt;service&lt;/td&gt;
&lt;td&gt;黑盒监控&lt;/td&gt;
&lt;td&gt;blackbox exporter&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;获取集群中Ingress的访问信息，并通过Blackbox Exporter获取网络探测指标&lt;/td&gt;
&lt;td&gt;ingress&lt;/td&gt;
&lt;td&gt;黑盒监控&lt;/td&gt;
&lt;td&gt;blackbox exporter&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h4 id=&#34;prometheus部署&#34;&gt;Prometheus部署&lt;/h4&gt;
&lt;p&gt;&lt;u&gt;&lt;em&gt;详细说一说，因为直接动了系统自带的配置文件&lt;/em&gt;&lt;/u&gt;&lt;/p&gt;
&lt;h4 id=&#34;node-exporter部署&#34;&gt;Node Exporter部署&lt;/h4&gt;
&lt;h5 id=&#34;方法&#34;&gt;方法：&lt;/h5&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;创建自定义的Node Exporter服务，然后将服务器配置为Prometheus上的Target（本次实验使用方法）&lt;/p&gt;
&lt;p&gt;【参考】&lt;a href=&#34;https://devopscube.com/monitor-linux-servers-prometheus-node-exporter/&#34;&gt;https://devopscube.com/monitor-linux-servers-prometheus-node-exporter/&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;还可以使用Daemonset控制器部署Node Exporter&lt;/p&gt;
&lt;p&gt;为了能够采集集群中各个节点的资源使用情况，需要在各节点中部署一个Node Exporter实例。在部署Prometheus时，我们使用了Kubernetes内置的控制器之一Deployment。Deployment能够确保Prometheus的Pod能够按照预期的状态在集群中运行，而Pod实例可能随机运行在任意节点上。&lt;/p&gt;
&lt;p&gt;而与Prometheus的部署不同的是，&lt;strong&gt;对于Node Exporter而言每个节点只需要运行一个唯一的实例&lt;/strong&gt;，所以需要使用Kubernetes的另外一种控制器Daemonset。Daemonset的管理方式类似于操作系统中的守护进程。Daemonset会确保在集群中所有（也可以指定）节点上运行一个唯一的Pod实例。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h5 id=&#34;daemonset-与-deployment-的区别&#34;&gt;DaemonSet 与 Deployment 的区别&lt;/h5&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Deployment&lt;/strong&gt; 部署的副本 &lt;strong&gt;Pod&lt;/strong&gt; 会分布在各个 &lt;strong&gt;Node&lt;/strong&gt; 上，每个 &lt;strong&gt;Node&lt;/strong&gt; 都可能运行好几个副本。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;DaemonSet&lt;/strong&gt; 的不同之处在于：每个 &lt;strong&gt;Node&lt;/strong&gt; 上最多只能运行一个副本。&lt;/li&gt;
&lt;/ul&gt;
&lt;h5 id=&#34;daemonset-的典型应用场景&#34;&gt;DaemonSet 的典型应用场景&lt;/h5&gt;
&lt;ul&gt;
&lt;li&gt;在集群的每个节点上运行存储 &lt;strong&gt;Daemon&lt;/strong&gt;，比如：&lt;strong&gt;glusterd&lt;/strong&gt; 或 &lt;strong&gt;ceph&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;在每个节点上运行日志收集 &lt;strong&gt;Daemon&lt;/strong&gt;，比如：&lt;strong&gt;flunentd&lt;/strong&gt; 或 &lt;strong&gt;logstash&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;在每个节点上运行监控 &lt;strong&gt;Daemon&lt;/strong&gt;，比如：&lt;strong&gt;Prometheus Node Exporter&lt;/strong&gt; 或 &lt;strong&gt;collectd&lt;/strong&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;h5 id=&#34;查看k8s-的-daemonset&#34;&gt;查看k8s 的 DaemonSet&lt;/h5&gt;
&lt;p&gt;&lt;strong&gt;Kubernetes&lt;/strong&gt; 自己就在用 &lt;strong&gt;DaemonSet&lt;/strong&gt; 运行系统组件。执行如下命令查看：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;kubectl get daemonset --``namespace``=kube-system&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;u&gt;(配一张截图)&lt;/u&gt;&lt;/em&gt;&lt;/p&gt;
&lt;h4 id=&#34;promql概念应用实例&#34;&gt;PromQL概念&amp;amp;应用实例&lt;/h4&gt;
&lt;h5 id=&#34;概念&#34;&gt;概念&lt;/h5&gt;
&lt;p&gt;Prometheus通过指标名称（metrics name）以及对应的一组标签（labelset）唯一定义一条时间序列。指标名称反映了监控样本的基本标识，而label则在这个基本特征上为采集到的数据提供了多种特征维度。用户可以基于这些特征维度过滤，聚合，统计从而产生新的计算后的一条时间序列。&lt;/p&gt;
&lt;h5 id=&#34;应用实例&#34;&gt;应用实例&lt;/h5&gt;
&lt;ol&gt;
&lt;li&gt;各节点磁盘使用率&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;code&gt;node_filesystem_size_bytes{fstype=~\&amp;quot;xfs|ext4\&amp;quot;} - node_filesystem_free_bytes) / node_filesystem_size_bytes&lt;/code&gt;&lt;/p&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;各节点内存使用率&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;code&gt;node_memory_MemTotal_bytes - node_memory_MemAvailable_bytes) / node_memory_MemTotal_bytes&lt;/code&gt;&lt;/p&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;各节点磁盘IO读速率(MiB/s)&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;code&gt;irate(node_disk_read_bytes_total{}[5m]) / 1024 / 1024&lt;/code&gt;&lt;/p&gt;
&lt;ol start=&#34;4&#34;&gt;
&lt;li&gt;各节点磁盘IO写速率(MiB/s)&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;code&gt;irate(node_disk_written_bytes_total{}[5m]) / 1024 / 1024&lt;/code&gt;&lt;/p&gt;
&lt;ol start=&#34;5&#34;&gt;
&lt;li&gt;某节点网络IO速率:入速率(MiB/s)&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;code&gt;irate(node_network_receive_bytes_total{job=\&amp;quot;节点名称_node_exporter_metrics\&amp;quot;}[5m]) / 1024 / 1024&lt;/code&gt;&lt;/p&gt;
&lt;ol start=&#34;6&#34;&gt;
&lt;li&gt;某节点网络IO速率:出速率(MiB/s)&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;code&gt;irate(node_network_transmit_bytes_total{job=\&amp;quot;节点名称_node_exporter_metrics\&amp;quot;}[5m]) / 1024 / 1024&lt;/code&gt;&lt;/p&gt;
&lt;ol start=&#34;7&#34;&gt;
&lt;li&gt;&lt;strong&gt;某节点CPU使用率&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;code&gt;100 - (avg by(instance) (irate(node_cpu_seconds_total{mode=\&amp;quot;idle\&amp;quot;, job=\&amp;quot;节点名称_node_exporter_metrics\&amp;quot;}[5m])) * 100)&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;CPU使用率的计算公式：&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;CPU0在5分钟内处于空闲状态的时间：&lt;code&gt;increase(node_cpu_seconds_total{cpu=&amp;quot;0&amp;quot;,mode=&amp;quot;idle&amp;quot;}[5m])&lt;/code&gt;，increase 的意思是表示增量，刚才说了 &lt;code&gt;node_cpu_seconds_total&lt;/code&gt;是单调递增的，这个公式的结果是当前时点的 &lt;code&gt;node_cpu_seconds_total&lt;/code&gt; 减去5分钟之前的 &lt;code&gt;node_cpu_seconds_total&lt;/code&gt;，也就是这5分钟之内处于&lt;code&gt;idle&lt;/code&gt;状态的 CPU时间。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;CPU0在5分钟内处于空闲状态的时间占比：&lt;code&gt;increase(node_cpu_seconds_total{cpu=&amp;quot;0&amp;quot;,mode=&amp;quot;idle&amp;quot;}[5m]) / increase(node_cpu_seconds_total{cpu=&amp;quot;0&amp;quot;}[5m])&lt;/code&gt;，分母其实就是5分钟=300秒。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;一台主机所有CPU在5分钟内处于空闲状态的时间占比&lt;/p&gt;
&lt;p&gt;用 &lt;code&gt;sum()&lt;/code&gt;函数累加各核数值：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;sum (increase(node_cpu_seconds_total{mode=&amp;quot;idle&amp;quot;}[5m])) / sum (increase(node_cpu_seconds_total{mode=&amp;quot;idle&amp;quot;}[5m]))&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如果 Prometheus 监控多台主机，要根据每台主机做 sum：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;sum by (instance)(increase(node_cpu_seconds_total{mode=&amp;quot;idle&amp;quot;}[5m])) / sum by (instance)(increase(node_cpu_seconds_total[5m]))&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;CPU使用率 = 1 - CPU空闲率：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;100 * (1 - sum by (instance)(increase(node_cpu_seconds_total{mode=&amp;quot;idle&amp;quot;}[5m])) / sum by (instance)(increase(node_cpu_seconds_total[5m])))&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;PromQL 有计算比率的函数：&lt;code&gt;rate()&lt;/code&gt; 和 &lt;code&gt;irate()&lt;/code&gt;，可以简化计算公式为:&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;code&gt;100 - (avg by(instance) (irate(node_cpu_seconds_total{mode=&amp;quot;idle&amp;quot;}[5m])) * 100)&lt;/code&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
">Prometheus</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://Czardas42.github.io/post/chapter6_6.3/"" data-c="
          &lt;h2 id=&#34;判断记录质数的方法&#34;&gt;判断/记录质数的方法&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;sqrt(n)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;素数筛法&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;1-素数判定&#34;&gt;1.  素数判定&lt;/h2&gt;
&lt;h3 id=&#34;题目描述&#34;&gt;&lt;strong&gt;题目描述&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;给定一个数n，要求判断其是否为素数（0,1，负数都是非素数）。&lt;/p&gt;
&lt;h3 id=&#34;要点&#34;&gt;&lt;strong&gt;要点&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;对于负数、0、1要特别处理&lt;/p&gt;
&lt;h3 id=&#34;提交地址&#34;&gt;提交地址&lt;/h3&gt;
&lt;p&gt;&lt;a href=&#34;https://www.nowcoder.com/practice/5fd9c28b1ce746dd99287a04d8fa9002?tpId=40&amp;amp;qru=%2Fta%2Ftsing-kaoyan%2Fquestion-ranking&amp;amp;tab=answerKey&#34;&gt;https://www.nowcoder.com/practice/5fd9c28b1ce746dd99287a04d8fa9002?tpId=40&amp;amp;qru=%2Fta%2Ftsing-kaoyan%2Fquestion-ranking&amp;amp;tab=answerKey&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&#34;代码&#34;&gt;代码&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;#include &amp;lt;iostream&amp;gt;
#include &amp;lt;cstdio&amp;gt;
#include &amp;lt;cmath&amp;gt;
using namespace std;

int main()
{
    int num;
    while (cin &amp;gt;&amp;gt; num)
    {
        if (num&amp;lt;=1)
        {
            cout &amp;lt;&amp;lt; &amp;quot;no&amp;quot; &amp;lt;&amp;lt; endl;
            continue;
        }
        
        bool flag = true;
        for (int i=num-1; i&amp;gt;=sqrt(num); i--)
        {
            if (num % i ==0)
            {
                flag = false;
                break;
            }
        }
        
        if (flag == true)
        {
            cout &amp;lt;&amp;lt; &amp;quot;yes&amp;quot; &amp;lt;&amp;lt; endl;
        }
        else
        {
            cout &amp;lt;&amp;lt; &amp;quot;no&amp;quot; &amp;lt;&amp;lt; endl;
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;2-素数&#34;&gt;2.  素数&lt;/h2&gt;
&lt;h3 id=&#34;题目描述-2&#34;&gt;&lt;strong&gt;题目描述&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;输入一个整数n(2&amp;lt;=n&amp;lt;=10000)，要求输出所有从1到这个整数之间(不包括1和这个整数)个位为1的素数，如果没有则输出-1。&lt;/p&gt;
&lt;h3 id=&#34;要点-2&#34;&gt;&lt;strong&gt;要点&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;方法一：穷举&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;方法二【素数筛法】：找到一个素数，就要标记其所有倍数为非负数无需再针对每个数字进行判断&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;（实际操作中，只需从平方开始标记即可）&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&#34;提交地址-2&#34;&gt;提交地址&lt;/h3&gt;
&lt;p&gt;&lt;a href=&#34;https://www.nowcoder.com/practice/7f4be54b37a04fdaa4ee545819151114?tpId=40&amp;amp;qru=%2Fta%2Ftsing-kaoyan%2Fquestion-ranking&amp;amp;tab=answerKey&#34;&gt;https://www.nowcoder.com/practice/7f4be54b37a04fdaa4ee545819151114?tpId=40&amp;amp;qru=%2Fta%2Ftsing-kaoyan%2Fquestion-ranking&amp;amp;tab=answerKey&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&#34;代码穷举&#34;&gt;代码（穷举）&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;#include &amp;lt;iostream&amp;gt;
#include &amp;lt;cstdio&amp;gt;
#include &amp;lt;cmath&amp;gt;

using namespace std;

int main()
{
    int range;
    while (cin &amp;gt;&amp;gt; range)
    {
        if (range &amp;lt;= 11)
        {
            cout &amp;lt;&amp;lt; &amp;quot;-1&amp;quot; &amp;lt;&amp;lt; endl;
            continue;
        }
        
        for (int num =11; num&amp;lt;range; num++)
        {
            bool flag = true;
            for (int i=num-1; i&amp;gt;=sqrt(num); i--)
            {
                if (num % i == 0)
                {
                    flag = false;
                    break;
                }
            }
            
            if ((flag == true) &amp;amp;&amp;amp; (num%10 == 1))
            {
                if (num == 11)
                    cout &amp;lt;&amp;lt; num;
                else
                    cout &amp;lt;&amp;lt; &amp;quot; &amp;quot; &amp;lt;&amp;lt; num ;
            }
        }
        cout &amp;lt;&amp;lt; endl;
    }
    
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;代码素数筛法&#34;&gt;代码（素数筛法）&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;#include &amp;lt;iostream&amp;gt;
#include &amp;lt;cstdio&amp;gt;
#include &amp;lt;cmath&amp;gt;
#include &amp;lt;vector&amp;gt;

using namespace std;

int main()
{
    int range;
    while (cin &amp;gt;&amp;gt; range)
    {
        if (range &amp;lt;=11)
        {
            cout &amp;lt;&amp;lt; &amp;quot;-1\n&amp;quot;;
            break;
        }
        
        bool num[10000];
        vector&amp;lt;int&amp;gt; prime;
        //初始化
        num[0] = false;
        num[1] = false;
        for (int i=2; i&amp;lt;10000; i++)
            num[i] = true;
        
        for (int temp=2; temp&amp;lt;range; temp++)
        {           
            if (num[temp] == true)
            {
                prime.push_back(temp);//加入素数组
                //标记之后temp的倍数不是素数
                for (int j=temp*temp; j&amp;lt;range; j=j+temp)
                    num[j] = false;
            }
        }
        
        //输出
        for (int i=0; i&amp;lt;prime.size(); i++)
        {
            if(prime[i] % 10 == 1)
            {
                if (prime[i] == 11)
                    cout &amp;lt;&amp;lt; prime[i];
                else                
                    cout &amp;lt;&amp;lt; &amp;quot; &amp;quot; &amp;lt;&amp;lt; prime[i];
            }
        }
        cout &amp;lt;&amp;lt; endl;        
    }
    
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;3-prime-number&#34;&gt;3.  Prime Number&lt;/h2&gt;
&lt;h3 id=&#34;题目描述-3&#34;&gt;&lt;strong&gt;题目描述&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;Output the k-th prime number.&lt;/p&gt;
&lt;h3 id=&#34;要点-3&#34;&gt;&lt;strong&gt;要点&lt;/strong&gt;&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;素数筛法&lt;/li&gt;
&lt;li&gt;提前存好10000个素数：范围开到1000000就够用，或者可以记录素数个数&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;适当可以使用void函数，让main函数看起来更加简洁&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;提交地址-3&#34;&gt;提交地址&lt;/h3&gt;
&lt;p&gt;&lt;a href=&#34;https://www.nowcoder.com/practice/c5f8688cea8a4a9a88edbd67d1358415?tpId=40&amp;amp;qru=%2Fta%2Ftsing-kaoyan%2Fquestion-ranking&amp;amp;tab=answerKey&#34;&gt;https://www.nowcoder.com/practice/c5f8688cea8a4a9a88edbd67d1358415?tpId=40&amp;amp;qru=%2Fta%2Ftsing-kaoyan%2Fquestion-ranking&amp;amp;tab=answerKey&lt;/a&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;#include &amp;lt;iostream&amp;gt;
#include &amp;lt;cstdio&amp;gt;
#include &amp;lt;vector&amp;gt;

using namespace std;

int order;
vector&amp;lt;int&amp;gt; prime;
const int range = 1000000;

void Initial()
{
    bool num[range];
    for (int i=0; i&amp;lt;range; i++)
        num[i] = true;
    num[0] = false;
    num[1] = false;
    
    for (int temp=0; temp&amp;lt;range; temp++)
    {
        if (num[temp] == true)
        {
            prime.push_back(temp);
            
            for (int j=temp*temp; j&amp;lt;range; j=j+temp)
                num[j] = false;
        }
    }
};

int main()
{
    Initial();      
    while (cin &amp;gt;&amp;gt; order)
    {
        cout &amp;lt;&amp;lt; prime[order-1] &amp;lt;&amp;lt; endl;
    }
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
">Chapter6数学问题：6.3质数</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://Czardas42.github.io/post/chapter6_6.2/"" data-c="
          &lt;h2 id=&#34;辗转相除法&#34;&gt;辗转相除法&lt;/h2&gt;
&lt;h2 id=&#34;1-最大公约数&#34;&gt;1.  最大公约数&lt;/h2&gt;
&lt;h3 id=&#34;题目描述&#34;&gt;&lt;strong&gt;题目描述&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;输入两个正整数，求其最大公约数。&lt;/p&gt;
&lt;h3 id=&#34;要点&#34;&gt;&lt;strong&gt;要点&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;递归实现辗转相除法GCD&lt;/p&gt;
&lt;h3 id=&#34;提交地址&#34;&gt;提交地址&lt;/h3&gt;
&lt;p&gt;&lt;a href=&#34;https://www.nowcoder.com/practice/20216f2c84bc438eb5ef05e382536fd3?tpId=40&amp;amp;qru=%2Fta%2Ftsing-kaoyan%2Fquestion-ranking&amp;amp;tab=answerKey&#34;&gt;https://www.nowcoder.com/practice/20216f2c84bc438eb5ef05e382536fd3?tpId=40&amp;amp;qru=%2Fta%2Ftsing-kaoyan%2Fquestion-ranking&amp;amp;tab=answerKey&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&#34;代码&#34;&gt;代码&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;#include &amp;lt;iostream&amp;gt;
#include &amp;lt;cstdio&amp;gt;

using namespace std;

int GCD(int a, int b)
{
    if(a%b == 0) //a可以整除b：b是最大公约数
    {
        return b;
    }
    else
    {
        return GCD(b, a%b);
    }
}

int main()
{
    int num1, num2;
    while(cin &amp;gt;&amp;gt; num1 &amp;gt;&amp;gt; num2)
    {
        cout &amp;lt;&amp;lt; GCD(num1, num2) &amp;lt;&amp;lt; endl;
    }
    
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;2-最小公倍数&#34;&gt;2.  最小公倍数&lt;/h2&gt;
&lt;h3 id=&#34;题目描述-2&#34;&gt;&lt;strong&gt;题目描述&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;输入两个正整数，求其最小公约数。&lt;/p&gt;
&lt;h3 id=&#34;要点-2&#34;&gt;&lt;strong&gt;要点&lt;/strong&gt;&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;最小公倍数 = 两数乘积 / 最大公约数&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;递归实现辗转相除法&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;提交地址-2&#34;&gt;提交地址&lt;/h3&gt;
&lt;p&gt;&lt;a href=&#34;https://www.nowcoder.com/practice/22948c2cad484e0291350abad86136c3?tpId=37&amp;amp;qru=%2Fta%2Ftsing-kaoyan%2Fquestion-ranking&amp;amp;tab=answerKey&#34;&gt;https://www.nowcoder.com/practice/22948c2cad484e0291350abad86136c3?tpId=37&amp;amp;qru=%2Fta%2Ftsing-kaoyan%2Fquestion-ranking&amp;amp;tab=answerKey&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&#34;代码-2&#34;&gt;代码&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;#include &amp;lt;iostream&amp;gt;
#include &amp;lt;cstdio&amp;gt;

using namespace std;

int GCD(int a, int b)
{
    if(a%b == 0)
    {
        return b;
    }
    else
    {
        return GCD(b, a%b);
    }
}

int main()
{
    int num1, num2;
    while (cin &amp;gt;&amp;gt; num1 &amp;gt;&amp;gt; num2)
    {
        int temp = num1 * num2;
        int result = temp / GCD(num1, num2);
        cout &amp;lt;&amp;lt; result &amp;lt;&amp;lt; endl;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;3-最简真分数&#34;&gt;3.  最简真分数&lt;/h2&gt;
&lt;h3 id=&#34;题目描述-3&#34;&gt;&lt;strong&gt;题目描述&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;给出n个正整数，任取两个数分别作为分子和分母组成最简真分数，编程求共有几个这样的组合。&lt;/p&gt;
&lt;h3 id=&#34;要点-3&#34;&gt;&lt;strong&gt;要点&lt;/strong&gt;&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;最简真分数：分子&amp;lt;分母；分子分母最大公约数为1&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;因为真分数的要求，最终结果/2&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;提交地址-3&#34;&gt;提交地址&lt;/h3&gt;
&lt;p&gt;&lt;a href=&#34;https://www.nowcoder.com/practice/1f1db273eeb745c6ac83e91ff14d2ec9?tpId=40&amp;amp;qru=%2Fta%2Ftsing-kaoyan%2Fquestion-ranking&amp;amp;tab=answerKey&#34;&gt;https://www.nowcoder.com/practice/1f1db273eeb745c6ac83e91ff14d2ec9?tpId=40&amp;amp;qru=%2Fta%2Ftsing-kaoyan%2Fquestion-ranking&amp;amp;tab=answerKey&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&#34;代码-3&#34;&gt;代码&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;#include &amp;lt;iostream&amp;gt;
#include &amp;lt;cstdio&amp;gt;
#include &amp;lt;vector&amp;gt;

using namespace std;

int GCD(int a, int b)
{
    if(a%b == 0)
        return b;
    else
        return GCD(b, a%b);
};

int main()
{
    int count;
    while(cin &amp;gt;&amp;gt; count)
    {
        if (count == 0)
            break;
        //存入数据
        vector&amp;lt;int&amp;gt; number;
        int num;
        for (int i=0; i&amp;lt;count; i++)
        {
            cin &amp;gt;&amp;gt; num;
            number.push_back(num);
        }
        //遍历
        int result = 0;
        for (int i=0; i&amp;lt;number.size(); i++)
        {
            for (int j=0; j&amp;lt;number.size(); j++)
            {
                int temp = GCD(number[i], number[j]);
                if (temp==1)
                {//两数最大公约数是1
                    result++;
                }
            }
        }
        cout &amp;lt;&amp;lt; result/2 &amp;lt;&amp;lt; endl;  //真分数&amp;lt;1,所以结果/2         
    }
    
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
">Chapter6数学问题：6.2 最大公约数和最小公倍数</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://Czardas42.github.io/post/chapter6_6.1/"" data-c="
          &lt;h2 id=&#34;进制转换原理&#34;&gt;进制转换原理&lt;/h2&gt;
&lt;h2 id=&#34;1-二进制数&#34;&gt;1.  二进制数&lt;/h2&gt;
&lt;h3 id=&#34;题目描述&#34;&gt;&lt;strong&gt;题目描述&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;大家都知道，数据在计算机里中存储是以二进制的形式存储的。 有一天，小明学了C语言之后，他想知道一个类型为unsigned int 类型的数字，存储在计算机中的二进制串是什么样子的。 你能帮帮小明吗？并且，小明不想要二进制串中前面的没有意义的0串，即要去掉前导0。&lt;/p&gt;
&lt;h3 id=&#34;要点&#34;&gt;&lt;strong&gt;要点&lt;/strong&gt;&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;进制转换标准公式&lt;/li&gt;
&lt;li&gt;以及while循环判断条件&lt;code&gt;while (num != 0)&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;提交地址&#34;&gt;提交地址&lt;/h3&gt;
&lt;p&gt;&lt;a href=&#34;https://www.nowcoder.com/practice/103dd589fed14457a673c613d8de3841?tpId=40&amp;amp;qru=%2Fta%2Ftsing-kaoyan%2Fquestion-ranking&amp;amp;tab=answerKey&#34;&gt;https://www.nowcoder.com/practice/103dd589fed14457a673c613d8de3841?tpId=40&amp;amp;qru=%2Fta%2Ftsing-kaoyan%2Fquestion-ranking&amp;amp;tab=answerKey&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&#34;代码&#34;&gt;代码&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;#include &amp;lt;iostream&amp;gt;
#include &amp;lt;cstdio&amp;gt;
#include &amp;lt;string&amp;gt;

using namespace std;

int main()
{
    int num;
    while (cin &amp;gt;&amp;gt; num)
    {
        string result = &amp;quot;&amp;quot;;
        
        while (num != 0)
        {
            int temp = num % 2;
            char num_now = char(&#39;0&#39;+temp);
            result = num_now + result;
            num = num / 2;
        }
        
        cout  &amp;lt;&amp;lt; result &amp;lt;&amp;lt; endl;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;2-进制转换&#34;&gt;2. &lt;strong&gt;进制转换&lt;/strong&gt;&lt;/h2&gt;
&lt;h3 id=&#34;题目描述-2&#34;&gt;&lt;strong&gt;题目描述&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;将一个长度最多为30位数字的十进制非负整数转换为二进制数输出。&lt;/p&gt;
&lt;h3 id=&#34;要点-2&#34;&gt;&lt;strong&gt;要点&lt;/strong&gt;&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;数字长度：https://www.runoob.com/cplusplus/cpp-data-types.html&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;unsigned long int&lt;/th&gt;
&lt;th&gt;0 到 18,446,744,073,709,551,615（20位）&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&lt;strong&gt;超过20位的数字运算就只能通过字符串实现&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;字符串类型计算乘除法的方法：模仿手动计算&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;从第一个非0位开始输出：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;设置flag，在第一次遇到非0时将其变为true；&lt;/p&gt;
&lt;p&gt;提前获得非0位的编号&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;提交地址-2&#34;&gt;提交地址&lt;/h3&gt;
&lt;p&gt;&lt;a href=&#34;https://www.nowcoder.com/practice/53447aa04f32460aa20ee11d02416e3b?tpId=40&amp;amp;qru=%2Fta%2Ftsing-kaoyan%2Fquestion-ranking&amp;amp;tab=answerKey&#34;&gt;https://www.nowcoder.com/practice/53447aa04f32460aa20ee11d02416e3b?tpId=40&amp;amp;qru=%2Fta%2Ftsing-kaoyan%2Fquestion-ranking&amp;amp;tab=answerKey&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&#34;代码-2&#34;&gt;代码&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;#include &amp;lt;iostream&amp;gt;
#include &amp;lt;cstdio&amp;gt;
#include &amp;lt;string&amp;gt;

using namespace std;

char GetTemp(string num)//取得字符串num的%2结果
{   //num%2结果 = num最后一位%2的结果
    int temp0 = int(num[num.size()-1] - &#39;0&#39;) % 2;
    char temp = char(temp0 + &#39;0&#39;);
    return temp;
};

string GetNum(string num)//取得字符串num的/2结果
{
    int m = 0;
    string result = num;
    for (int i=0; i&amp;lt;num.size(); i++)
    {   //模仿手动计算除法的过程
        int num_now = int(num[i] - &#39;0&#39;) + m*10;
        result[i] = char(num_now / 2 + &#39;0&#39;);
        m = num_now % 2;
    }
    
    return result;
};

int main()
{
    string num;
    while (cin &amp;gt;&amp;gt; num)
    {
        string result = &amp;quot;&amp;quot;;
        
        //flag：和num位数相同的全零串
        string flag = num;
        for (int i=0; i&amp;lt;flag.size(); i++)
            flag[i] = &#39;0&#39;;
        
        while(num != flag)
        {
            result = GetTemp(num) + result;
            num = GetNum(num);
        }

        //输出：从首个非零位开始
        bool flag2 = false;
        for (int j=0; j&amp;lt;result.size(); j++)
        {
            if (result[j] != &#39;0&#39;)
                flag2 = true;
            
            if (flag2 == true)
                cout &amp;lt;&amp;lt; result[j];
        }
        cout &amp;lt;&amp;lt; endl;        
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;3-十进制vs二进制&#34;&gt;3. &lt;strong&gt;十进制VS二进制&lt;/strong&gt;&lt;/h2&gt;
&lt;h3 id=&#34;题目描述-3&#34;&gt;&lt;strong&gt;题目描述&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;对于一个十进制数A，将A转换为二进制数，然后按位逆序排列，再转换为十进制数B，我们称B为A的二进制逆序数。   例如对于十进制数173，它的二进制形式为10101101，逆序排列得到10110101，其十进制数为181，181即为173的二进制逆序数。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意：一个1000位(即10^999)以内的十进制数。&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&#34;要点-3&#34;&gt;&lt;strong&gt;要点&lt;/strong&gt;&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;法一：字符串类型的加法，乘法，除法，取余&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;法二：大数进制转换&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;参考：&lt;a href=&#34;https://blog.csdn.net/StrongerL/article/details/92702052&#34;&gt;https://blog.csdn.net/StrongerL/article/details/92702052&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;提交地址-3&#34;&gt;提交地址&lt;/h3&gt;
&lt;p&gt;&lt;a href=&#34;https://www.nowcoder.com/practice/53447aa04f32460aa20ee11d02416e3b?tpId=40&amp;amp;qru=%2Fta%2Ftsing-kaoyan%2Fquestion-ranking&amp;amp;tab=answerKey&#34;&gt;https://www.nowcoder.com/practice/53447aa04f32460aa20ee11d02416e3b?tpId=40&amp;amp;qru=%2Fta%2Ftsing-kaoyan%2Fquestion-ranking&amp;amp;tab=answerKey&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&#34;代码-3&#34;&gt;代码&lt;/h3&gt;
">Chapter6数学问题：6.1 进制转换</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://Czardas42.github.io/post/chapter5-5.3/"" data-c="
          &lt;h2 id=&#34;栈的基本操作&#34;&gt;栈的基本操作&lt;/h2&gt;
&lt;p&gt;只能在栈顶进行操作&lt;/p&gt;
&lt;p&gt;重点用于处理逆序问题&lt;/p&gt;
&lt;h2 id=&#34;1-zero-complexity-transposition逆序输出&#34;&gt;1.  Zero-complexity Transposition（逆序输出）&lt;/h2&gt;
&lt;h3 id=&#34;题目描述&#34;&gt;&lt;strong&gt;题目描述&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;You are given a sequence of integer numbers. Zero-complexity transposition of the sequence is the reverse of this sequence. Your task is to write a program that prints zero-complexity transposition of the given sequence.&lt;/p&gt;
&lt;h3 id=&#34;要点&#34;&gt;&lt;strong&gt;要点&lt;/strong&gt;&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;利用栈的结构完成逆序输出&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;提交地址&#34;&gt;提交地址&lt;/h3&gt;
&lt;p&gt;&lt;a href=&#34;https://www.nowcoder.com/practice/c54775799f634c72b447ef31eb36e975?tpId=40&amp;amp;qru=%2Fta%2Ftsing-kaoyan%2Fquestion-ranking&amp;amp;tab=answerKey&#34;&gt;https://www.nowcoder.com/practice/c54775799f634c72b447ef31eb36e975?tpId=40&amp;amp;qru=%2Fta%2Ftsing-kaoyan%2Fquestion-ranking&amp;amp;tab=answerKey&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&#34;代码&#34;&gt;代码&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;#include &amp;lt;iostream&amp;gt;
#include &amp;lt;stack&amp;gt;
#include &amp;lt;cstdio&amp;gt;

using namespace std;

int main()
{
    int count;
    stack&amp;lt;int&amp;gt; record;
    
    while(cin &amp;gt;&amp;gt; count)
    {
        int num;
        for (int i=0; i&amp;lt;count; i++)
        {
            cin &amp;gt;&amp;gt; num;
            record.push(num);
        }
        
        for (int i=0; i&amp;lt;count; i++)
        {
            if (record.empty())
            {
                cout &amp;lt;&amp;lt; record.top() &amp;lt;&amp;lt; endl;
                record.pop();
            }
            else
            {
                cout &amp;lt;&amp;lt; record.top() &amp;lt;&amp;lt; &amp;quot; &amp;quot;;
                record.pop();
            }          
        }    
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;2-括号序列&#34;&gt;2. &lt;strong&gt;括号序列&lt;/strong&gt;&lt;/h2&gt;
&lt;h3 id=&#34;题目描述-2&#34;&gt;&lt;strong&gt;题目描述&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;给出一个仅包含字符&#39;(&#39;,&#39;)&#39;,&#39;{&#39;,&#39;}&#39;,&#39;[&#39;和&#39;]&#39;,的字符串，判断给出的字符串是否是合法的括号序列&lt;br&gt;
括号必须以正确的顺序关闭，&amp;quot;()&amp;quot;和&amp;quot;()[]{}&amp;quot;都是合法的括号序列，但&amp;quot;(]&amp;quot;和&amp;quot;([)]&amp;quot;不合法。&lt;/p&gt;
&lt;h3 id=&#34;要点-2&#34;&gt;&lt;strong&gt;要点&lt;/strong&gt;&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;利用栈的结构完成序号匹配（思想参考编译原理）&lt;/li&gt;
&lt;li&gt;若符合规则，就将一对符号弹出&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;提交地址-2&#34;&gt;提交地址&lt;/h3&gt;
&lt;p&gt;&lt;a href=&#34;https://www.nowcoder.com/practice/6235a76b1e404f748f7c820583125c50?tpId=8&amp;amp;qru=%2Fta%2Ftsing-kaoyan%2Fquestion-ranking&amp;amp;tab=answerKey&#34;&gt;https://www.nowcoder.com/practice/6235a76b1e404f748f7c820583125c50?tpId=8&amp;amp;qru=%2Fta%2Ftsing-kaoyan%2Fquestion-ranking&amp;amp;tab=answerKey&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&#34;代码-2&#34;&gt;代码&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;class Solution {
public:
    /**
     * 
     * @param s string字符串 
     * @return bool布尔型
     */
    bool isValid(string s) {
        // write code here
        stack&amp;lt;char&amp;gt; record;
        for (int i=0; i&amp;lt;s.size(); i++)
        {
            int temp = s[i];
            if (!record.empty())
            {                
                int symbol = record.top();
                if (  (temp==&#39;)&#39; &amp;amp;&amp;amp; symbol==&#39;(&#39;)
                    ||(temp==&#39;]&#39; &amp;amp;&amp;amp; symbol==&#39;[&#39;)
                    ||(temp==&#39;}&#39; &amp;amp;&amp;amp; symbol==&#39;{&#39;)
                   )
                {
                    record.pop();
                }
                else
                {
                    record.push(temp);
                }
                   
            }
            else
            {
                record.push(temp);
            }           
        }
        
        if (record.empty())
            return true;
        else
            return false;
    }
};
&lt;/code&gt;&lt;/pre&gt;
">Chapter5数据结构一：5.3 栈</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://Czardas42.github.io/post/chapter5_5.2/"" data-c="
          &lt;h2 id=&#34;队列基本操作&#34;&gt;队列基本操作&lt;/h2&gt;
&lt;h2 id=&#34;1-约瑟夫问题&#34;&gt;1. &lt;strong&gt;约瑟夫问题&lt;/strong&gt;&lt;/h2&gt;
&lt;h3 id=&#34;题目描述&#34;&gt;&lt;strong&gt;题目描述&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;编号为 1 到 n的 n个人围成一圈。从编号为 11 的人开始报数，报到 m的人离开。&lt;/p&gt;
&lt;p&gt;下一个人继续从 11 开始报数。&lt;/p&gt;
&lt;p&gt;n-1轮结束以后，只剩下一个人，问最后留下的这个人编号是多少？&lt;/p&gt;
&lt;h3 id=&#34;要点&#34;&gt;&lt;strong&gt;要点&lt;/strong&gt;&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;利用队列模拟的思想&lt;/li&gt;
&lt;li&gt;不需循环列表也可以完成&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;提交地址&#34;&gt;提交地址&lt;/h3&gt;
&lt;p&gt;&lt;a href=&#34;https://www.nowcoder.com/practice/41c399fdb6004b31a6cbb047c641ed8a?tpId=196&amp;amp;qru=%2Fta%2Ftsing-kaoyan%2Fquestion-ranking&amp;amp;tab=answerKey&#34;&gt;https://www.nowcoder.com/practice/41c399fdb6004b31a6cbb047c641ed8a?tpId=196&amp;amp;qru=%2Fta%2Ftsing-kaoyan%2Fquestion-ranking&amp;amp;tab=answerKey&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&#34;代码&#34;&gt;代码&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;class Solution {
public:
    /**
     * @param n int整型 
     * @param m int整型 
     * @return int整型
     */
    int ysf(int n, int m) {
        // write code here
        queue&amp;lt;int&amp;gt; line;
        //全部入队
        for (int i=1; i&amp;lt;=n; i++)
        {
            line.push(i);
        }
        //开始模拟
        for (int j=1; j&amp;lt;n; j++)//n-1轮游戏
        {
            for (int i=1; i&amp;lt;m; i++)
            {
                int temp = line.front();
                line.pop();
                line.push(temp);
            }
            line.pop();
        }
        
        return line.front();
    }
};
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;2-猫狗收容所&#34;&gt;2. &lt;strong&gt;猫狗收容所&lt;/strong&gt;&lt;/h2&gt;
&lt;h3 id=&#34;题目描述-2&#34;&gt;&lt;strong&gt;题目描述&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;有家动物收容所只收留猫和狗，但有特殊的收养规则，收养人有两种收养方式，第一种为直接收养所有动物中最早进入收容所的，第二种为选择收养的动物类型（猫或狗），并收养该种动物中最早进入收容所的。&lt;/p&gt;
&lt;p&gt;给定一个操作序列int[][2] ope(C++中为vector&lt;vector&gt;)代表所有事件。若第一个元素为1，则代表有动物进入收容所，第二个元素为动物的编号，正数代表狗，负数代表猫；若第一个元素为2，则代表有人收养动物，第二个元素若为0，则采取第一种收养方式，若为1，则指定收养狗，若为-1则指定收养猫。请按顺序返回收养的序列。若出现不合法的操作，即没有可以符合领养要求的动物，则将这次领养操作忽略。&lt;/p&gt;
&lt;h3 id=&#34;要点-2&#34;&gt;&lt;strong&gt;要点&lt;/strong&gt;&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;利用两个队列分别记录猫狗&lt;/li&gt;
&lt;li&gt;animal结构体：&lt;strong&gt;记录type和时间tag&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;注意讨论收养时猫狗列表可能为空的情况&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;提交地址-2&#34;&gt;提交地址&lt;/h3&gt;
&lt;p&gt;&lt;a href=&#34;https://www.nowcoder.com/practice/6235a76b1e404f748f7c820583125c50?tpId=8&amp;amp;qru=%2Fta%2Ftsing-kaoyan%2Fquestion-ranking&amp;amp;tab=answerKey&#34;&gt;https://www.nowcoder.com/practice/6235a76b1e404f748f7c820583125c50?tpId=8&amp;amp;qru=%2Fta%2Ftsing-kaoyan%2Fquestion-ranking&amp;amp;tab=answerKey&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&#34;代码-2&#34;&gt;代码&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;class CatDogAsylum {
public:
    struct animal
    {
        int type;
        int order;
        animal(int t, int o)
        {
            type = t;
            order = o;
        }
    };
    vector&amp;lt;int&amp;gt; asylum(vector&amp;lt;vector&amp;lt;int&amp;gt; &amp;gt; ope) 
    {
        // write code here
        queue&amp;lt;animal&amp;gt; cats, dogs;
        int order = 0;
        vector&amp;lt;int&amp;gt; result;
        for (int i=0; i&amp;lt;ope.size(); i++)
        {
            vector&amp;lt;int&amp;gt; item = ope[i];
            int method = item[0];
            int type = item[1];
            
            if (method == 1) //有动物进入
            {
                if (type &amp;gt; 0) //狗
                {
                    order++;
                    dogs.push(animal(type, order));
                }
                else if (type &amp;lt; 0) //猫
                {
                    order++;
                    cats.push(animal(type, order));
                }
            }
            else if (method == 2) //有人收养
            {
                animal dog = dogs.front();
                animal cat = cats.front();
                
                if (type == 0) //直接收养最早进入的
                {
                    if (dog.order&amp;lt;cat.order &amp;amp;&amp;amp; !dogs.empty() &amp;amp;&amp;amp; !cats.empty())
                    {
                        result.push_back(dog.type);
                        dogs.pop();
                    }
                    else if (dog.order&amp;gt;cat.order &amp;amp;&amp;amp; !dogs.empty() &amp;amp;&amp;amp; !cats.empty())
                    {
                        result.push_back(cat.type);
                        cats.pop();
                    }
                    else if (dogs.empty())
                    {
                        result.push_back(cat.type);
                        cats.pop();
                    }
                    else if (cats.empty())
                    {
                        result.push_back(dog.type);
                        dogs.pop();
                    }
                }
                else if (type == 1 &amp;amp;&amp;amp; !dogs.empty()) //指定收养狗
                {
                    result.push_back(dog.type);
                    dogs.pop();
                }
                else if (type == -1 &amp;amp;&amp;amp; !cats.empty()) //指定收养猫
                {
                    result.push_back(cat.type);
                    cats.pop();
                }
            }
        }
        return result;
    }
};
&lt;/code&gt;&lt;/pre&gt;
">Chapter5数据结构一：5.2 队列</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://Czardas42.github.io/post/chapter5_5.1/"" data-c="
          &lt;h2 id=&#34;向量基本操作&#34;&gt;向量基本操作&lt;/h2&gt;
&lt;h2 id=&#34;完数与盈数&#34;&gt;&lt;strong&gt;完数与盈数&lt;/strong&gt;&lt;/h2&gt;
&lt;h3 id=&#34;题目描述&#34;&gt;&lt;strong&gt;题目描述&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;一个数如果恰好等于它的各因子（该数本身除外）子和，如：6=3+2+1，则称其为“完数”；若因子之和大于该数，则称其为“盈数”。求出2 到60 之间所有“完数”和“盈数”，并以如下形式输出： E: e1 e2 e3 ......(ei 为完数) G: g1 g2 g3 ......(gi 为盈数)&lt;/p&gt;
&lt;h3 id=&#34;要点&#34;&gt;&lt;strong&gt;要点&lt;/strong&gt;&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;vector.pop_back()&lt;/code&gt;是弹出最后一个元素&lt;/li&gt;
&lt;li&gt;vector遍历方法：&lt;code&gt;vector.size()&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;求因子的方法：&lt;code&gt;num % i == 0&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;提交地址&#34;&gt;提交地址&lt;/h3&gt;
&lt;p&gt;&lt;a href=&#34;https://www.nowcoder.com/practice/df0d850e41894d06a165bf445ec8a8b4?tpId=40&amp;amp;qru=%2Fta%2Ftsing-kaoyan%2Fquestion-ranking&amp;amp;tab=answerKey&#34;&gt;https://www.nowcoder.com/practice/df0d850e41894d06a165bf445ec8a8b4?tpId=40&amp;amp;qru=%2Fta%2Ftsing-kaoyan%2Fquestion-ranking&amp;amp;tab=answerKey&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&#34;代码&#34;&gt;代码&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;#include &amp;lt;iostream&amp;gt;
#include &amp;lt;cstdio&amp;gt;
#include &amp;lt;vector&amp;gt;

using namespace std;

int Sum(int num)
{
    int sum = 0;
    for (int i=1; i&amp;lt;num; i++)
    {
        if (num % i == 0)
        {
            sum += i;
        }
    }
    return sum;
};

int main()
{
    vector&amp;lt;int&amp;gt; E, G;
    for (int i=2; i&amp;lt;=60; i++)
    {
        int sum = Sum(i);
        if (i == sum)
        {   
            E.push_back(i);
        }
        else if (i &amp;lt; sum)
        {
            G.push_back(i);
        }
    }
    //输出E
    cout &amp;lt;&amp;lt; &amp;quot;E:&amp;quot;;
    for (int j=0; j&amp;lt;E.size(); j++)
    {
        cout &amp;lt;&amp;lt; &amp;quot; &amp;quot; &amp;lt;&amp;lt; E[j];
    }
    //输出G
    cout &amp;lt;&amp;lt; &amp;quot; G:&amp;quot;;
    for (int j=0; j&amp;lt;G.size(); j++)
    {
        cout &amp;lt;&amp;lt; &amp;quot; &amp;quot; &amp;lt;&amp;lt; G[j];
    }
    cout &amp;lt;&amp;lt; endl;
}
&lt;/code&gt;&lt;/pre&gt;
">Chapter5数据结构一：5.1 向量</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://Czardas42.github.io/post/chapter4_4.3/"" data-c="
          &lt;h2 id=&#34;kmp算法&#34;&gt;KMP算法&lt;/h2&gt;
&lt;h2 id=&#34;1-string-matching&#34;&gt;&lt;strong&gt;1. String Matching&lt;/strong&gt;&lt;/h2&gt;
&lt;h3 id=&#34;题目描述&#34;&gt;&lt;strong&gt;题目描述&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;Finding all occurrences of a pattern in a text is a problem that arises frequently in text-editing programs.   Typically,the text is a document being edited,and the pattern searched for is a particular word supplied by the user.    We assume that the text is an array T[1..n] of length n and that the pattern is an array P[1..m] of length m&amp;lt;=n.We further assume that the elements of P and T are all alphabets(∑={a,b...,z}).The character arrays P and T are often called strings of characters.    We say that pattern P occurs with shift s in the text T if 0&amp;lt;=s&amp;lt;=n and T[s+1..s+m] = P[1..m](that is if T[s+j]=P[j],for 1&amp;lt;=j&amp;lt;=m).    If P occurs with shift s in T,then we call s a valid shift;otherwise,we calls a invalid shift.   Your task is to calculate the number of vald shifts for the given text T and p attern P.&lt;/p&gt;
&lt;h3 id=&#34;要点&#34;&gt;&lt;strong&gt;要点&lt;/strong&gt;&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;KMP算法&lt;/strong&gt;，nextTable构建方式 &lt;strong&gt;（两个函数）&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;返回第一个匹配子串/返回全部匹配子串个数&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;提交地址&#34;&gt;提交地址&lt;/h3&gt;
&lt;p&gt;&lt;a href=&#34;https://www.nowcoder.com/practice/00438b0bc9384ceeb65613346b42e88a?tpId=40&amp;amp;qru=%2Fta%2Ftsing-kaoyan%2Fquestion-ranking&amp;amp;tab=answerKey&#34;&gt;https://www.nowcoder.com/practice/00438b0bc9384ceeb65613346b42e88a?tpId=40&amp;amp;qru=%2Fta%2Ftsing-kaoyan%2Fquestion-ranking&amp;amp;tab=answerKey&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&#34;代码&#34;&gt;代码&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;#include &amp;lt;iostream&amp;gt;
#include &amp;lt;cstdio&amp;gt;
#include &amp;lt;string&amp;gt;

using namespace std;

int text[1000000];
int pattern[1000000];
int nextTable[1000000];

void getNextTable(string pattern)
{
    int m = pattern.size();
    nextTable[0] = -1;
    int i=0, j=-1;
    while(i &amp;lt; m)
    {
        if (j == -1 || pattern[i] == pattern[j])
        {
            i++;
            j++;
            nextTable[i] = j;
        }
        else
        {
            j = nextTable[j];
        }
    }
};

int kmp(string text, string pattern)
{
    int m = text.size();
    int n = pattern.size();
    getNextTable(pattern);
    
    int count = 0;
    int i = 0;
    int j = 0;

    while(i &amp;lt; m)
    {
        //匹配
        if ((j == -1) || (text[i] == pattern[j]))
        {
            i++;
            j++;
        }
        else
        {
            j = nextTable[j];
        }
        
        //判断
        if(j == n)
        {
            count++;
            j = nextTable[j];
        }
    }
    
    return count;
};

int main()
{
    string text, pattern;
    while(cin &amp;gt;&amp;gt; text &amp;gt;&amp;gt; pattern)
    {
        int count = kmp(text,pattern);
        cout &amp;lt;&amp;lt; count &amp;lt;&amp;lt; endl;
    }
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;2-字符串匹配&#34;&gt;2. 字符串匹配&lt;/h2&gt;
&lt;h3 id=&#34;题目描述-2&#34;&gt;&lt;strong&gt;题目描述&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;读入数据string[ ]，然后读入一个短字符串。要求查找string[ ]中和短字符串的所有匹配，输出行号、匹配字符串。匹配时不区分大小写，并且可以有一个用中括号表示的模式匹配。如“aa[123]bb”，就是说aa1bb、aa2bb、aa3bb都算匹配。&lt;/p&gt;
&lt;h3 id=&#34;要点-2&#34;&gt;&lt;strong&gt;要点&lt;/strong&gt;&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;注意：题目要求的是完全匹配，即长度完全一样，忽略大小写&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;可以使用&lt;strong&gt;正则表达式&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;#include &amp;lt;regex&amp;gt;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;regex r(st[0], regex::icase); // regex::icase 不区分大小写,建立正则表达式&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;regex_match(st[i], r)&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;提交地址-2&#34;&gt;提交地址&lt;/h3&gt;
&lt;p&gt;&lt;a href=&#34;https://www.nowcoder.com/practice/fbdc522ef958455687654b38a4ca01e0?tpId=40&amp;amp;qru=%2Fta%2Ftsing-kaoyan%2Fquestion-ranking&amp;amp;tab=answerKey&#34;&gt;https://www.nowcoder.com/practice/fbdc522ef958455687654b38a4ca01e0?tpId=40&amp;amp;qru=%2Fta%2Ftsing-kaoyan%2Fquestion-ranking&amp;amp;tab=answerKey&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&#34;代码-2&#34;&gt;代码&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-C++&#34;&gt;#include &amp;lt;cstdio&amp;gt;
#include &amp;lt;iostream&amp;gt;
#include &amp;lt;string&amp;gt;
#include &amp;lt;regex&amp;gt;

using namespace std;
string st[1001];

int main () {
    int n;
    scanf(&amp;quot;%d &amp;quot;, &amp;amp;n);
    for (int i=1; i&amp;lt;=n; ++i)
        getline(cin, st[i]);
    getline(cin, st[0]);
    regex r(st[0], regex::icase);  // regex::icase 不区分大小写
    for (int i=1; i&amp;lt;=n; ++i)
        if (regex_match(st[i], r))  // 这是完全匹配，部分匹配用regex_search
            cout &amp;lt;&amp;lt; i &amp;lt;&amp;lt; &#39; &#39; &amp;lt;&amp;lt; st[i] &amp;lt;&amp;lt; endl;
}
&lt;/code&gt;&lt;/pre&gt;
">Chapter4字符串：4.3 字符串匹配</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://Czardas42.github.io/post/vpc_p2p/"" data-c="
          &lt;h4 id=&#34;概念&#34;&gt;概念&lt;/h4&gt;
&lt;p&gt;对等连接是指两个VPC之间的网络连接。可以使用私有IP地址在两个VPC之间进行通信，就像两个VPC在同一个网络中一样。同一区域内，可以在自己的VPC之间创建对等连接，也可以在自己的VPC与其他帐户的VPC之间创建对等连接。不同区域间的VPC之间不能创建对等连接。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://Czardas42.github.io//post-images/1620200083815.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h4 id=&#34;约束与限制&#34;&gt;约束与限制&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;有重叠子网网段的VPC建立的对等连接，可能不生效。&lt;/li&gt;
&lt;li&gt;两个VPC之间不能同时建立多个VPC对等连接。&lt;/li&gt;
&lt;li&gt;不同区域的VPC不能创建对等连接。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;路由配置&#34;&gt;路由配置&lt;/h4&gt;
&lt;p&gt;如图1所示，VPC1和VPC2需要通过添加路由来建立对等关系。对等连接路由配置如图2所示，配置完成后，VPC1和VPC2就建立了对等关系，可以相互通信。&lt;/p&gt;
&lt;p&gt;指向整个VPC的对等连接的路由配置，目的地址为对端VPC的CIDR，下一跳地址为对等连接ID。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;无类域间路由（Classless Inter-Domain Routing，CIDR）可以将路由集中起来，在路由表中更灵活地定义地址。它不区分 A 类、B 类、C 类地址，而是使用 CIDR 前缀的值指定地址中作为网络 ID 的位数。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;2&#34;&gt;&lt;img src=&#34;https://Czardas42.github.io//post-images/1620200105962.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;3&#34;&gt;&lt;img src=&#34;https://Czardas42.github.io//post-images/1620200120934.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h4 id=&#34;操作流程以跨用户为例&#34;&gt;操作流程（以跨用户为例）&lt;/h4&gt;
&lt;p&gt;跨帐户创建VPC对等连接时，一端VPC发起创建对等连接请求，对等连接状态为待接受。待对方接受该创建请求后，对等连接状态变为已接受，请求方和接受方须分别配置对等连接路由信息，才能使两个VPC互通。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;4&#34;&gt;&lt;img src=&#34;https://Czardas42.github.io//post-images/1620200145251.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;&lt;a href=&#34;https://support.huaweicloud.com/usermanual-vpc/zh-cn_topic_0046655038.html&#34;&gt;https://support.huaweicloud.com/usermanual-vpc/zh-cn_topic_0046655038.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;u&gt;&lt;strong&gt;实验过程中搭建K8s集群所用到VPC对等连接操作实例&lt;/strong&gt;&lt;/u&gt;&lt;/p&gt;
">VPC对等连接</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://Czardas42.github.io/post/openfaas/"" data-c="
          &lt;h4 id=&#34;layers-工作流程&#34;&gt;Layers &amp;amp; 工作流程&lt;/h4&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://Czardas42.github.io//post-images/1620199885176.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;&lt;strong&gt;无服务器函数变得简单&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;推荐的部署OpenFaaS平台都是Kubernetes&lt;/li&gt;
&lt;li&gt;OpenFaaS Cloud建立在OpenFaaS的基础上，可通过GitHub.com或自行托管的GitLab交付GitOps&lt;/li&gt;
&lt;li&gt;NATS提供异步执行和排队&lt;/li&gt;
&lt;li&gt;Prometheus提供指标并通过AlertManager启用自动缩放&lt;/li&gt;
&lt;li&gt;容器注册表包含每个可以通过API部署在OpenFaaS上的不可变工件&lt;/li&gt;
&lt;/ul&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;2&#34;&gt;&lt;img src=&#34;https://Czardas42.github.io//post-images/1620199913601.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;可以通过其REST API，CLI或UI来访问网关。所有服务或功能都会暴露默认路由，但是自定义域也可以用于每个端点。&lt;/p&gt;
&lt;h4 id=&#34;gateway&#34;&gt;Gateway&lt;/h4&gt;
&lt;p&gt;OpenFaaS的Gateway是一个golang实现的请求转发的网关，在这个网关服务中，主要有以下几个功能：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;UI&lt;/li&gt;
&lt;li&gt;部署函数&lt;/li&gt;
&lt;li&gt;监控&lt;/li&gt;
&lt;li&gt;自动伸缩&lt;/li&gt;
&lt;/ul&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;3&#34;&gt;&lt;img src=&#34;https://Czardas42.github.io//post-images/1620199930497.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;从图中可以发现，当Gateway作为一个入口，当CLI或者web页面发来要部署或者调用一个函数的时候，Gateway会将请求转发给Provider，同时会将监控指标发给Prometheus。AlterManager会根据需求，调用API自动伸缩函数。&lt;/p&gt;
&lt;p&gt;Gateway是OpenFaaS最为重要的一个组件。Gateway本质上就是一个rest转发服务，一个一个的handler，每个模块之间的耦合性不是很高，可以很容易的去拆卸，自定义实现相应的模块。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;源码解读：&lt;a href=&#34;https://zhuanlan.zhihu.com/p/41056766&#34;&gt;https://zhuanlan.zhihu.com/p/41056766&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&#34;watchdog&#34;&gt;watchdog&lt;/h4&gt;
&lt;p&gt;watchdog提供了一个外部世界和函数之间的非托管的通用接口。它的工作是收集从API网关来的HTTP请求，然后调用程序。watchdog是一个小型的Golang服务&lt;/p&gt;
&lt;p&gt;下图展示了它是如何工作的：&lt;/p&gt;
&lt;p&gt;一个小型的web服务，可以为每个传入的HTTP请求分配所需要的进程。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;4&#34;&gt;&lt;img src=&#34;https://Czardas42.github.io//post-images/1620199949953.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;每个函数都需要嵌入这个二进制文件并将其作为&lt;code&gt;ENTRYPOINT&lt;/code&gt; 或 &lt;code&gt;CMD&lt;/code&gt;，实际上是把它作为容器的初始化进程。一旦进程被创建分支，watchdog就会通过&lt;code&gt;stdin&lt;/code&gt; 传递HTTP请求并从&lt;code&gt;stdout&lt;/code&gt;中读取HTTP响应。这意味着程序无需知道web和HTTP的任何信息。&lt;/p&gt;
&lt;h4 id=&#34;of-watchdog&#34;&gt;of-watchdog&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;of-watchdog&lt;/code&gt;项目于2017年10月启动，该组件适合在生产中使用，并且是&lt;a href=&#34;https://github.com/openfaas&#34;&gt;openfaas&lt;/a&gt; GitHub组织的一部分。&lt;/p&gt;
&lt;p&gt;of-watchdog是函数和微服务之间的&lt;strong&gt;反向代理&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;of-watchdog的默认模式是http模式，部署服务时of-watchdog会fork一个进程（假设为进程A），进程A会监听一个端口，of-wahtchdog收到的所有请求都会转发到进程A监听的端口，HTTP模式的官方架构图如下：&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;5&#34;&gt;&lt;img src=&#34;https://Czardas42.github.io//post-images/1620199965913.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;如图所示，代码是在右侧的child里面执行的，这个child从3000端口收到of-watchdog转发过来的外部请求，然后内部处理掉。&lt;/p&gt;
&lt;p&gt;主要区别在于：经典的看门狗会为每个请求派生一个进程，以提供最高级别的可移植性，&lt;strong&gt;但是of-watchdog启用了一种&lt;code&gt;http&lt;/code&gt;模式，在该模式下，该进程可以重复使用，以抵消分叉的延迟&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;of-watchdog的优点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;第一，并发性能和吞吐量最优；&lt;/li&gt;
&lt;li&gt;第二，相比watchdog，对内存的使用更高效；&lt;/li&gt;
&lt;li&gt;第三，建好的数据库连接可以反复使用；&lt;/li&gt;
&lt;li&gt;第四，容器操作系统的临时文件夹(/tmp/目录)，是所有请求共用的，例如可以做临时缓存用&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;函数请求处理流程感觉写好了很亮眼&#34;&gt;函数请求处理流程（感觉写好了很亮眼）&lt;/h4&gt;
&lt;p&gt;【参考】&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://blog.csdn.net/weixin_38616705/article/details/107385293&#34;&gt;https://blog.csdn.net/weixin_38616705/article/details/107385293&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://zhuanlan.zhihu.com/p/41056766&#34;&gt;https://zhuanlan.zhihu.com/p/41056766&lt;/a&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;访问openfaas的gateway的service。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;对于一个函数请求而言，其由一个客户端发出，首先访问的是openfaas的gateway的service，通过iptables将对于Service的访问路由到pod所连接的网卡。&lt;/p&gt;
&lt;p&gt;iptables中的处理流程：&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;u&gt;需要真实操作的真实截图&lt;/u&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;该流程画成图就是如下图所示的过程*&lt;u&gt;（图需要自己重新画）&lt;/u&gt;*&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;6&#34;&gt;&lt;img src=&#34;https://Czardas42.github.io//post-images/1620302159529.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;pod的连接&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在多节点集群中，请求进行DNAT之后会被转发到flannel网卡上，然后由一个flanneld的程序进行处理（也就是路由，flanneld通过etcd储存了一个集群的网络信息，通过此进行路由），接着flanneld会根据路由选择的结果将请求转发到目的pod所在机器上，而在目的pod所在机器上，请求先是被转发到flannel网卡上。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;u&gt;（下图需要自己重新画）&lt;/u&gt;&lt;/em&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;7&#34;&gt;&lt;img src=&#34;https://Czardas42.github.io//post-images/1620302193199.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;&lt;strong&gt;找到了相应的pod，接下来需要发送给具体的容器。&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;8&#34;&gt;&lt;img src=&#34;https://Czardas42.github.io//post-images/1620302206521.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;在每个pod之中，都有一个pause容器，这是kubernetes创建的系统容器，pause容器会创建网络命名空间并将直接的网络桥接到cni0网桥（通过veth pair），然后所有的用户容器都会共享这个网络命名空间，即共享一块网卡。那么请求转发的流程就是直接在cni0通过veth pair传向了pod内的eth0，接着容器就可以直接接收网卡eth0上的信息了。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;Gateway中的请求处理&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;在gateway中存在处理函数请求的handler&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;代理转发&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Gateway本身不做任何和部署发布函数的事情，它只是作为一个代理，把请求转发给相应的Provider去处理，所有的请求都要通过这个网关。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;4.1 同步函数转发&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;主要转发的API有：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;RoutelessProxy&lt;/li&gt;
&lt;li&gt;ListFunctions&lt;/li&gt;
&lt;li&gt;DeployFunction&lt;/li&gt;
&lt;li&gt;DeleteFunction&lt;/li&gt;
&lt;li&gt;UpdateFunction&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-C&#34;&gt;faasHandlers.RoutelessProxy = handlers.MakeForwardingProxyHandler(reverseProxy, forwardingNotifiers, urlResolver)
    faasHandlers.ListFunctions = handlers.MakeForwardingProxyHandler(reverseProxy, forwardingNotifiers, urlResolver)
    faasHandlers.DeployFunction = handlers.MakeForwardingProxyHandler(reverseProxy, forwardingNotifiers, urlResolver)
    faasHandlers.DeleteFunction = handlers.MakeForwardingProxyHandler(reverseProxy, forwardingNotifiers, urlResolver)
    faasHandlers.UpdateFunction = handlers.MakeForwardingProxyHandler(reverseProxy, forwardingNotifiers, urlResolver)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;MakeForwardingProxyHandler()有三个参数：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;proxy&lt;br&gt;
这是一个http的客户端，作者把这个客户端抽成一个类，然后使用该类的NewHTTPClientReverseProxy方法创建实例，这样就简化了代码，不用每次都得写一堆相同的配置。&lt;/li&gt;
&lt;li&gt;notifiers&lt;br&gt;
这个其实是要打印的日志，这里是一个HTTPNotifier的接口。而在这个MakeForwardingProxyHandler中其实有两个实现类，一个是LoggingNotifier，一个是PrometheusFunctionNotifier，分别用来打印和函数http请求相关的日志以及和Prometheus监控相关的日志。&lt;/li&gt;
&lt;li&gt;baseURLResolver&lt;br&gt;
这个就是Provider的url地址。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;MakeForwardingProxyHandler中主要做了三件事儿：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;解析要转发的url&lt;/li&gt;
&lt;li&gt;调用forwardRequest方法转发请求，&lt;/li&gt;
&lt;li&gt;打印日志&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-C&#34;&gt;// MakeForwardingProxyHandler create a handler which forwards HTTP requests
func MakeForwardingProxyHandler(proxy *types.HTTPClientReverseProxy, notifiers []HTTPNotifier, baseURLResolver BaseURLResolver) http.HandlerFunc {
    return func(w http.ResponseWriter, r *http.Request) {
        baseURL := baseURLResolver.Resolve(r)
        requestURL := r.URL.Path
        start := time.Now()
        statusCode, err := forwardRequest(w, r, proxy.Client, baseURL, requestURL, proxy.Timeout)
        seconds := time.Since(start)
        if err != nil {
            log.Printf(&amp;quot;error with upstream request to: %s, %s\n&amp;quot;, requestURL, err.Error())
        }
        for _, notifier := range notifiers {
            notifier.Notify(r.Method, requestURL, statusCode, seconds)
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;4.2 异步函数转发&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;如果是异步函数，Gateway就作为一个发布者，将函数放到队列里。MakeQueuedProxy方法就是做这件事的：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;读取请求体&lt;/li&gt;
&lt;li&gt;将&lt;code&gt;X-Callback-Url&lt;/code&gt;参数从参数中http的header中读出来&lt;/li&gt;
&lt;li&gt;实例化用于异步处理的Request对象&lt;/li&gt;
&lt;li&gt;调用canQueueRequests.Queue(req)，将请求发布到队列中&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-C&#34;&gt;// MakeQueuedProxy accepts work onto a queue
func MakeQueuedProxy(metrics metrics.MetricOptions, wildcard bool, canQueueRequests queue.CanQueueRequests) http.HandlerFunc {
    return func(w http.ResponseWriter, r *http.Request) {
        defer r.Body.Close()
        body, err := ioutil.ReadAll(r.Body)
        // 省略错误处理代码
        vars := mux.Vars(r)
        name := vars[&amp;quot;name&amp;quot;]
​
        callbackURLHeader := r.Header.Get(&amp;quot;X-Callback-Url&amp;quot;)
        var callbackURL *url.URL
        if len(callbackURLHeader) &amp;gt; 0 {
            urlVal, urlErr := url.Parse(callbackURLHeader)
            // 省略错误处理代码
            callbackURL = urlVal
        }
        req := &amp;amp;queue.Request{
            Function:    name,
            Body:        body,
            Method:      r.Method,
            QueryString: r.URL.RawQuery,
            Header:      r.Header,
            CallbackURL: callbackURL,
        }
        err = canQueueRequests.Queue(req)
        // 省略错误处理代码
        w.WriteHeader(http.StatusAccepted)
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;5&#34;&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;函数pod内部的请求处理&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;接下来gateway就会把请求转发给具体的function所对应的Service，这里Service的访问流程如前所述，但是也有一点需要注意，因为每个function都会对应多个pod副本，那么Service在进行iptables处理的时候就需要选择一个具体的pod来转发请求，这个时候就会有一个负载均衡的问题，而Kubernetes在这里的处理是随机选择一个pod进行转发。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;目前，对于openfaas，如前文所述，函数的部署是通过of-watchdog。&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;9&#34;&gt;&lt;img src=&#34;https://Czardas42.github.io//post-images/1620199965913.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;在Http的方式下当这个watchdog启动时，父进程会fork一个子进程（也就是用户提交的函数程序），这个函数程序不是简单的函数逻辑，也要包含一个Http服务器用来处理Http请求，且这个函数程序会一直运行，监听容器网卡上的端口以获得请求。&lt;/p&gt;
&lt;h4 id=&#34;自动伸缩&#34;&gt;&lt;strong&gt;自动伸缩&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;【参考】&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://zhuanlan.zhihu.com/p/41056766&#34;&gt;https://zhuanlan.zhihu.com/p/41056766&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;伸缩性其实有两种，一种是可以通过调用API接口，来将函数进行缩放。另外一种就是通过AlertHandler。&lt;/p&gt;
&lt;p&gt;自动伸缩是OpenFaaS的一大特点，触发自动伸缩主要是根据不同的指标需求。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;根据每秒请求数来做伸缩&lt;br&gt;
OpenFaaS附带了一个自动伸缩的规则，这个规则是在AlertManager配置文件中定义。AlertManager从Prometheus中读取使用情况（每秒请求数），然后在满足一定条件时向Gateway发送警报。&lt;br&gt;
可以通过删除AlertManager，或者将部署扩展的环境变量设置为0，来禁用此方式。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;最小/最大副本数&lt;br&gt;
通过向函数添加标签, 可以在部署时设置最小 (初始) 和最大副本数。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;com.openfaas.scale.min&lt;/code&gt; 默认是 &lt;code&gt;1&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;com.openfaas.scale.max&lt;/code&gt; 默认是 &lt;code&gt;20&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;com.openfaas.scale.factor&lt;/code&gt; 默认是 &lt;code&gt;20%&lt;/code&gt; ，在0-100之间，这是每次扩容的时候，新增实例的百分比，若是100的话，会瞬间飙升到副本数的最大值。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;com.openfaas.scale.min&lt;/code&gt; 和 &lt;code&gt;com.openfaas.scale.max&lt;/code&gt;值一样的时候，可以关闭自动伸缩。&lt;br&gt;
&lt;code&gt;com.openfaas.scale.factor&lt;/code&gt;是0时，也会关闭自动伸缩。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;scaleService&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Gateway的源码中，&lt;code&gt;scaleService&lt;/code&gt;是真正处理伸缩服务的函数：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-C&#34;&gt;func scaleService(alert requests.PrometheusInnerAlert, service ServiceQuery) error {
    var err error
    serviceName := alert.Labels.FunctionName
​
    if len(serviceName) &amp;gt; 0 {
        queryResponse, getErr := service.GetReplicas(serviceName)
        if getErr == nil {
            status := alert.Status
​
            newReplicas := CalculateReplicas(status, queryResponse.Replicas, uint64(queryResponse.MaxReplicas), queryResponse.MinReplicas, queryResponse.ScalingFactor)
​
            log.Printf(&amp;quot;[Scale] function=%s %d =&amp;gt; %d.\n&amp;quot;, serviceName, queryResponse.Replicas, newReplicas)
            if newReplicas == queryResponse.Replicas {
                return nil
            }
​
            updateErr := service.SetReplicas(serviceName, newReplicas)
            if updateErr != nil {
                err = updateErr
            }
        }
    }
    return err
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;从代码z中可以看到，scaleService做了三件事：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;获取现在的副本数&lt;/li&gt;
&lt;li&gt;计算新的副本数&lt;br&gt;
新副本数的计算方法是根据&lt;code&gt;com.openfaas.scale.factor&lt;/code&gt;计算步长：&lt;br&gt;
&lt;code&gt;step := uint64((float64(maxReplicas) / 100) * float64(scalingFactor))&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;设置为新的副本数&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;MakeScalingHandler&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在调用函数的时候，用的路由是：&lt;code&gt;/function/:name&lt;/code&gt;。如果环境变量里有配置&lt;code&gt;scale_from_zero&lt;/code&gt;为true，先用&lt;code&gt;MakeScalingHandler()&lt;/code&gt;方法对proxyHandler进行一次包装。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;MakeScalingHandler&lt;/code&gt;接受参数主要是：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;next：就是下一个httpHandlerFunc，中间件都会有这样一个参数&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;config：&lt;code&gt;ScalingConfig&lt;/code&gt;的对象：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-C&#34;&gt;// ScalingConfig for scaling behaviours
type ScalingConfig struct {
MaxPollCount uint // 查到的最大数量
FunctionPollInterval time.Duration // 函数调用时间间隔
CacheExpiry time.Duration // 缓存过期时间
ServiceQuery ServiceQuery // 外部服务调用的一个接口
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这个&lt;code&gt;MakeScalingHandler&lt;/code&gt;中间件主要做了如下的事情：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;先从FunctionCache缓存中获取该函数的基本信息，从这个缓存可以拿到每个函数的副本数量。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;为了加快函数的启动速度，如果缓存中可以获该得函数，且函数的副本数大于0，满足条件，return即可。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如果不满足上一步，就会调用&lt;code&gt;SetReplicas&lt;/code&gt;方法设置副本数，并更新FunctionCache的缓存。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-C&#34;&gt;// MakeScalingHandler creates handler which can scale a function from
// zero to 1 replica(s).
func MakeScalingHandler(next http.HandlerFunc, upstream http.HandlerFunc, config ScalingConfig) http.HandlerFunc {
    cache := FunctionCache{
        Cache:  make(map[string]*FunctionMeta),
        Expiry: config.CacheExpiry,
    }
    return func(w http.ResponseWriter, r *http.Request) {
        functionName := getServiceName(r.URL.String())
        if serviceQueryResponse, hit := cache.Get(functionName); hit &amp;amp;&amp;amp; serviceQueryResponse.AvailableReplicas &amp;gt; 0 {
            next.ServeHTTP(w, r)
            return
        } 
        queryResponse, err := config.ServiceQuery.GetReplicas(functionName)
        cache.Set(functionName, queryResponse)
        // 省略错误处理
        if queryResponse.AvailableReplicas == 0 {
            minReplicas := uint64(1)
            if queryResponse.MinReplicas &amp;gt; 0 {
                minReplicas = queryResponse.MinReplicas
            }
            err := config.ServiceQuery.SetReplicas(functionName, minReplicas)
            // 省略错误处理代码
            for i := 0; i &amp;lt; int(config.MaxPollCount); i++ {
                queryResponse, err := config.ServiceQuery.GetReplicas(functionName)
                cache.Set(functionName, queryResponse)
                // 省略错误处理
                time.Sleep(config.FunctionPollInterval)
            }
        }
        next.ServeHTTP(w, r)
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;注：&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;GetReplicas&lt;/code&gt;方法&lt;br&gt;
从&lt;code&gt;system/function/:name&lt;/code&gt;接口获取到函数的信息，组装一个&lt;code&gt;ServiceQueryResponse&lt;/code&gt;对象即可。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;SetReplicas&lt;/code&gt;方法&lt;br&gt;
调用&lt;code&gt;system/scale-function/:name&lt;/code&gt;接口，设置副本数。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
">OpenFaaS</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://Czardas42.github.io/post/kubernetes/"" data-c="
          &lt;h3 id=&#34;整体架构&#34;&gt;整体架构&lt;/h3&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://Czardas42.github.io//post-images/1620199629518.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;Kubernetes属于主从分布式架构，主要由Master Node和Worker Node组成，以及包括客户端命令行工具kubectl和其它附加项。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;**Master Node：**作为控制节点，对集群进行调度管理；Master Node由API Server、Scheduler、Cluster State Store和Controller-Manger Server所组成&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;**Worker Node：**作为真正的工作节点，运行业务应用的容器；Worker Node包含kubelet、kube proxy和Container Runtime&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;**kubectl：**用于通过命令行与API Server进行交互，而对Kubernetes进行操作，实现在集群中进行各种资源的增删改查等操作&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;master-node&#34;&gt;Master Node&lt;/h3&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;2&#34;&gt;&lt;img src=&#34;https://Czardas42.github.io//post-images/1620199664616.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h4 id=&#34;1-api-serverapi服务器&#34;&gt;1. &lt;strong&gt;API Server（API服务器）&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;API Server主要用来处理REST的操作，确保它们生效，并执行相关业务逻辑，以及更新etcd（或者其他存储）中的相关对象。&lt;/p&gt;
&lt;h4 id=&#34;2-cluster-state-store集群状态存储&#34;&gt;2. &lt;strong&gt;Cluster state store（集群状态存储）&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;Kubernetes默认使用etcd作为集群整体存储。集群的所有状态都存储在etcd实例中，并具有监控的能力，因此当etcd中的信息发生变化时，就能够快速的通知集群中相关的组件。&lt;/p&gt;
&lt;h4 id=&#34;3-controller-manager-server控制管理服务器&#34;&gt;3. &lt;strong&gt;Controller-Manager Server（控制管理服务器）&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;Controller-Manager Serve用于执行大部分的集群层次的功能，它既执行生命周期功能(例如：命名空间创建和生命周期、事件垃圾收集、已终止垃圾收集、级联删除垃圾收集、node垃圾收集)，也执行API业务逻辑（例如：pod的弹性扩容）。&lt;/p&gt;
&lt;h4 id=&#34;4-scheduler调度器&#34;&gt;4. &lt;strong&gt;Scheduler（调度器）&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;scheduler组件为容器自动选择运行的主机。依据请求资源的可用性，服务请求的质量等约束条件，scheduler监控未绑定的pod，并将其绑定至特定的node节点。&lt;/p&gt;
&lt;h3 id=&#34;worker-node&#34;&gt;Worker Node&lt;/h3&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;3&#34;&gt;&lt;img src=&#34;https://Czardas42.github.io//post-images/1620199680953.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h4 id=&#34;1-kubelet&#34;&gt;1. kubelet&lt;/h4&gt;
&lt;p&gt;kubelet负责管理pods和它们上面的容器，images镜像、volumes、etc。&lt;/p&gt;
&lt;h4 id=&#34;2-kube-proxy&#34;&gt;2. kube-proxy&lt;/h4&gt;
&lt;p&gt;kube proxy负责为Pod创建代理服务；引到访问至服务；并实现服务到Pod的路由和转发，以及通过应用的负载均衡。每一个Node都会运行一个kube-proxy，kube proxy通过iptables规则引导访问至服务IP，并将重定向至正确的后端应用，通过这种方式kube-proxy提供了一个高可用的负载均衡解决方案。&lt;/p&gt;
&lt;h4 id=&#34;3-container-runtime&#34;&gt;3. Container Runtime&lt;/h4&gt;
&lt;p&gt;每一个Node都会运行一个Container Runtime，其负责下载镜像和运行容器。kubelet使用Unix socket之上的gRPC框架与容器运行时进行通信，kubelet作为客户端，而CRI shim作为服务器。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;4&#34;&gt;&lt;img src=&#34;https://Czardas42.github.io//post-images/1620199694750.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h4 id=&#34;4-fluentd-elasticsearch&#34;&gt;4. &lt;strong&gt;Fluentd-elasticsearch&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;提供集群日志采集、存储与查询&lt;/p&gt;
&lt;h3 id=&#34;pod&#34;&gt;Pod&lt;/h3&gt;
&lt;h4 id=&#34;1-定义&#34;&gt;1. 定义&lt;/h4&gt;
&lt;p&gt;**Pod是可以在 Kubernetes 中创建和管理的、最小的可部署的计算单元。**Pod的设计理念是支持多个容器在一个Pod中共享网络地址和文件系统，可以通过进程间通信和文件共享这种简单高效的方式组合完成服务。&lt;/p&gt;
&lt;h4 id=&#34;2-pod的调度方法&#34;&gt;2. Pod的调度方法&lt;/h4&gt;
&lt;p&gt;Scheduler负责根据调度策略自动将Pod部署到合适Node中，调度策略分为预选策略和优选策略，Pod的整个调度过程分为两步：&lt;/p&gt;
&lt;p&gt;1）预选Node：遍历集群中所有的Node，按照具体的预选策略筛选出符合要求的Node列表。如没有Node符合预选策略规则，该Pod就会被挂起，直到集群中出现符合要求的Node。&lt;/p&gt;
&lt;p&gt;2）优选Node：预选Node列表的基础上，按照优选策略为待选的Node进行打分和排序，从中获取最优Node。&lt;/p&gt;
&lt;h3 id=&#34;deployment-service-job&#34;&gt;Deployment &amp;amp; Service &amp;amp; Job&lt;/h3&gt;
&lt;h4 id=&#34;1-部署deployment&#34;&gt;1. 部署(Deployment)&lt;/h4&gt;
&lt;p&gt;部署表示用户对K8s集群的一次更新操作。可以是创建一个新的服务，更新一个新的服务，也可以是滚动升级一个服务。滚动升级一个服务，实际是创建一个新的RS，然后逐渐将新RS中副本数增加到理想状态，将旧RS中的副本数减小到0的复合操作。&lt;/p&gt;
&lt;p&gt;&lt;u&gt;&lt;strong&gt;删除pod的正确方法&lt;/strong&gt;&lt;/u&gt;&lt;/p&gt;
&lt;h4 id=&#34;2-服务service&#34;&gt;2. 服务（Service）&lt;/h4&gt;
&lt;p&gt;一个Pod只是一个运行服务的实例，随时可能在一个节点上停止，在另一个节点以一个新的IP启动一个新的Pod，因此不能以确定的IP和端口号提供服务。要稳定地提供服务需要服务发现和负载均衡能力。服务发现完成的工作，是针对客户端访问的服务，找到对应的的后端服务实例。在K8s集群中，客户端需要访问的服务就是Service对象。每个Service会对应一个集群内部有效的虚拟IP，集群内部通过虚拟IP访问一个服务。&lt;/p&gt;
&lt;p&gt;&lt;u&gt;&lt;strong&gt;结合Prometheus部署&lt;/strong&gt;&lt;/u&gt;&lt;/p&gt;
&lt;h4 id=&#34;3-任务job&#34;&gt;3. 任务（Job）&lt;/h4&gt;
&lt;p&gt;Job是K8s用来控制批处理型任务的API对象。Job 会创建一个或者多个 Pods，并将继续重试 Pods 的执行，直到指定数量的 Pods 成功终止。 随着 Pods 成功结束，Job 跟踪记录成功完成的 Pods 个数。 当数量达到指定的成功个数阈值时，任务（即 Job）结束。 删除 Job 的操作会清除所创建的全部 Pods。&lt;/p&gt;
">Kubernetes</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://Czardas42.github.io/post/A_Little_Story/"" data-c="
          &lt;/br&gt;
&lt;h2 id=&#34;part-1&#34;&gt;Part 1&lt;/h2&gt;
&lt;p&gt;&lt;em&gt;&lt;strong&gt;一切辉煌的，卑微的，欢乐的，悲伤的事物终将陨灭，唯有故事和歌谣能在时光的洪流中静静流淌。&lt;/strong&gt;&lt;/em&gt;&lt;br&gt;
　　&lt;br&gt;
　　瑞文戴尔医治创伤，瑞文戴尔忘记痛苦。&lt;br&gt;
　　最近这里越来越安静了。好吧，是一直都很安静。但从未像现在这样，没有言语，没有欢笑，没有精灵长袍划过地面时的沙沙声，没有吟咏诗歌的甜美嗓音。只有落了一地的红叶和蜿蜒附着在墙上的藤蔓。&lt;br&gt;
　　这让我不禁怀疑，这一切在不久之后都会消失殆尽，就像他们从未存在过一般。瑞文戴尔终将成为古老歌谣中的传奇——那最后的避难所。&lt;br&gt;
　　风有时会穿过隐匿的谷隙，送来远方的讯息。它托起地上的落叶，让他们旋腾着放飞，又悄然无声的下落，划过耳畔，只余一声叹息。不过无论怎样，这里依旧是美丽的，非常美丽——但是哀伤。很少的时候我会突发奇想，觉得或许这两者本身就是休戚与共的，因美丽而变得哀伤，又因哀伤更为美丽。&lt;br&gt;
　　&lt;br&gt;
　　瑞文戴尔遗忘了时光，然而时光的印记依旧显露在我的面容上。&lt;br&gt;
　　我老了。&lt;br&gt;
　　&lt;br&gt;
　　某一天的清晨，当我睁开双眼的瞬间，一个来自心底的声音告诉我。&lt;br&gt;
　　你已经老了。&lt;br&gt;
　　我再也无法背上旅行包，遮上斗篷，去探寻高山裂谷间的天地。是时候该坐下来，在火炉旁喝杯热茶了。每天我都会从房间出发，把我的书夹在臂下，一路漫步到Lord Erlond家一处偏僻的阳台上去。我坚信那里会给予我创作的灵感，每天皆是如此。&lt;br&gt;
　　还有，我称呼它为“我的小阳台”。&lt;br&gt;
　　&lt;br&gt;
　　告别是生命的永恒主题，在蒙福之地之外的大地上，没有人能抗拒它，即使是精灵。我们只能匆忙起身，告别一张张熟悉的面孔，独自踏上旅程。或如有的时候，是我们站在这里，目送他们步步远去。&lt;br&gt;
　　&lt;br&gt;
　　一天又一天，我穿过长长的步廊，去往我的小阳台。我的手指不再圆润灵活，我的步伐不再飞扬灵健，精灵们依旧微笑着和我道早安。&lt;br&gt;
　　一天又一天，我穿过长长的步廊，去往我的小阳台。执着拐杖，蹒跚地走在阳光的影子上。四周静悄悄的，连鸟儿也不愿再尽情地歌唱，生怕叨扰这美丽的哀伤。&lt;br&gt;
　　他们都走了，离开这里，前往灰港，离开中土，奔向大海的那方。&lt;br&gt;
　　直到有一天，我抬头望见Lindir亲切的脸庞。&lt;br&gt;
　　“早安，Bilbo。”他如是说。&lt;br&gt;
　　“早安，Lindir。”我笑着向他鞠了一躬。&lt;br&gt;
　　精灵的离去时我感到哀伤，再也没有什么比老友的笑容更能使人舒畅的了。&lt;br&gt;
　　“Well，你今天是否有兴致听我念念书的新进展呢？”&lt;br&gt;
　　“我——很遗憾，Bilbo。”Lindir抿了抿唇，目光欢欣而又哀伤。&lt;br&gt;
　　“为什么不呢？我正要给你看看老Bilbo最得意的那几段呐。为什么呢，Lindir？”&lt;br&gt;
　　“因为...我要离开了...”&lt;br&gt;
　　&lt;br&gt;
　　我沉默下来，再度被寂寞所笼罩。精灵注定不属于这里。数千年的阅历使他们变得智慧，沧桑，而那绵长的记忆又时刻折磨着他们。当形体逐渐被时光的洪流所侵蚀时，精灵注定会从此扬帆远航。向西，向西，去往那处没有悲伤的土地。&lt;br&gt;
　　&lt;br&gt;
　　静默的气氛让Lindir不安起来。哦善良的Lindir，总是不忍心让我这个老家伙悲伤。&lt;br&gt;
　　“你知道的，Bilbo老友。我的心没有一时一刻没有在呼唤着大海。更重要的是，我相信...我有种预感，你我终究会在大海边重逢。”&lt;br&gt;
　　“喔，那可真是谢谢你的消息啦。我会从今天开始抓紧造船的。”我佯装生气地用拐杖敲了敲地砖，恶狠狠地说。&lt;br&gt;
　　精灵一向对外界的时间流逝感知不大，对人事亦是如此。我只希望，这个苍老的、坏脾气的霍比特人能让精灵在漫长的纪元之中偶然间忆起，哪怕只是拐杖敲在地上的砰砰声。&lt;br&gt;
　　也许在许多许多年之后，在阿门洲的某个美丽的角落，我的身影会从他们记忆的缝隙中闪过。&lt;br&gt;
　　&lt;br&gt;
　　“喂，你还记得那个半身人吗？”&lt;br&gt;
　　“你是说那个别扭的、坏脾气的老Bilbo？喔，他可是个厉害的霍比特人！”&lt;br&gt;
　　“我依稀记得我们还一起作过诗歌呐。啊，瑞文戴尔的欢乐时光。”&lt;br&gt;
　　&lt;br&gt;
　　“你知道吗，我真想念他。”&lt;br&gt;
　　然后，我希望他们能微笑着吟诵出我的故事和歌谣。一切辉煌的，卑微的，欢乐的，悲伤的事物终将陨灭，唯有故事和歌谣能在时光的洪流中静静流淌。&lt;br&gt;
　　&lt;br&gt;
　　“我没有在开玩笑”，Lindir半蹲下来，注视着我的眼睛，“我知道，我就是知道——不论世事如何变迁，不论沧海多少次变为桑田，我们终将团聚于大海彼岸，在维拉膝边聆听一如的智言。在那时，伊露维塔的子女和埃尔达的其他所有美好生灵，都将领悟到这万物存在的真谛。于浩大之中，于须臾之间。至于你，Bilbo老友。别担心，我们还会再见的，就在不久的将来。”&lt;br&gt;
　　“无论怎样”，我轻笑出声，“请记住我的故事，老Bilbo的历险故事。”&lt;br&gt;
　　“当然啦，我亲爱的Bilbo。我会在大海彼岸吟唱你的旅歌，直到你我重聚之时。待到那时，你便可以亲自向维林诺的居民讲述你的小故事。”他向前倾来，指尖搭上我的肩膀，平和的声音传入耳畔。&lt;br&gt;
　　“精灵对告别这类事情可不怎么擅长。所以...再会。再会了，Bilbo。”Lindir那温暖的手掌轻拍了拍我的肩，然后他站起来，右手抚上心口，朝我微微鞠躬。&lt;br&gt;
　　“别了，Bilbo老爷。我将顺从内心的呼唤，前往那极西之地，并在海鸥的飞鸣中期待与您的重逢。”&lt;br&gt;
　　然后，我松开了拐杖，张开双臂，接受了一个来自精灵的拥抱，一个来自老朋友的拥抱。&lt;br&gt;
　　我听见自己说：“别担心我，吾友。我还硬朗着呐，况且我的书还需要尽快完成。当你登上灰港的白船时，记得多写几首诗，回来拿给我欣赏欣赏。”&lt;br&gt;
　　说着，我轻拍了拍他的背。&lt;br&gt;
　　“我会的。”Lindir笑了。接着便转过身，向谷口走去，他的族人在那里等待着他。长长的袍子在地上画出了一道悠扬的弧线。渐渐地，嗒嗒的脚步声也消失了。&lt;br&gt;
　　他走了。&lt;br&gt;
　　再然后啊，老Bilbo就拾起他的拐杖，夹着他还未完成的书，继续哼着歌向他的小阳台漫步而去。&lt;br&gt;
　　&lt;br&gt;
　　大路长呀长，&lt;br&gt;
　　从家门口伸呀伸。&lt;br&gt;
　　大路已走远，&lt;br&gt;
　　让别人快跟上！&lt;br&gt;
　　去踏上新旅程！&lt;br&gt;
　　我这双累累脚，&lt;br&gt;
　　要往那旅店走，&lt;br&gt;
　　好好睡一觉。&lt;br&gt;
　　&lt;br&gt;
　　这世上的告别并非都是悲伤的。我知道，这次就不是。&lt;/p&gt;
&lt;/br&gt;
&lt;h2 id=&#34;part-2&#34;&gt;Part 2&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;“所有的战争，英雄和无所畏惧的行动，并不比每天的平凡生活更&lt;/em&gt;具有价值和值得称颂。”&lt;/strong&gt;&lt;br&gt;
　　                                                                        &lt;em&gt;&lt;strong&gt;——TRR.托尔金&lt;/strong&gt;&lt;/em&gt;&lt;br&gt;
　　&lt;br&gt;
　　就是第三纪元末的一个普普通通的下午，我依旧坐在扶椅上，思索着故事的结尾。一个动人又不落俗套的结尾。&lt;br&gt;
　　岁月在我身上留下的痕迹愈来愈明显。我的双眼开始昏花，耳朵也听不见远处的溪水声了。有时，我正执着笔思索，意识就开始变得模糊，字迹好像重叠了一般，就这么睡了过去。&lt;br&gt;
　　唤醒我的是指尖摩挲纸卷时的沙沙声。此时正值黄昏，夕阳刚好映在我的面颊上。那光芒让我无法张开双眸。&lt;br&gt;
　　所以我开口问道：“谁在那里？Lindir，Aragon，还是...Frodo？&lt;br&gt;
　　好啦，不要嘲笑我老糊涂了。我当然知道他们不可能出现。但是这是种习惯，人老了之后都会有的习惯：总会觉得生活就保存在记忆中的状态，熟悉的人们永远围绕在自己身旁。恍惚之间，还是会叫出思念之人的名字。&lt;br&gt;
　　&lt;br&gt;
　　我极力想睁开双眼，看见在那日落的光辉中，Lord Erlond侧身站在那里，饶有兴致地读着书摊开的那一页。&lt;br&gt;
　　尽管我是个老霍比特人啦，不过被别人发现在写书时睡着可不是什么特别光彩的事。我尴尬极了，讷讷道：“能在这宁静的黄昏遇见您真是我的荣幸，my lord。”&lt;br&gt;
　　“哦，Bilbo，你醒了。我进来时你正睡得香呐。”Lord Erlond冲我温和一笑，“还有，你不会介意我偷瞟了几眼你的书吧？”&lt;br&gt;
　　“当然不会，my lord。”我松了口气，期待道，“事实上，我正打算去找您呢。我总是不能思考出一个好的结尾。”&lt;br&gt;
　　或许说，有那么一个还不错的，就是那个我在离开袋底洞时想到的。可是它太直白了，缺少诗意。“老霍比特人从此幸福的生活了下去。”我总觉得缺失了什么。&lt;br&gt;
　　&lt;br&gt;
　　“Well .我相信你会的，Bilbo总是会为他的故事安排一个妙极了的结尾。”Lord Erlond笑着回答。&lt;br&gt;
　　黄昏的最后一缕阳光缠绕着他的发梢。这位历尽沧桑的领主大人依旧睿智而又肃穆，周身萦绕着淡淡的微光。但他不再流露出悲伤，眼神中的丝缕笑意也流淌入我心间。&lt;br&gt;
　　我知道有些事情发生了，一些好的、非常好的事情发生了。&lt;br&gt;
　　于是我开口询问：“有什么好消息吗，my lord？”&lt;br&gt;
　　“当然啦，我亲爱的Bilbo。”Erlond抿唇答道，“Frodo马上就要回来了。”&lt;br&gt;
　　“Frodo！是...是Frodo！”&lt;br&gt;
　　我简直不敢相信自己的耳朵。My dear Frodo，勇敢的Frodo就要回来了。&lt;br&gt;
　　“所以说，他的任务完成了？已经摧...嗯...摧毁了那枚戒指？”我不能停止发问。&lt;br&gt;
　　“没错。他现在身在米纳斯提力斯。还有，我将要动身去那里，去祝贺刚铎的人皇。”&lt;br&gt;
　　“人皇？”我诧异道，“那一定是个大人物啦。”&lt;br&gt;
　　“哦，Bilbo。”Erlond摇头失笑道，“你认识他的。他的子民又称其为&#39;Elessar&#39;，意为&#39;精灵宝石&#39;。”&lt;br&gt;
　　“Aragon！我就知道是他。”我掩口大叫，随后便开心地笑出了声。“好小子，他倒是有出息。还有Frodo，他怎么样啦？”&lt;br&gt;
　　“我相信他已经成为了诸多领主和将军最为敬重的人物，即使他的功绩不被众人所知。”Lord Erlond颔首道，“Frodo也会参加庆功宴，然后他将归来，途经这里，返回夏尔。你愿意和我们一起去米纳斯提力斯吗，Bilbo？”&lt;br&gt;
　　我勾着嘴角摇了摇头，说：“我老啦，不想再参加热闹的场面了。况且我的书尚未写完，还要抓紧时间赶工呐。等到Frodo归来时，我要把我的书和其他物什统统转交给他。从那之后，我就可以天天和您一起边喝热茶边聊天啦。”&lt;br&gt;
　　“真是个好想法，Bilbo。”Lord Erlond哑然失笑。&lt;br&gt;
　　他踌躇了一会儿，再次低沉开口：“恐怕我有些事情要告诉你，关于Frodo的。”&lt;br&gt;
　　“你知道，他曾被戒灵所伤。我或许可以医治好皮肤上的疤痕，却无法根除毒咒对他的影响。Frodo必须随我们乘船西渡，惟有那处不休之地可以治愈他的痛苦。如若他坚持留在这里，日久经年，他终会厌倦，动身前往维林诺。所以我会建议他早下决断。如果Frodo决定离开，你愿同他一同启程吗，Bilbo？”&lt;br&gt;
　　我静默了。&lt;br&gt;
　　&lt;br&gt;
　　恍惚间，我忆起了夏尔绿油油的嫩草地，和远处的几缕炊烟。Frodo一定很想家。他可是一个居家型的人。可怜的孩子，他却永不可能与他挚爱的土地长长久久安稳地生活下去。他注定饱受磨难，也注定会以只身之力抗击邪恶，推动众人命运的齿轮。&lt;br&gt;
　　如果我可以陪伴在他身旁，或多或少能给予他一些安慰吧。&lt;br&gt;
　　于是我轻叹道：“我还从未见过大海呢，那一定是另一场非凡的经历。告诉他，my lord。告诉Frodo，我将和你们一道，渡船西去。他或许会跟随我离去，这会使他不再动摇。所以烦请您转告他，明年的这个时候，我将在夏尔边界的白桦林里等待他。您也将同我一道吗，my lord？”&lt;br&gt;
　　“我会的。”Lord Erlond颔首，周身的气息又流露出美丽的哀伤，“至尊之戒已被摧毁。正如我们所料，精灵三戒的力量也随之泯灭，瑞文戴尔和罗立斯洛安也不再受其庇护。如若精灵长久地逗留在这里，我们的形体将逐渐承载不了灵魂的炙热以及回忆的沉重。我们必将从此地扬帆远航，在瓦尔妲的光芒下歌唱。”&lt;br&gt;
　　&lt;br&gt;
　　和精灵的交流总是很愉悦，但却哀伤，美丽又哀伤。&lt;br&gt;
　　我扭了扭手指，开口道：“伟大的一天，my lord。请想一想开心的事吧。嗯，我在想...你想要看一看我的书吗？”&lt;br&gt;
　　Erlond用他那双饱含岁月漩涡的眼眸凝视着我，轻笑出声：“为什么不呢，亲爱的Bilbo？让我看看你的书吧。”&lt;br&gt;
　　我起身将书递给他，然后重新缩回到椅子里，抱着我那杯尚未凉透的茶，眺望瑞文戴尔最西处与天空交汇的地方。夕阳西下去，只余一道狭长的金黄色剪影。&lt;br&gt;
　　海的那一头，究竟是怎样的呢？&lt;br&gt;
　　&lt;br&gt;
　　Lord Erlond静静地翻着书卷。直到夜幕降临，留守的精灵为我们点上支支跳动着橘黄色火焰的蜡烛。&lt;br&gt;
　　终于，他合上了书。&lt;br&gt;
　　“它怎么样？”我有些期待地询问，却又害怕得知答案。&lt;br&gt;
　　“精彩极了，Bilbo老爷，即使以精灵的标准来看。我现在开始理解你为什么想不好结尾了，要给这么棒的故事写结尾，可真要花费些脑筋呀。”&lt;br&gt;
　　“你能喜欢它真是太好了，my lord。”我松了口气，就又兴奋地扭动起来。&lt;br&gt;
　　“让我猜猜，你最喜欢哪一段？矮人们闯进袋底洞的大门？还是我和Gollum在黑暗中的猜谜游戏？啊哈，我知道了。一定是我们乘着木桶漂流的情节！狼狈又好笑，我当时可被淹个够呛呀，不是吗？”&lt;br&gt;
　　Lord Erlond以微笑回应我，他摇了摇头，叹道：“都不是，Bilbo。我喜欢你的开头。&#39;There was a Hobbit live in a hole......&#39;这是多么可爱的开头啊。”&lt;br&gt;
　　我有些难以置信地望着他，失声道：“为什么？那段文字只是我的铺陈性描述呀。你难道不喜欢黑暗中惊险刺激的谜语吗？”&lt;br&gt;
　　&lt;br&gt;
　　“我己经目睹过太多的沧桑迁变，人世无常。”&lt;br&gt;
　　他注视着天边刚刚升起的暮星，低声凝喃，“在我看来，这世上所有的战争，英雄和无所畏惧的行动，并不比每天的平凡生活更具有价值和值得称颂。但是我们的灵魂不甘于此，总是想多看一些，在多看一些。灵魂的炽焰——那一如注入我们体内的不灭之火，让我们渴望创造，渴望跋涉于崇山峻岭之中，渴望到达世界之巅。我们一路上见了很多，也做了很多。好的、坏的，无论如何，他们使我们的存在有意义。我认为独一之神的深意便在于此。然而美丽总是伴随着哀伤，即使是再璀璨耀人的珠宝也会消蚀，再美丽的花儿也会枯萎，再伟大的城池也会弥散在时间的铁蹄下。世事如此，循环往复。经年之后，纵使是最极致的美丽，或是最无法治愈的哀伤也无法使我清晰铭记。惟有那火炉旁的温暖，老友的欢笑和动人的诗篇能够抚慰内心的疲倦。现在我最大的愿望——我所想过的最美好的事，就是大家欢聚在一起，我们所有人。舒舒服服地依偎在暖炉旁，讲故事，说笑话，或许再来一顿丰盛的晚宴。而你的故事开头，Bilbo。它使我重新忆起了这种感觉。一种大多数时刻会被我们遗忘，却最为我们需要的感觉。”&lt;br&gt;
　　&lt;br&gt;
　　我的大脑思考着Erlond的话，胸中有什么呼之欲出。&lt;br&gt;
　　Lord Erlond轻轻把书放回原处，转身与踱步而去。&lt;br&gt;
　　再然后啊，我听见自己开口说，声音无比清晰地回荡在墙壁间。&lt;br&gt;
　　“我刚刚为我的书想到了一个再合适不过的结局，您想听听吗，my lord？”&lt;br&gt;
　　Erlond顿住了，转身浅笑着看着我。&lt;br&gt;
　　“从此，那个霍比特人过上了幸福快乐的生活，直到他的灵魂不再受形体的束缚，自由自在地畅游在山丘和原野之间。他化为一阵清风，萦绕在他的老友们之间，让他们欢笑，直到永远。”&lt;br&gt;
　　Lord Erlond眼中星光闪烁，他开口道：“这真是个好结局，Bilbo老友。”&lt;br&gt;
　　说罢，便抬步离开了我的小阳台。&lt;br&gt;
　　&lt;br&gt;
　　良久，我伫立在那里，无声地笑了起来。&lt;br&gt;
　　I know, I know. And I will tell this to my dear Frodo.&lt;/p&gt;
&lt;/br&gt;
&lt;h2 id=&#34;part-3&#34;&gt;Part 3&lt;/h2&gt;
&lt;p&gt;&lt;em&gt;&lt;strong&gt;我又忆起了那段疯狂的时光，那段跟着矮人到处乱跑的疯狂时光。看着晓雾弥散，孤山耸立在遥远的北方，还有那锤子敲敲打打的撞击声。&lt;/strong&gt;&lt;/em&gt;&lt;br&gt;
　　&lt;br&gt;
　　我对时间的概念又开始模糊了。记不清这是上午还是傍晚，记不清我是否吃了第二顿午饭，记不清在我榻前晃变的许多面孔。&lt;br&gt;
　　也许是个黄昏吧，我缓缓睁开了眼。听见门外那海鸥归巢时的低鸣。和精灵呆在一起总是会让人忽略时光的流动，更不要说在这极西之地，这受维拉福祉的阿门州。&lt;br&gt;
　　阿瑞恩驭着阿纳消失在了地平线，埃兰迪尔扬帆起航，而那金黄的余晖依旧萦绕在身旁。我嗅着海风咸咸的味道，从榻上坐了起来。&lt;br&gt;
　　我的时刻到了，是时候告别了。&lt;br&gt;
　　&lt;br&gt;
　　半掩着的圆木门被轻轻推开，吱呀吱呀地响。我看见Frodo踱了进来，他身上沾染了大海的味道，衣衫微拂。他转过身，合上门，静默着褪下外衣，慢步走到我身旁。&lt;br&gt;
　　“Bilbo，你醒了。”他涩然开口，眼睛里闪着美丽却又忧伤的光，“我刚刚准备了丰盛的晚饭呐，用泰勒瑞精灵密不外传的佐料腌制的烤鱼，我可是缠着Lindir好久他才答应帮我找的呢。来吧，Bilbo，你一定会爱上它的。”&lt;br&gt;
　　Frodo总是那么善解人意，我的好孩子。我们拥有这种无需言语的默契，用闲聊的口吻谈论死亡，就好像我只是要再去参加一次冒险一样。&lt;br&gt;
　　我望着Frodo酌着些许悲伤的浅笑，开口道：“啊，Frodo。只碰我们两个怎么消受得了如此美味的鱼？Gandalf呢，我的老朋友们呢？”&lt;br&gt;
　　“就快了，Bilbo。他们就快到了。”Frodo轻声对我说，忽而又轻笑出声，“哦，我的老Bilbo。你总是那么心急，有没有恶龙在后面追着你跑。”&lt;br&gt;
　　啊，恶龙。好久没有听到过这个词了。我又忆起了那段疯狂的时光，那段跟着矮人到处乱跑的疯狂时光。看着晓雾弥散，孤山耸立在遥远的北方，还有那锤子敲敲打打的撞击声。片刻间，我仿佛又听到索林·橡木盾雄厚的嗓音哼唱的古老歌谣。&lt;br&gt;
　　那是多久以前的事啊。自从到达维林诺，Frodo和我就同泰勒瑞精灵一起居住在海边。泰勒瑞族非常热情，他们赠予我们食物以及衣物，帮助我们搭建属于霍比特人的家。&lt;br&gt;
　　&lt;br&gt;
　　“哈，阿门州的袋底洞。你又创造了一个奇迹，Bilbo。”我犹记得Gandalf如是说， “不过，为什么你和Frodo都不愿随我一起前往罗瑞恩花园呢？据我所知，一般的霍比特人可不会舍弃美丽无比的花园，却选择把房子建在大海边上呀。”&lt;br&gt;
　　“才不是呢，Gandalf。我毕竟只是广阔天地中的一个小人物，然而这世界却大得很呐。这是你告诉我的，你还记得吗？”&lt;br&gt;
　　我咧嘴笑着，下意识的想掏出上衣口袋里的烟斗。却过了好久才想起来，我已经把他们赠给了Marry和Pipin。没准他们现在就躺在夏尔明媚的阳光下，抽着南区最好的烟草聊大天呢。&lt;br&gt;
　　维林诺土地上的所有植物都在雅凡娜的荣光下繁茂生长，但是我永远不会再见到那连片的烟草地了。&lt;br&gt;
　　“好吧，我很高兴你还记得我说过的话。但是这和罗瑞恩花园有什么关系呢，我亲爱的Bilbo？”&lt;br&gt;
　　Gandalf和我倚在海边的一块岩石旁，看那翻滚着的白色浪花洗刷着白色的沙滩。在阳光的照耀下，每一粒细沙折射出粲然的白光。泰勒瑞精灵在远处嬉戏玩耍，他们银色的长发沐浴在金黄的温暖之下，灿灿生辉。&lt;br&gt;
　　“我只是个小人物，Gandalf。但我曾经和三只食人妖整夜周旋，我曾经在瑞文戴尔驻足，我曾经与八脚蜘蛛搏斗，我曾经只身深入伊鲁柏和恶龙交涉，我曾经加入五军之战，与精灵一起战斗。我已经目睹过世界上为数不多的奇迹，作为一个霍比特人，我已见识了太多，是时候该休息了。Come on，Gandalf，想象一下。一个霍比特人，住在维拉们的花园里，这该有多么荒谬呀！”&lt;br&gt;
　　Gandalf望着海的那头——他挚爱的中土，陷入了沉思。&lt;br&gt;
　　&lt;br&gt;
　　就这样，我们沉默着坐在海边的岩石上，聆听海鸥诉说那彼岸的故事。&lt;br&gt;
　　瞟了瞟Gandalf慈祥的面孔，我突然有些局促不安，开口道：“当然，我老啦，走不动啦。只期盼着能坐在炉火旁，听亲爱的Frodo念诗歌给我听。天气好的时候，我们聚到外面来，躺在这里聊天。说累了，就阖上眼，在精灵歌谣的陪伴下入睡。Frodo总是呆呆地望着海岸线，哦对了，有一次他还和我开玩笑说也许Sam就过来陪他了呢。”&lt;br&gt;
　　我们都大笑起来，Gandalf爽朗地嚷道：“对此我毫不怀疑。Samwise Gamgee，那个呆头呆脑却蕴藏着非凡勇气的霍比特人。也许哪天头脑一热，就追随他的主人渡海而来了。”&lt;br&gt;
　　说罢，他站起身来，拍了拍原本就没有一粒灰尘的白袍，叹了口气说：“我真希望维林诺可以种出夏尔南区的烟草，但是谁知道呢，现在我只剩一把空烟斗啦。”说着，他就转了身朝提里安城的方向走去。&lt;br&gt;
　　不到片刻，Gandalf沧桑却不显衰老的声音就又传了过来：“一切都会变得越来越好的，老友。只是可怜的老Gandalf还是有事忙。等着我，Bilbo。晚上咱们还要开怀畅饮哩。”&lt;br&gt;
　　我仰面躺在岩石上，随口应答道：“All right，Gandalf，你说什么就是什么吧。”&lt;br&gt;
　　然后啊，我就数着天上的云朵，双目阖合，继续我的小憩。&lt;/p&gt;
&lt;/br&gt;
&lt;h2 id=&#34;part-4&#34;&gt;Part 4&lt;/h2&gt;
&lt;p&gt;&lt;em&gt;&lt;strong&gt;Once upon a time, there was a Hobbit lived in a hole.&lt;/strong&gt;&lt;/em&gt;&lt;br&gt;
　　&lt;br&gt;
　　“Bilbo，Bilbo。醒醒。”朦胧间，我听到Frodo急切的声音。&lt;br&gt;
　　我努力地想睁开双眼，却发现自己并没有躺在海边的小丘上，而是蜷缩在炉火边，身上还盖着我旧时的旅行斗篷。&lt;br&gt;
　　我摇了摇头，感觉一切似真似幻。果真是做梦了吗？梦到了刚到维林诺不久的日子里的一段普普通通的回忆。我再度眨了眨眼，困惑地望向Frodo。&lt;br&gt;
　　Frodo帮我捻好衣角，又向炉火中添了几把柴火。他蹲下来轻声对我说：“他们马上就到了，Bilbo...Lord Erlond，Lindir和Gandalf，我刚从送信的诺多精灵处得知。再坚持一会儿，Bilbo...他们就要来了。”Frodo嗓音沙哑。&lt;br&gt;
　　我慈爱地注视着我亲爱的Frodo，笑着开了口：“不要悲伤，我的孩子。老Bilbo的冒险故事也许会在这里结束，我却马上就要踏上新的旅途了。是的，Frodo。我可以感受到它，我的灵魂生来便如此，无拘无束，自由自在。到了现在...啊...我要加入新的旅途啦...你还记得我告诉过你的那个故事结尾吗，Frodo？”&lt;br&gt;
　　“当然。”Frodo低喃道，“从此，那个霍比特人过上了幸福快乐的生活，直到他的灵魂不再受形体的束缚，自由自在地畅游在山丘和原野之间。他化为一阵清风，萦绕在他的老友们之间，让他们欢笑，直到永远。”&lt;br&gt;
　　“对啊...”我轻叹出声，“多么完美的结局，不是吗？”&lt;br&gt;
　　&lt;br&gt;
　　这时，门外传来了脚步声，属于霍比特人的圆圆的门吱呀呀地打开，Gandalf慈祥的面孔再度出现在我眼前。跟在他后面的，还有Lord Erlond，Lindir和我所有的挚友们。&lt;br&gt;
　　他们都来到这里，他们都到此与我告别。&lt;br&gt;
　　我半卧在摇椅上，凝视着他们的脸庞。看他们以微笑回应我，眼神中流露出的不舍之意。 还有，那淡淡的忧伤。&lt;br&gt;
　　没有眼泪，没有挽歌。我们以微笑告别，仿佛我只是要出趟远门，要到那一望无际的原野中游荡。&lt;br&gt;
　　&lt;br&gt;
　　我感觉到我的意识正一丝一缕地游离躯干，乘着海风，飞往大海的那边。&lt;br&gt;
　　于是阖眼，轻叹。&lt;br&gt;
　　往事如影随行。&lt;br&gt;
　　&lt;br&gt;
　　“你我终究会在大海彼岸重逢。”&lt;br&gt;
　　&lt;br&gt;
　　“我己经目睹过太多的沧桑迁变，人世无常。”&lt;br&gt;
　　&lt;br&gt;
　　“我老啦，走不动啦。只期盼着能坐在炉火旁，听亲爱的Frodo念诗歌给我听。”&lt;br&gt;
　　&lt;br&gt;
　　“经年之后，纵使是最极致的美丽，或是最无法治愈的哀伤也无法使我清晰铭记。惟有那火炉旁的温暖，老友的欢笑和动人的诗篇能够抚慰内心的疲倦。”&lt;br&gt;
　　&lt;br&gt;
　　“我真希望维林诺可以种出夏尔南区的烟草，但是谁知道呢，现在我只剩一把空烟斗啦。”&lt;br&gt;
　　&lt;br&gt;
　　“我所想过的最美好的事，就是大家欢聚在一起，我们所有人。舒舒服服地依偎在暖炉旁，讲故事，说笑话，或许再来一顿丰盛的晚宴。”&lt;br&gt;
　　&lt;br&gt;
　　“无论怎样，请记住我的故事，老Bilbo的历险故事。”&lt;br&gt;
　　&lt;br&gt;
　　恍惚间，我看见了湛蓝苍穹之下，一碧万顷的大海；我看见灰港岸边停靠着的美丽白船；我看见清澈梦幻的小溪从幽谷流出，满载着精灵的欢笑；我看见北部那雄廓的大荒野，骏马疾驰其间；我看见云雾散尽后的孤山，渡鸦从裂隙飞过，敲响了国王之石下的锁眼。&lt;br&gt;
　　&lt;br&gt;
　　但是，这些都不是我的终点。哦，傻傻的老Bilbo怎能忘记？就在那中土的西边，有一片嫩绿的土地。&lt;br&gt;
　　没有一望无际的荒野，没有高峰如云的山峰，没有充满魔法的溪泉，也没有阳光下银灿灿的沙滩。它的绿绵绵延延，每当清晨的第一缕阳光照耀大地，山丘上不知名的野花就会争发幽香。我怎能忘记我的故乡——夏尔。&lt;br&gt;
　　&lt;br&gt;
　　于是我再度开口，低沉地询问Frodo：“我亲爱的孩子，how about listen to a story，Eh？”&lt;br&gt;
　　“当然啦，Bilbo。我已经好久没听过你讲故事了。”Frodo温柔的回应。&lt;br&gt;
　　所以人们都坐了下来，准备听老Bilbo最后一遍讲述他的小故事。&lt;br&gt;
　　&lt;br&gt;
　　我合上眼，清了清嗓子，开口讲：&lt;br&gt;
　　“Once upon a time, there was a Hobbit lived in a hole.”&lt;br&gt;
　　&lt;br&gt;
　　夏尔清晰地展现在我眼前。清晨，诺克牵着他的羊沿着临水路遛早，老农夫卡顿的女儿小玫打开了小酒馆的门，边擦杯子边倚在门边眺望Samwise·Gamgee修剪袋底洞的小花园。&lt;br&gt;
　　&lt;br&gt;
　　“不是那种让人恶心的洞，脏兮兮湿乎乎的，长满了虫子，透着一股子泥腥味。”&lt;br&gt;
　　&lt;br&gt;
　　老吹号家的公鸡开始打鸣了，远处传来傲娇家叮叮咣咣的做饭声。图克家的小孩乘着小船，幻想着去边境之外冒险。&lt;br&gt;
　　&lt;br&gt;
　　“也不是那种满是沙子的洞，干巴巴光秃秃的，没好地方坐，也没好东西吃。”&lt;br&gt;
　　&lt;br&gt;
　　山迪曼在炫耀自己昨天淘到了一箱棒极了的烟草，罗贝拉·巴金斯还在千方百计地往裙兜中塞我的银汤勺。老诺克单肩背着满满的酒桶，走到半路被迎接Gandalf的小孩子们撞倒，索性坐在地上痛饮。&lt;br&gt;
　　&lt;br&gt;
　　“这是一个霍比特人的洞，而霍比特人的洞就意味着舒适。”&lt;br&gt;
　　&lt;br&gt;
　　在东边的树林中，Frodo正聚精会神地看着诗集。Gandalf驾着破破旧旧的马车姗姗来迟，哼着歌儿去往袋底洞的方向。孩子们追随着Gandalf的烟火，图伏特老爹在旁边看着傻笑。月光下，我捧着酒杯，在嬉闹声中开怀大笑。霍比特人的歌声冲出烟囱，直达云霄。&lt;br&gt;
　　&lt;br&gt;
　　“突然有一天啊，这个霍比特人在一位巫师的忽悠下，稀里糊涂地和矮人踏上了一段改变他一生的旅程。&lt;br&gt;
　　&lt;br&gt;
　　他和三只食人妖在篝火旁聊天，绞尽脑汁地营救矮人伙伴。&lt;br&gt;
　　他深入哥布林的洞穴，在黑暗中与Gollum猜谜。&lt;br&gt;
　　他在幽暗密林遭遇了大蜘蛛，用宝剑&#39;刺钉&#39;再度营救伙伴。&lt;br&gt;
　　他用木酒桶帮助矮人们逃离精灵王的府邸，却被河水淹了个够呛。&lt;br&gt;
　　他在伊鲁柏中吵醒了恶龙，用魔力指环躲避Smaug的追杀。&lt;br&gt;
　　他与精灵一起对抗奥克斯大军，目睹过巨鹰的雄壮美丽。&lt;br&gt;
　　&lt;br&gt;
　　再后来啊，他与巫师踏上曾走过的路，穿过茂密的森林，廖廓的原野以及幽静的河谷，回到他们最初离开的地方。&lt;br&gt;
　　这个霍比特人又住回了他的老屋，常常在炉火旁等待老友们的光临。他就这样幸福快乐地生活了下去，直到他的灵魂不再受形体的束缚，自由自在地畅游在山丘和原野之间。他化为一阵清风，萦绕在他的老友们之间，让他们欢笑，直到最后的最后。&lt;br&gt;
　　&lt;br&gt;
　　他的名字，叫做Bilbo Baggins。”&lt;br&gt;
　　&lt;br&gt;
　　“这真是个好故事，Bilbo。”Frodo笑着对我说，“这是我所听到过的最好的故事，真的。”&lt;br&gt;
　　“当然，我轻笑出声，“这可是我的小故事。”最后一眼望了望我挚爱的世界。&lt;br&gt;
　　&lt;br&gt;
　　是啊，my dear Frodo。我感觉意识逐渐模糊，灵魂也摆脱了形体的束缚，乘着海风飞向我心心念念的地方。&lt;br&gt;
　　&lt;br&gt;
　　My dear Frodo，我们终将成为故事。&lt;/p&gt;
&lt;p&gt;&lt;/br&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;The End.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;/br&gt;&lt;/br&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;故事完结于2015年3月&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;最初发表在霍比特人吧&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;最后一次编辑于2020.3.23下午&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;于2020.05.05决定为这篇文再留下些痕迹&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;2021.05.03 发表在自己的博客&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;strong&gt;跨越五年时光&lt;/strong&gt;&lt;/em&gt;&lt;br&gt;
&lt;em&gt;&lt;strong&gt;追求独特 热爱平凡&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt;
">A Little Story（短篇  比尔博.巴金斯相关）</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://Czardas42.github.io/post/chapter4_4.2/"" data-c="
          &lt;h2 id=&#34;1-特殊乘法&#34;&gt;&lt;strong&gt;1. 特殊乘法&lt;/strong&gt;&lt;/h2&gt;
&lt;h3 id=&#34;题目描述&#34;&gt;&lt;strong&gt;题目描述&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;写个算法，对2个小于1000000000的输入，求结果。 特殊乘法举例：123 * &lt;em&gt;45 = 1&lt;strong&gt;4 +1&lt;/strong&gt;5 +2&lt;strong&gt;4 +2&lt;/strong&gt;5 +3**4+3&lt;/em&gt;5&lt;/p&gt;
&lt;h3 id=&#34;要点&#34;&gt;&lt;strong&gt;要点&lt;/strong&gt;&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;char&lt;/code&gt;和&lt;code&gt;int&lt;/code&gt;类型的转换：&lt;code&gt;int((str1[i]-&#39;0&#39;)*(str2[j]-&#39;0&#39;))&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;用字符串处理数字的思路&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;提交地址&#34;&gt;提交地址&lt;/h3&gt;
&lt;p&gt;&lt;a href=&#34;https://www.nowcoder.com/practice/a5edebf0622045468436c74c3a34240f?tpId=60&amp;amp;tqId=29490&amp;amp;qru=%2Fta%2Ftsing-kaoyan%2Fquestion-ranking&amp;amp;tab=answerKey&#34;&gt;https://www.nowcoder.com/practice/a5edebf0622045468436c74c3a34240f?tpId=60&amp;amp;tqId=29490&amp;amp;qru=%2Fta%2Ftsing-kaoyan%2Fquestion-ranking&amp;amp;tab=answerKey&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&#34;代码&#34;&gt;代码&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;#include &amp;lt;iostream&amp;gt;

#include &amp;lt;cstdio&amp;gt;

#include &amp;lt;string&amp;gt;



using namespace std;



int main()

{

​    string str1, str2;

​    while(cin &amp;gt;&amp;gt; str1 &amp;gt;&amp;gt; str2)

​    {

​        int count = 0;

​        for (int i=0; i&amp;lt;str1.size(); i++)

​        {

​            for (int j=0; j&amp;lt;str2.size(); j++)

​            {

​                count = count + int((str1[i]-&#39;0&#39;)*(str2[j]-&#39;0&#39;));

​            }

​        }

​        cout &amp;lt;&amp;lt; count &amp;lt;&amp;lt; endl;

​    }

}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;2-密码翻译&#34;&gt;&lt;strong&gt;2.  密码翻译&lt;/strong&gt;&lt;/h2&gt;
&lt;h3 id=&#34;题目描述-2&#34;&gt;&lt;strong&gt;题目描述&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;在情报传递过程中，为了防止情报被截获，往往需要对情报用一定的方式加密，简单的加密算法虽然不足以完全避免情报被破译，但仍然能防止情报被轻易的识别。我们给出一种最简的的加密方法，对给定的一个字符串，把其中从a-y,A-Y的字母用其后继字母替代，把z和Z用a和A替代，则可得到一个简单的加密字符串。&lt;/p&gt;
&lt;h3 id=&#34;要点-2&#34;&gt;&lt;strong&gt;要点&lt;/strong&gt;&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;C++的if语句不可以使用连等，需要用&lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt;分开表示：&lt;code&gt;if ((int(&#39;a&#39;)&amp;lt;=num &amp;amp;&amp;amp; num&amp;lt;=int(&#39;z&#39;)) || (int(&#39;A&#39;)&amp;lt;=num &amp;amp;&amp;amp; num&amp;lt;=int(&#39;Z&#39;)))&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;用ASCII码鉴别字符&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;强制类型转换：&lt;code&gt;char()&lt;/code&gt;和&lt;code&gt;int()&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;要求整行输入，需要用到&lt;code&gt;getline(cin, str)&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;提交地址-2&#34;&gt;提交地址：&lt;/h3&gt;
&lt;p&gt;&lt;a href=&#34;https://www.nowcoder.com/practice/a5edebf0622045468436c74c3a34240f?tpId=60&amp;amp;tqId=29490&amp;amp;qru=%2Fta%2Ftsing-kaoyan%2Fquestion-ranking&amp;amp;tab=answerKey&#34;&gt;https://www.nowcoder.com/practice/a5edebf0622045468436c74c3a34240f?tpId=60&amp;amp;tqId=29490&amp;amp;qru=%2Fta%2Ftsing-kaoyan%2Fquestion-ranking&amp;amp;tab=answerKey&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&#34;代码-2&#34;&gt;&lt;strong&gt;代码&lt;/strong&gt;&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;#include &amp;lt;iostream&amp;gt;
#include &amp;lt;cstdio&amp;gt;
#include &amp;lt;string&amp;gt;

using namespace std;

int main()

{

​    string str;

​    while(getline(cin, str))

​    {

​        for(int i=0; i&amp;lt;str.size(); i++)

​        {

​            int num = int(str[i]);

​            if ((int(&#39;a&#39;)&amp;lt;=num &amp;amp;&amp;amp; num&amp;lt;=int(&#39;z&#39;)) || (int(&#39;A&#39;)&amp;lt;=num &amp;amp;&amp;amp; num&amp;lt;=int(&#39;Z&#39;)))

​            {

​                if (str[i] == &#39;z&#39;)

​                {

​                    str[i] == &#39;a&#39;;

​                }

​                else if(str[i] == &#39;Z&#39;)

​                {

​                    str[i] == &#39;A&#39;;

​                }

​                else

​                {

​                    str[i] = char(int(str[i]) + 1);

​                }

​                

​            }

​        }

​        cout &amp;lt;&amp;lt; str &amp;lt;&amp;lt; endl;

​    }

}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;3-简单密码&#34;&gt;&lt;strong&gt;3.  简单密码&lt;/strong&gt;&lt;/h2&gt;
&lt;h3 id=&#34;题目描述-3&#34;&gt;题目描述&lt;/h3&gt;
&lt;p&gt;Julius Caesar曾经使用过一种很简单的密码。 对于明文中的每个字符，将它用它字母表中后5位对应的字符来代替，这样就得到了密文。 比如字符A用F来代替。如下是密文和明文中字符的对应关系。 密文 A B C D E F G H I J K L M N O P Q R S T U V W X Y Z 明文 V W X Y Z A B C D E F G H I J K L M N O P Q R S T U 你的任务是对给定的密文进行解密得到明文。 你需要注意的是，密文中出现的字母都是大写字母。密文中也包括非字母的字符，对这些字符不用进行解码。&lt;/p&gt;
&lt;h3 id=&#34;要点-3&#34;&gt;&lt;strong&gt;要点&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;循环平移类问题&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;id：差量，从零开始&lt;/p&gt;
&lt;p&gt;begin：初始量&lt;/p&gt;
&lt;p&gt;公式1：&lt;code&gt;初始量 +（id + 平移量）% 个数&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;公式2：&lt;code&gt;初始量 +（id - 平移量 + 个数）% 个数&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;例如本题，A-Z每个字母取其前五的字母：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;str[i] = char(int(&#39;A&#39;) + (int(str[i])-int(&#39;A&#39;)-5+26)%26);
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;提交地址-3&#34;&gt;&lt;strong&gt;提交地址&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href=&#34;https://www.nowcoder.com/practice/ff99c43dd07f4e95a8f2f5448da3772a?tpId=61&amp;amp;tqId=29562&amp;amp;tPage=4&amp;amp;ru=%2Fkaoyan%2Fretest%2F1002&amp;amp;qru=%2Fta%2Fpku-kaoyan%2Fquestion-ranking&amp;amp;tab=answerKey&#34;&gt;https://www.nowcoder.com/practice/ff99c43dd07f4e95a8f2f5448da3772a?tpId=61&amp;amp;tqId=29562&amp;amp;tPage=4&amp;amp;ru=%2Fkaoyan%2Fretest%2F1002&amp;amp;qru=%2Fta%2Fpku-kaoyan%2Fquestion-ranking&amp;amp;tab=answerKey&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&#34;代码-3&#34;&gt;&lt;strong&gt;代码&lt;/strong&gt;&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;#include &amp;lt;iostream&amp;gt;
#include &amp;lt;cstdio&amp;gt;
#include &amp;lt;string&amp;gt;

using namespace std;

int main()

{

​    string str;

​    while (getline(cin, str))

​    {

​        if (str == &amp;quot;START&amp;quot; || str == &amp;quot;END&amp;quot;)

​            continue;

​        else if(str == &amp;quot;ENDOFINPUT&amp;quot;)

​            break;

​        else

​        {

​            for(int i=0; i&amp;lt;str.size(); i++)

​            {

​                if (int(&#39;A&#39;) &amp;lt;= int(str[i]) &amp;amp;&amp;amp; int(str[i])&amp;lt;= int(&#39;Z&#39;))

​                {

​                    str[i] = char(int(&#39;A&#39;) + (int(str[i])-int(&#39;A&#39;)-5+26)%26);

​                }

​            }

​            cout &amp;lt;&amp;lt; str &amp;lt;&amp;lt; endl;

​        }

​    }

}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;4-统计字符&#34;&gt;&lt;strong&gt;4.  统计字符&lt;/strong&gt;&lt;/h2&gt;
&lt;h3 id=&#34;题目描述-4&#34;&gt;题目描述&lt;/h3&gt;
&lt;p&gt;统计一个给定字符串中指定的字符出现的次数。&lt;/p&gt;
&lt;h3 id=&#34;要点-4&#34;&gt;要点&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;数组清零/初始化方法：（&lt;code&gt;cstring&lt;/code&gt;库）&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;​     &lt;code&gt;memset(number, 0, sizeof(number));&lt;/code&gt;&lt;/p&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;统计/计数问题思路：&lt;strong&gt;&lt;strong&gt;先全部计数，再按照要求输出即可&lt;/strong&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;提交地址-4&#34;&gt;提交地址&lt;/h3&gt;
&lt;p&gt;&lt;a href=&#34;https://www.nowcoder.com/practice/4ec4325634634193a7cd6798037697a8?tpId=63&amp;amp;tqId=29574&amp;amp;tPage=1&amp;amp;ru=%2Fkaoyan%2Fretest%2F9001&amp;amp;qru=%2Fta%2Fzju-kaoyan%2Fquestion-ranking&amp;amp;tab=answerKey&#34;&gt;https://www.nowcoder.com/practice/4ec4325634634193a7cd6798037697a8?tpId=63&amp;amp;tqId=29574&amp;amp;tPage=1&amp;amp;ru=%2Fkaoyan%2Fretest%2F9001&amp;amp;qru=%2Fta%2Fzju-kaoyan%2Fquestion-ranking&amp;amp;tab=answerKey&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&#34;代码-4&#34;&gt;代码&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;#include &amp;lt;iostream&amp;gt;
#include &amp;lt;cstdio&amp;gt;
#include &amp;lt;string&amp;gt;
#include &amp;lt;cstring&amp;gt;
using namespace std;

int main()

{

​    string str1, str2;

​    int number[128];

​    

​    while(getline(cin, str1))

​    {

​        if (str1 == &amp;quot;#&amp;quot;)

​            break;

​        else

​        {

​            getline(cin, str2);

​            memset(number, 0, sizeof(number));

​            for (int i=0; i&amp;lt;str2.size(); i++)

​            {

​                number[int(str2[i])]++;

​            }

​            for (int j=0; j&amp;lt;str1.size(); j++)

​            {

​                

​                cout &amp;lt;&amp;lt; str1[j] &amp;lt;&amp;lt; &amp;quot; &amp;quot;&amp;lt;&amp;lt; number[int(str1[j])] &amp;lt;&amp;lt; endl;

​            }

​        }

​        

​    }

}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;5-字母统计&#34;&gt;&lt;strong&gt;5.  字母统计&lt;/strong&gt;&lt;/h2&gt;
&lt;h3 id=&#34;题目描述-5&#34;&gt;&lt;strong&gt;题目描述&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;输入一行字符串，计算其中A-Z大写字母出现的次数&lt;/p&gt;
&lt;h3 id=&#34;要点-5&#34;&gt;&lt;strong&gt;要点&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;与前一题思路类似&lt;/p&gt;
&lt;h3 id=&#34;提交地址-5&#34;&gt;&lt;strong&gt;提交地址&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href=&#34;https://www.nowcoder.com/practice/de7bf0945c1c4bd1aa9d49573b831f3c?tpId=62&amp;amp;tqId=29470&amp;amp;tPage=2&amp;amp;ru=%2Fkaoyan%2Fretest%2F2002&amp;amp;qru=%2Fta%2Fsju-kaoyan%2Fquestion-ranking&amp;amp;tab=answerKey&#34;&gt;https://www.nowcoder.com/practice/de7bf0945c1c4bd1aa9d49573b831f3c?tpId=62&amp;amp;tqId=29470&amp;amp;tPage=2&amp;amp;ru=%2Fkaoyan%2Fretest%2F2002&amp;amp;qru=%2Fta%2Fsju-kaoyan%2Fquestion-ranking&amp;amp;tab=answerKey&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&#34;代码-5&#34;&gt;&lt;strong&gt;代码&lt;/strong&gt;&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;#include &amp;lt;iostream&amp;gt;

#include &amp;lt;cstdio&amp;gt;

#include &amp;lt;string&amp;gt;

#include &amp;lt;cstring&amp;gt;

using namespace std;

int main()

{

​    string str;

​    int count[26];

​    while (getline(cin, str))

​    {

​        memset(count, 0, sizeof(count));

​        for (int i=0; i&amp;lt;str.size(); i++)

​        {

​            if (&#39;A&#39;&amp;lt;=str[i] &amp;amp;&amp;amp; str[i]&amp;lt;=&#39;Z&#39;)

​            {

​                 count[int(str[i]-&#39;A&#39;)]++;

​            }   

​        }   

​        for (int j=0; j&amp;lt;26; j++)

​        {

​            cout &amp;lt;&amp;lt; char(int(&#39;A&#39;+j)) &amp;lt;&amp;lt; &amp;quot;:&amp;quot; &amp;lt;&amp;lt; count[j] &amp;lt;&amp;lt; endl;

​        }

​    }

}

&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;6-skew数&#34;&gt;&lt;strong&gt;6.  skew数&lt;/strong&gt;&lt;/h2&gt;
&lt;h3 id=&#34;题目描述-6&#34;&gt;&lt;strong&gt;题目描述&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;在 skew binary 表示中，第 k 位的值 x[k] 表示 x[k]×(2^(k+1)-1)。每个位上的可能数字是 0 或 1，最后面一个非零位可以是 2，例如，10120(skew) = 1×(2^5-1) + 0×(2^4-1) + 1×(2^3-1) + 2×(2^2-1) + 0×(2^1-1) = 31 + 0 + 7 + 6 + 0 = 44。前十个 skew 数是 0、1、2、10、11、12、20、100、101、以及 102。&lt;/p&gt;
&lt;h3 id=&#34;要点-6&#34;&gt;&lt;strong&gt;要点&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;次幂函数&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;math.h&amp;gt;
pow(a, b)
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;提交地址-6&#34;&gt;&lt;strong&gt;提交地址&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href=&#34;https://www.nowcoder.com/practice/5928127cc6604129923346e955e75984?tpId=61&amp;amp;tqId=29517&amp;amp;tPage=1&amp;amp;ru=%2Fkaoyan%2Fretest%2F1002&amp;amp;qru=%2Fta%2Fpku-kaoyan%2Fquestion-ranking&amp;amp;tab=answerKey&#34;&gt;https://www.nowcoder.com/practice/5928127cc6604129923346e955e75984?tpId=61&amp;amp;tqId=29517&amp;amp;tPage=1&amp;amp;ru=%2Fkaoyan%2Fretest%2F1002&amp;amp;qru=%2Fta%2Fpku-kaoyan%2Fquestion-ranking&amp;amp;tab=answerKey&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&#34;代码-6&#34;&gt;&lt;strong&gt;代码&lt;/strong&gt;&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-C++&#34;&gt;#include &amp;lt;iostream&amp;gt;
#include &amp;lt;cstdio&amp;gt;
#include &amp;lt;string&amp;gt;
#include &amp;lt;math.h&amp;gt;
using namespace std;

int main()

{

​    string str;

​    while (cin&amp;gt;&amp;gt;str)

​    {

​        int sum = 0;

​        for(int i=0; i&amp;lt;str.size(); i++)

​        {

​            int id = str.size() - i;

​            sum += int(str[i] - &#39;0&#39;) * (pow(2, id)-1);

​        }

​        cout &amp;lt;&amp;lt; sum &amp;lt;&amp;lt; endl;

​    }

}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;7-单词替换&#34;&gt;&lt;strong&gt;7.  单词替换&lt;/strong&gt;&lt;/h2&gt;
&lt;h3 id=&#34;题目描述-7&#34;&gt;&lt;strong&gt;题目描述&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;输入一个字符串，以回车结束（字符串长度&amp;lt;=100）。该字符串由若干个单词组成，单词之间用一个空格隔开，所有单词区分大小写。现需要将其中的某个单词替换成另一个单词，并输出替换之后的字符串。&lt;/p&gt;
&lt;h3 id=&#34;要点-7&#34;&gt;&lt;strong&gt;要点&lt;/strong&gt;&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;坑：可能需要替换的单词是其他单词的前缀或者后缀或者中间一部分&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;​    &lt;strong&gt;解决方法：在句子、被替换词、替换词的前后都加上空格，保证不会产生查找错误&lt;/strong&gt;&lt;/p&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;
&lt;p&gt;查找字符串中特定字符或者子串的方法(所有位置)&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-C++&#34;&gt;int position = 0;

while((position=line.find(str1,position))!=string::npos)

 {

​         //line.erase(position, str1.size());

​         //line.insert(position, str2);

​         line.replace(position,str1.length(),str2);

​         position++;

}
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;string类型基本操作&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;erase(起始位置，长度)
insert(起始位置，长度)
replace(起始位置，长度，替换结果)
substr(起始位置，长度)
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;提交地址-7&#34;&gt;&lt;strong&gt;提交地址&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href=&#34;https://www.nowcoder.com/practice/5b58a04679d5419caf62c2b238e5c9c7?tpId=61&amp;amp;tqId=29518&amp;amp;tPage=1&amp;amp;ru=%2Fkaoyan%2Fretest%2F1002&amp;amp;qru=%2Fta%2Fpku-kaoyan%2Fquestion-ranking&amp;amp;tab=answerKey&#34;&gt;https://www.nowcoder.com/practice/5b58a04679d5419caf62c2b238e5c9c7?tpId=61&amp;amp;tqId=29518&amp;amp;tPage=1&amp;amp;ru=%2Fkaoyan%2Fretest%2F1002&amp;amp;qru=%2Fta%2Fpku-kaoyan%2Fquestion-ranking&amp;amp;tab=answerKey&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&#34;代码-7&#34;&gt;&lt;strong&gt;代码&lt;/strong&gt;&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-C++&#34;&gt;#include &amp;lt;iostream&amp;gt;
#include &amp;lt;string&amp;gt;
#include &amp;lt;cstdio&amp;gt;

using namespace std;

int main()

{

​    string line;

​    while (getline(cin, line))

​    {

​        line = line;

​        string str1, str2;

​        cin &amp;gt;&amp;gt; str1 &amp;gt;&amp;gt; str2;

​        line = &#39; &#39; + line + &#39; &#39;;

​        str1 = &#39; &#39; + str1 + &#39; &#39;;

​        str2 = &#39; &#39; + str2 + &#39; &#39;;

​        

​        int position = 0;

​        while((position=line.find(str1,position))!=string::npos)

​        {

​            //line.erase(position, str1.size());

​            //line.insert(position, str2);

​            line.replace(position,str1.length(),str2);

​            position++;

​        }

​        

​        cout &amp;lt;&amp;lt; line.substr(1, line.size()-2) &amp;lt;&amp;lt; endl;

​    }

}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;8-首字母大写&#34;&gt;&lt;strong&gt;8.  首字母大写&lt;/strong&gt;&lt;/h2&gt;
&lt;h3 id=&#34;题目描述-8&#34;&gt;&lt;strong&gt;题目描述&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;对一个字符串中的所有单词，如果单词的首字母不是大写字母，则把单词的首字母变成大写字母。 在字符串中，单词之间通过空白符分隔，空白符包括：空格(&#39; &#39;)、制表符(&#39;\t&#39;)、回车符(&#39;\r&#39;)、换行符(&#39;\n&#39;)。&lt;/p&gt;
&lt;h3 id=&#34;要点-8&#34;&gt;&lt;strong&gt;要点&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;句首和其他位置要分开讨论&lt;/p&gt;
&lt;p&gt;其他位置可以根据空白符确定&lt;/p&gt;
&lt;h3 id=&#34;提交地址-8&#34;&gt;&lt;strong&gt;提交地址&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href=&#34;https://www.nowcoder.com/practice/91f9c70e7b6f4c0ab23744055632467a?tpId=61&amp;amp;tqId=29529&amp;amp;tPage=2&amp;amp;ru=%2Fkaoyan%2Fretest%2F1002&amp;amp;qru=%2Fta%2Fpku-kaoyan%2Fquestion-ranking&amp;amp;tab=answerKey&#34;&gt;https://www.nowcoder.com/practice/91f9c70e7b6f4c0ab23744055632467a?tpId=61&amp;amp;tqId=29529&amp;amp;tPage=2&amp;amp;ru=%2Fkaoyan%2Fretest%2F1002&amp;amp;qru=%2Fta%2Fpku-kaoyan%2Fquestion-ranking&amp;amp;tab=answerKey&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&#34;代码-8&#34;&gt;&lt;strong&gt;代码&lt;/strong&gt;&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-C++&#34;&gt;#include&amp;lt;iostream&amp;gt;
#include&amp;lt;string&amp;gt;
using namespace std;

int main(){

​    string s;

​    getline(cin,s);

​    for(int i=0;i&amp;lt;s.length();i++){

​        if(i==0)

​            s[i]=toupper(s[i]);

​        else{

​            if(s[i-1]==&#39; &#39;||s[i-1]==&#39;\t&#39;||s[i-1]==&#39;\r&#39;||s[i-1]==&#39;\n&#39;)

​                s[i]=toupper(s[i]);

​        }

​    }

​    cout&amp;lt;&amp;lt;s&amp;lt;&amp;lt;endl;

}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;9-浮点数加法&#34;&gt;&lt;strong&gt;9.  浮点数加法&lt;/strong&gt;&lt;/h2&gt;
&lt;h3 id=&#34;题目描述-9&#34;&gt;&lt;strong&gt;题目描述&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;对求2个浮点数相加的和 题目中输入输出中出现浮点数都有如下的形式： P1P2...Pi.Q1Q2...Qj 对于整数部分，P1P2...Pi是一个非负整数 对于小数部分，Qj不等于0&lt;/p&gt;
&lt;h3 id=&#34;要点-9&#34;&gt;&lt;strong&gt;要点&lt;/strong&gt;&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;整数和小数部分位数均可能不相等，所以都需要需要补0，可以分开操作&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;绝对值函数：&lt;code&gt;#include &amp;lt;cmath&amp;gt;&lt;/code&gt;  &lt;code&gt;int c = abs(a + b)&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;加法进位操作&lt;/p&gt;
&lt;p&gt;变量：两个加数，加数结果（中间变量），一个位结果，一个进位变量&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-C++&#34;&gt;int add = int((str1[i]-&#39;0&#39;) + (str2[i]-&#39;0&#39;));
result[i] = char(&#39;0&#39; + (add + temp)%10);    
temp = (add + temp)/10;
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;提交地址-9&#34;&gt;&lt;strong&gt;提交地址&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href=&#34;https://www.nowcoder.com/practice/ddec753f446e4ba4944e35378ba635c8?tpId=40&amp;amp;rp=1&amp;amp;ru=%2Fta%2Fkaoyan&amp;amp;qru=%2Fta%2Fkaoyan%2Fquestion-ranking&amp;amp;tab=answerKey&#34;&gt;https://www.nowcoder.com/practice/ddec753f446e4ba4944e35378ba635c8?tpId=40&amp;amp;rp=1&amp;amp;ru=%2Fta%2Fkaoyan&amp;amp;qru=%2Fta%2Fkaoyan%2Fquestion-ranking&amp;amp;tab=answerKey&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&#34;代码-9&#34;&gt;&lt;strong&gt;代码&lt;/strong&gt;&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-C++&#34;&gt;#include &amp;lt;iostream&amp;gt;
#include &amp;lt;string&amp;gt;
#include &amp;lt;cstdio&amp;gt;
#include &amp;lt;cmath&amp;gt;
using namespace std;

int main()
{
    string str1, str2;
    while(cin &amp;gt;&amp;gt; str1)
    {
        cin &amp;gt;&amp;gt; str2;
        int flag1 = str1.find(&#39;.&#39;) + 1; //str1整数长度
        int flag11 = str1.size() - flag1; //str1小数长度
        int flag2 = str2.find(&#39;.&#39;) + 1;
        int flag22 = str2.size() - flag2;
        int time1 = abs(flag1 - flag2); //str1和str2整数部分差值
        int time2 = abs(flag11 - flag22); //str1和str2小数部分差值
        //整数部分补0
        if (flag1 &amp;gt; flag2)
        {
            for(int i=0; i&amp;lt;time1; i++)
                str2 = &#39;0&#39; + str2;
        }
        else
        {
            for(int i=0; i&amp;lt;time1; i++)
                str1 = &#39;0&#39; + str1;
        }
        //小数部分补0
        if (flag11 &amp;gt; flag22)
        {
            for(int i=0; i&amp;lt;time2; i++)
                str2 = str2 + &#39;0&#39;;
        }
        else
        {
            for(int i=0; i&amp;lt;time2; i++)
                str1 = str1 + &#39;0&#39;;
        }
        //预存结果格式
        //注意：此处并没有考虑最高位进位的问题，用例中也没有出现
        string result = str1;
        int temp = 0;
        for (int i=str1.size()-1; i&amp;gt;=0; i--)
        {
            if (str1[i] != &#39;.&#39;)
            {   //经典加法操作
                int add = int((str1[i]-&#39;0&#39;) + (str2[i]-&#39;0&#39;));
                result[i] = char(&#39;0&#39; + (add + temp)%10);    
                temp = (add + temp)/10;
            }
        }
        cout &amp;lt;&amp;lt; result &amp;lt;&amp;lt; endl;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;10-后缀字串排序&#34;&gt;&lt;strong&gt;10.  后缀字串排序&lt;/strong&gt;&lt;/h2&gt;
&lt;h3 id=&#34;题目描述-10&#34;&gt;&lt;strong&gt;题目描述&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;对于一个字符串，将其后缀子串进行排序，例如grain 其子串有： grain rain ain in n 然后对各子串按字典顺序排序，即： ain,grain,in,n,rain&lt;/p&gt;
&lt;h3 id=&#34;要点-10&#34;&gt;&lt;strong&gt;要点&lt;/strong&gt;&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;两个步骤：得到所有后缀子串，排序输出&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;得到所有后缀子串方法&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;使用&lt;code&gt;str.substr(起始位, 长度)&lt;/code&gt;函数&lt;/p&gt;
&lt;p&gt;从单词最后一位开始遍历，同时增加长度&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;排序函数&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;void sort (RandomAccessIterator first, RandomAccessIterator last, Compare comp);&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;（1）第一个参数first：是要排序的数组的起始地址。&lt;/p&gt;
&lt;p&gt;（2）第二个参数last：是结束的地址（&lt;strong&gt;最后一个数据的后一个数据的地址&lt;/strong&gt;）&lt;/p&gt;
&lt;p&gt;（3）第三个参数comp是排序的方法：可以是从升序也可是降序。如果第三个参数不写，则默认的排序方法是从小到大排序。降序：&lt;code&gt;cmp&lt;/code&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;提交地址-10&#34;&gt;&lt;strong&gt;提交地址&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href=&#34;https://www.nowcoder.com/practice/f89f96ea3145418b8e6c3eb75773f65a?tpId=40&amp;amp;rp=1&amp;amp;ru=%2Fta%2Fkaoyan&amp;amp;qru=%2Fta%2Fkaoyan%2Fquestion-ranking&amp;amp;tab=answerKey&#34;&gt;https://www.nowcoder.com/practice/f89f96ea3145418b8e6c3eb75773f65a?tpId=40&amp;amp;rp=1&amp;amp;ru=%2Fta%2Fkaoyan&amp;amp;qru=%2Fta%2Fkaoyan%2Fquestion-ranking&amp;amp;tab=answerKey&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&#34;代码-10&#34;&gt;&lt;strong&gt;代码&lt;/strong&gt;&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-C++&#34;&gt;#include &amp;lt;iostream&amp;gt;
#include &amp;lt;cstdio&amp;gt;
#include &amp;lt;string&amp;gt;
#include &amp;lt;algorithm&amp;gt;
using namespace std;

int main()
{
    string str;
    while(cin &amp;gt;&amp;gt; str)
    {
        string sub[50];//50对于用例够了
        //得到后缀子串
        for (int i=str.size()-1, j=1; i&amp;gt;=0; i--, j++)
        {
            sub[i] = str.substr(i,j);
        }
        //排序
        sort(sub, sub+str.size());//记住！！！！！
        for (int i=0; i&amp;lt;str.size(); i++)
            cout &amp;lt;&amp;lt; sub[i] &amp;lt;&amp;lt; endl;
    }
    
}
&lt;/code&gt;&lt;/pre&gt;
">Chapter4 字符串：4.2 字符串处理</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://Czardas42.github.io/post/openfaas_project_notes/"" data-c="
          &lt;h1 id=&#34;1-kubernetes&#34;&gt;1. Kubernetes&lt;/h1&gt;
&lt;h2 id=&#34;11-架构节点工作负载&#34;&gt;1.1 架构(节点)，工作负载&lt;/h2&gt;
&lt;h3 id=&#34;nodes&#34;&gt;nodes：&lt;/h3&gt;
&lt;p&gt;&lt;a href=&#34;https://kubernetes.io/zh/docs/concepts/architecture/nodes/&#34;&gt;https://kubernetes.io/zh/docs/concepts/architecture/nodes/&lt;/a&gt;&lt;br&gt;
&lt;/br&gt;&lt;/p&gt;
&lt;h3 id=&#34;pods&#34;&gt;Pods：&lt;/h3&gt;
&lt;p&gt;Pod 是可以在 Kubernetes 中创建和管理的、最小的可部署的计算单元。&lt;br&gt;
&lt;a href=&#34;https://kubernetes.io/zh/docs/concepts/workloads/&#34;&gt;https://kubernetes.io/zh/docs/concepts/workloads/&lt;/a&gt;&lt;br&gt;
&lt;/br&gt;&lt;/p&gt;
&lt;h2 id=&#34;12-服务-负载均衡和联网&#34;&gt;1.2 服务、负载均衡和联网&lt;/h2&gt;
&lt;h3 id=&#34;使用-service-连接到应用&#34;&gt;使用 Service 连接到应用:&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;可结合Prometheus部署过程进行阐述&lt;/strong&gt;&lt;br&gt;
&lt;a href=&#34;https://kubernetes.io/zh/docs/concepts/services-networking/connect-applications-service/&#34;&gt;https://kubernetes.io/zh/docs/concepts/services-networking/connect-applications-service/&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&#34;用-kubectl-扩缩应用程序deployment副本数&#34;&gt;用 kubectl 扩缩应用程序(Deployment副本数)：&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;可结合正确删除pod的方法进行阐述&lt;/strong&gt;&lt;br&gt;
在之前的模块中，我们创建了一个 Deployment，然后通过 Service让其可以开放访问。Deployment 仅为跑这个应用程序创建了一个 Pod。 当流量增加时，我们需要扩容应用程序满足用户需求。&lt;br&gt;
&lt;a href=&#34;https://kubernetes.io/zh/docs/tutorials/kubernetes-basics/scale/scale-intro/&#34;&gt;https://kubernetes.io/zh/docs/tutorials/kubernetes-basics/scale/scale-intro/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;/br&gt;&lt;/br&gt;&lt;/p&gt;
&lt;h1 id=&#34;2-openfaas&#34;&gt;2. OpenFaaS&lt;/h1&gt;
&lt;h2 id=&#34;21-layers-and-responsibilities-工作流程&#34;&gt;2.1 Layers and responsibilities 工作流程&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://docs.openfaas.com/architecture/stack/#openfaas-stack&#34;&gt;https://docs.openfaas.com/architecture/stack/#openfaas-stack&lt;/a&gt;&lt;br&gt;
&lt;/br&gt;&lt;/p&gt;
&lt;h2 id=&#34;22-架构gateway&#34;&gt;2.2 架构&amp;amp;Gateway&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://docs.openfaas.com/architecture/gateway/&#34;&gt;https://docs.openfaas.com/architecture/gateway/&lt;/a&gt;&lt;br&gt;
&lt;/br&gt;&lt;/p&gt;
&lt;h2 id=&#34;23-watchdog工作原理-函数请求处理流程详解&#34;&gt;2.3 Watchdog工作原理&amp;amp; 函数请求处理流程详解&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://docs.openfaas.com/architecture/watchdog/&#34;&gt;https://docs.openfaas.com/architecture/watchdog/&lt;/a&gt;&lt;br&gt;
&lt;a href=&#34;https://blog.csdn.net/weixin_38616705/article/details/107385293&#34;&gt;https://blog.csdn.net/weixin_38616705/article/details/107385293&lt;/a&gt;&lt;br&gt;
&lt;/br&gt;&lt;/p&gt;
&lt;h2 id=&#34;24-自动缩放工作原理冷启动43&#34;&gt;2.4 自动缩放工作原理&amp;amp;冷启动（4.3）&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://docs.openfaas.com/architecture/autoscaling/&#34;&gt;https://docs.openfaas.com/architecture/autoscaling/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;/br&gt;&lt;/br&gt;&lt;/p&gt;
&lt;h1 id=&#34;3-prometheusgrafana&#34;&gt;3. Prometheus&amp;amp;Grafana&lt;/h1&gt;
&lt;h2 id=&#34;31-yml文件配置结合prometheus配置过程&#34;&gt;3.1 yml文件配置(结合Prometheus配置过程)&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://blog.csdn.net/weixin_29278805/article/details/112493314?utm_medium=distribute.pc_relevant.none-task-blog-baidujs_title-0&amp;amp;spm=1001.2101.3001.4242&#34;&gt;https://blog.csdn.net/weixin_29278805/article/details/112493314?utm_medium=distribute.pc_relevant.none-task-blog-baidujs_title-0&amp;amp;spm=1001.2101.3001.4242&lt;/a&gt;&lt;br&gt;
&lt;/br&gt;&lt;/p&gt;
&lt;h2 id=&#34;32-promql语法以及实验使用示例&#34;&gt;3.2 PromQL语法以及实验使用示例&lt;/h2&gt;
&lt;p&gt;Prometheus内置的数据查询语言，其提供对时间序列数据丰富的查询，聚合以及逻辑运算能力的支持。并且被广泛应用在Prometheus的日常应用当中，包括对数据查询、可视化、告警处理当中。&lt;br&gt;
&lt;a href=&#34;https://yunlzheng.gitbook.io/prometheus-book/parti-prometheus-ji-chu/promql/prometheus-query-language&#34;&gt;https://yunlzheng.gitbook.io/prometheus-book/parti-prometheus-ji-chu/promql/prometheus-query-language&lt;/a&gt;&lt;br&gt;
&lt;/br&gt;&lt;/br&gt;&lt;/p&gt;
&lt;h1 id=&#34;4-实验&#34;&gt;4. 实验&lt;/h1&gt;
&lt;h2 id=&#34;41-控制变量-相关性&#34;&gt;4.1 控制变量 &amp;amp; 相关性&lt;/h2&gt;
&lt;h2 id=&#34;42-压力测试&#34;&gt;4.2 压力测试&lt;/h2&gt;
&lt;h2 id=&#34;43-冷热启动&#34;&gt;4.3 冷热启动&lt;/h2&gt;
&lt;p&gt;&lt;/br&gt;&lt;/br&gt;&lt;/p&gt;
&lt;h1 id=&#34;5-其他&#34;&gt;5. 其他&lt;/h1&gt;
&lt;h2 id=&#34;51-vpc对等连接涉及计网相关知识&#34;&gt;5.1 VPC对等连接(涉及计网相关知识)&lt;/h2&gt;
&lt;p&gt;对等连接(peer-to-peer，简写为 P2P)是指两个主机在通信时并不区分哪一个是服务请求方还是服务提供方。&lt;br&gt;
只要两个主机都运行了对等连接软件（P2P 软件），它们就可以进行平等的、对等连接通信。&lt;br&gt;
&lt;a href=&#34;https://support.huaweicloud.com/usermanual-vpc/vpc_peering_0000.html&#34;&gt;https://support.huaweicloud.com/usermanual-vpc/vpc_peering_0000.html&lt;/a&gt;&lt;br&gt;
&lt;a href=&#34;https://www.cnblogs.com/liuawen/p/11930142.html#2_134&#34;&gt;https://www.cnblogs.com/liuawen/p/11930142.html#2_134&lt;/a&gt;&lt;br&gt;
&lt;a href=&#34;https://www.nowcoder.com/questionTerminal/f14684caf72042a2a747f5d7df32670b&#34;&gt;https://www.nowcoder.com/questionTerminal/f14684caf72042a2a747f5d7df32670b&lt;/a&gt;&lt;br&gt;
&lt;/br&gt;&lt;/br&gt;&lt;/p&gt;
">云计算大作业知识点</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://Czardas42.github.io/post/Trusted_Computing/"" data-c="
          &lt;h1 id=&#34;安全含义&#34;&gt;安全含义&lt;/h1&gt;
&lt;p&gt;CIA：机密， 完整，可用&lt;br&gt;
在信息安全等级保护工作中，根据信息系统的机密性（Confidentiality）、完整性（Integrity）、可用性（Availability）来划分信息系统的安全等级，三个性质简称CIA&lt;/p&gt;
&lt;h1 id=&#34;信息安全五性&#34;&gt;信息安全五性：&lt;/h1&gt;
&lt;p&gt;事前可验证性&lt;br&gt;
事后不可否认性&lt;br&gt;
CIA&lt;/p&gt;
&lt;h1 id=&#34;可信-约等于-安全-可靠&#34;&gt;可信 约等于 安全 + 可靠&lt;/h1&gt;
">可信计算</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://Czardas42.github.io/post/20210427_ks8_openfaas_test/"" data-c="
          &lt;h2 id=&#34;1-分布式负载测试web测试应用的pod负载变化&#34;&gt;1. 分布式负载测试：web测试应用的pod负载变化&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;准备&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&#34;a-部署web应用&#34;&gt;a. 部署Web应用&lt;/h3&gt;
&lt;h3 id=&#34;b-部署locust测试工具&#34;&gt;b. 部署Locust（测试工具）&lt;/h3&gt;
&lt;h3 id=&#34;c-配置traefik监控-可用prometheus&#34;&gt;c. 配置Traefik（监控） 可用Prometheus&lt;/h3&gt;
&lt;p&gt;&lt;/br&gt;&lt;/br&gt;&lt;br&gt;
&lt;strong&gt;测试方法&lt;/strong&gt;&lt;br&gt;
打开&lt;a href=&#34;http://traefik.locust.io&#34;&gt;http://traefik.locust.io&lt;/a&gt;页面，点击Edit输入伪造的用户数和用户每秒发送的请求个数，点击Start Swarming就可以开始测试了。&lt;/p&gt;
&lt;p&gt;在测试过程中调整sample-webapp的pod个数（默认设置了1个pod），观察pod的负载变化情况。&lt;br&gt;
从一段时间的观察中可以看到负载被平均分配给了3个pod.&lt;br&gt;
在locust的页面中可以实时观察也可以下载测试结果。&lt;/p&gt;
&lt;p&gt;&lt;/br&gt;&lt;/br&gt;&lt;br&gt;
&lt;strong&gt;【参考】&lt;/strong&gt;&lt;br&gt;
&lt;a href=&#34;https://www.ctolib.com/docs/sfile/kubernetes-handbook/practice/distributed-load-test.html&#34;&gt;https://www.ctolib.com/docs/sfile/kubernetes-handbook/practice/distributed-load-test.html&lt;/a&gt;&lt;br&gt;
&lt;/br&gt;&lt;/br&gt;&lt;/p&gt;
&lt;h2 id=&#34;2-网络延迟测试通过不同方式访问web测试应用&#34;&gt;2. 网络延迟测试：通过不同方式访问web测试应用&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;测试场景&lt;/strong&gt;&lt;br&gt;
场景一、 Kubernetes集群node节点上通过Cluster IP访问sample-webapp&lt;br&gt;
场景二、Kubernetes集群内部通过service访问sample-webapp&lt;br&gt;
场景三、在公网上通过traefik ingress访问sample-webapp&lt;br&gt;
&lt;/br&gt;&lt;/br&gt;&lt;br&gt;
&lt;strong&gt;测试结果&lt;/strong&gt;&lt;br&gt;
在这三种场景下的响应时间测试结果如下：&lt;br&gt;
Kubernetes集群node节点上通过Cluster IP方式访问：2ms&lt;br&gt;
Kubernetes集群内部通过service访问：6ms&lt;br&gt;
Kubernetes集群外部通过traefik ingress暴露的地址访问：110ms&lt;br&gt;
注意：执行测试的node节点/Pod与serivce所在的pod的距离（是否在同一台主机上），对前两个场景可以能会有一定影响。&lt;br&gt;
&lt;/br&gt;&lt;/br&gt;&lt;br&gt;
&lt;strong&gt;【参考】&lt;/strong&gt;&lt;br&gt;
&lt;a href=&#34;https://www.ctolib.com/docs/sfile/kubernetes-handbook/practice/network-and-cluster-perfermance-test.html&#34;&gt;https://www.ctolib.com/docs/sfile/kubernetes-handbook/practice/network-and-cluster-perfermance-test.html&lt;/a&gt;&lt;br&gt;
&lt;/br&gt;&lt;/br&gt;&lt;/p&gt;
&lt;h2 id=&#34;3-网络性能测试暂时不考虑&#34;&gt;3. 网络性能测试(暂时不考虑)&lt;/h2&gt;
&lt;p&gt;网络使用flannel的vxlan模式。&lt;br&gt;
使用iperf进行测试。&lt;/p&gt;
&lt;p&gt;使用Flannel的vxlan模式实现每个pod一个IP的方式，会比宿主机直接互联的网络性能损耗30%～40%，符合网上流传的测试结论。而flannel的host-gw模式比起宿主机互连的网络性能损耗大约是10%。&lt;/p&gt;
&lt;p&gt;Vxlan会有一个封包解包的过程，所以会对网络性能造成较大的损耗，而host-gw模式是直接使用路由信息，网络损耗小。&lt;br&gt;
&lt;strong&gt;【参考】&lt;/strong&gt;&lt;br&gt;
&lt;a href=&#34;https://www.ctolib.com/docs/sfile/kubernetes-handbook/practice/network-and-cluster-perfermance-test.html&#34;&gt;https://www.ctolib.com/docs/sfile/kubernetes-handbook/practice/network-and-cluster-perfermance-test.html&lt;/a&gt;&lt;br&gt;
&lt;/br&gt;&lt;/br&gt;&lt;/p&gt;
&lt;h2 id=&#34;4-不同type的资源类型api请求耗时分布测试暂时不考虑&#34;&gt;4. 不同type的资源类型API请求耗时分布测试(暂时不考虑)&lt;/h2&gt;
&lt;/br&gt;
**【参考】**
&lt;https://www.ctolib.com/docs/sfile/kubernetes-handbook/practice/network-and-cluster-perfermance-test.html&gt;
&lt;https://supereagle.github.io/2017/03/09/kubemark/&gt;
">2021.04.27：K8s 性能测试</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://Czardas42.github.io/post/20210427_grafana/"" data-c="
          &lt;p&gt;&lt;strong&gt;监控内容：各节点CPU使用率、磁盘、内存、磁盘IO读写、网络IO速率&lt;/strong&gt;&lt;br&gt;
&lt;/br&gt;&lt;/br&gt;&lt;br&gt;
&lt;strong&gt;监控平台截图：&lt;/strong&gt;&lt;br&gt;
&lt;img src=&#34;https://Czardas42.github.io//post-images/1619580572559.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://Czardas42.github.io//post-images/1619580593621.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;2&#34;&gt;&lt;img src=&#34;https://Czardas42.github.io//post-images/1619580606902.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;3&#34;&gt;&lt;img src=&#34;https://Czardas42.github.io//post-images/1619580616167.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;&lt;img src=&#34;https://Czardas42.github.io//post-images/1619580630042.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;/br&gt;&lt;/br&gt;&lt;br&gt;
&lt;strong&gt;对应JSON文件如下：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;{
  &amp;quot;__inputs&amp;quot;: [
    {
      &amp;quot;name&amp;quot;: &amp;quot;DS_FAAS&amp;quot;,
      &amp;quot;label&amp;quot;: &amp;quot;faas&amp;quot;,
      &amp;quot;description&amp;quot;: &amp;quot;&amp;quot;,
      &amp;quot;type&amp;quot;: &amp;quot;datasource&amp;quot;,
      &amp;quot;pluginId&amp;quot;: &amp;quot;prometheus&amp;quot;,
      &amp;quot;pluginName&amp;quot;: &amp;quot;Prometheus&amp;quot;
    }
  ],
  &amp;quot;__requires&amp;quot;: [
    {
      &amp;quot;type&amp;quot;: &amp;quot;grafana&amp;quot;,
      &amp;quot;id&amp;quot;: &amp;quot;grafana&amp;quot;,
      &amp;quot;name&amp;quot;: &amp;quot;Grafana&amp;quot;,
      &amp;quot;version&amp;quot;: &amp;quot;4.6.3&amp;quot;
    },
    {
      &amp;quot;type&amp;quot;: &amp;quot;panel&amp;quot;,
      &amp;quot;id&amp;quot;: &amp;quot;graph&amp;quot;,
      &amp;quot;name&amp;quot;: &amp;quot;Graph&amp;quot;,
      &amp;quot;version&amp;quot;: &amp;quot;&amp;quot;
    },
    {
      &amp;quot;type&amp;quot;: &amp;quot;datasource&amp;quot;,
      &amp;quot;id&amp;quot;: &amp;quot;prometheus&amp;quot;,
      &amp;quot;name&amp;quot;: &amp;quot;Prometheus&amp;quot;,
      &amp;quot;version&amp;quot;: &amp;quot;1.0.0&amp;quot;
    }
  ],
  &amp;quot;annotations&amp;quot;: {
    &amp;quot;list&amp;quot;: [
      {
        &amp;quot;builtIn&amp;quot;: 1,
        &amp;quot;datasource&amp;quot;: &amp;quot;-- Grafana --&amp;quot;,
        &amp;quot;enable&amp;quot;: true,
        &amp;quot;hide&amp;quot;: true,
        &amp;quot;iconColor&amp;quot;: &amp;quot;rgba(0, 211, 255, 1)&amp;quot;,
        &amp;quot;name&amp;quot;: &amp;quot;Annotations &amp;amp; Alerts&amp;quot;,
        &amp;quot;type&amp;quot;: &amp;quot;dashboard&amp;quot;
      }
    ]
  },
  &amp;quot;editable&amp;quot;: true,
  &amp;quot;gnetId&amp;quot;: null,
  &amp;quot;graphTooltip&amp;quot;: 0,
  &amp;quot;hideControls&amp;quot;: false,
  &amp;quot;id&amp;quot;: null,
  &amp;quot;links&amp;quot;: [],
  &amp;quot;rows&amp;quot;: [
    {
      &amp;quot;collapse&amp;quot;: false,
      &amp;quot;height&amp;quot;: &amp;quot;250px&amp;quot;,
      &amp;quot;panels&amp;quot;: [
        {
          &amp;quot;aliasColors&amp;quot;: {},
          &amp;quot;bars&amp;quot;: true,
          &amp;quot;dashLength&amp;quot;: 10,
          &amp;quot;dashes&amp;quot;: false,
          &amp;quot;datasource&amp;quot;: &amp;quot;${DS_FAAS}&amp;quot;,
          &amp;quot;fill&amp;quot;: 1,
          &amp;quot;id&amp;quot;: 11,
          &amp;quot;legend&amp;quot;: {
            &amp;quot;alignAsTable&amp;quot;: true,
            &amp;quot;avg&amp;quot;: false,
            &amp;quot;current&amp;quot;: false,
            &amp;quot;max&amp;quot;: false,
            &amp;quot;min&amp;quot;: false,
            &amp;quot;show&amp;quot;: true,
            &amp;quot;total&amp;quot;: false,
            &amp;quot;values&amp;quot;: false
          },
          &amp;quot;lines&amp;quot;: true,
          &amp;quot;linewidth&amp;quot;: 1,
          &amp;quot;links&amp;quot;: [],
          &amp;quot;nullPointMode&amp;quot;: &amp;quot;null&amp;quot;,
          &amp;quot;percentage&amp;quot;: false,
          &amp;quot;pointradius&amp;quot;: 5,
          &amp;quot;points&amp;quot;: false,
          &amp;quot;renderer&amp;quot;: &amp;quot;flot&amp;quot;,
          &amp;quot;seriesOverrides&amp;quot;: [],
          &amp;quot;spaceLength&amp;quot;: 10,
          &amp;quot;span&amp;quot;: 4,
          &amp;quot;stack&amp;quot;: false,
          &amp;quot;steppedLine&amp;quot;: false,
          &amp;quot;targets&amp;quot;: [
            {
              &amp;quot;expr&amp;quot;: &amp;quot;100 - (avg by(instance) (irate(node_cpu_seconds_total{mode=\&amp;quot;idle\&amp;quot;, job=\&amp;quot;master_node_exporter_metrics\&amp;quot;}[5m])) * 100) &amp;quot;,
              &amp;quot;format&amp;quot;: &amp;quot;time_series&amp;quot;,
              &amp;quot;intervalFactor&amp;quot;: 2,
              &amp;quot;refId&amp;quot;: &amp;quot;A&amp;quot;
            }
          ],
          &amp;quot;thresholds&amp;quot;: [],
          &amp;quot;timeFrom&amp;quot;: &amp;quot;1h&amp;quot;,
          &amp;quot;timeShift&amp;quot;: null,
          &amp;quot;title&amp;quot;: &amp;quot;Master CPU使用率&amp;quot;,
          &amp;quot;tooltip&amp;quot;: {
            &amp;quot;shared&amp;quot;: true,
            &amp;quot;sort&amp;quot;: 0,
            &amp;quot;value_type&amp;quot;: &amp;quot;individual&amp;quot;
          },
          &amp;quot;type&amp;quot;: &amp;quot;graph&amp;quot;,
          &amp;quot;xaxis&amp;quot;: {
            &amp;quot;buckets&amp;quot;: null,
            &amp;quot;mode&amp;quot;: &amp;quot;time&amp;quot;,
            &amp;quot;name&amp;quot;: null,
            &amp;quot;show&amp;quot;: true,
            &amp;quot;values&amp;quot;: []
          },
          &amp;quot;yaxes&amp;quot;: [
            {
              &amp;quot;format&amp;quot;: &amp;quot;short&amp;quot;,
              &amp;quot;label&amp;quot;: null,
              &amp;quot;logBase&amp;quot;: 1,
              &amp;quot;max&amp;quot;: null,
              &amp;quot;min&amp;quot;: null,
              &amp;quot;show&amp;quot;: true
            },
            {
              &amp;quot;format&amp;quot;: &amp;quot;short&amp;quot;,
              &amp;quot;label&amp;quot;: null,
              &amp;quot;logBase&amp;quot;: 1,
              &amp;quot;max&amp;quot;: null,
              &amp;quot;min&amp;quot;: null,
              &amp;quot;show&amp;quot;: true
            }
          ]
        },
        {
          &amp;quot;aliasColors&amp;quot;: {},
          &amp;quot;bars&amp;quot;: true,
          &amp;quot;dashLength&amp;quot;: 10,
          &amp;quot;dashes&amp;quot;: false,
          &amp;quot;datasource&amp;quot;: &amp;quot;${DS_FAAS}&amp;quot;,
          &amp;quot;fill&amp;quot;: 1,
          &amp;quot;id&amp;quot;: 13,
          &amp;quot;legend&amp;quot;: {
            &amp;quot;alignAsTable&amp;quot;: true,
            &amp;quot;avg&amp;quot;: false,
            &amp;quot;current&amp;quot;: false,
            &amp;quot;max&amp;quot;: false,
            &amp;quot;min&amp;quot;: false,
            &amp;quot;show&amp;quot;: true,
            &amp;quot;total&amp;quot;: false,
            &amp;quot;values&amp;quot;: false
          },
          &amp;quot;lines&amp;quot;: true,
          &amp;quot;linewidth&amp;quot;: 1,
          &amp;quot;links&amp;quot;: [],
          &amp;quot;nullPointMode&amp;quot;: &amp;quot;null&amp;quot;,
          &amp;quot;percentage&amp;quot;: false,
          &amp;quot;pointradius&amp;quot;: 5,
          &amp;quot;points&amp;quot;: false,
          &amp;quot;renderer&amp;quot;: &amp;quot;flot&amp;quot;,
          &amp;quot;seriesOverrides&amp;quot;: [],
          &amp;quot;spaceLength&amp;quot;: 10,
          &amp;quot;span&amp;quot;: 4,
          &amp;quot;stack&amp;quot;: false,
          &amp;quot;steppedLine&amp;quot;: false,
          &amp;quot;targets&amp;quot;: [
            {
              &amp;quot;expr&amp;quot;: &amp;quot;100 - (avg by(instance) (irate(node_cpu_seconds_total{mode=\&amp;quot;idle\&amp;quot;, job=\&amp;quot;slave-0001_node_exporter_metrics\&amp;quot;}[5m])) * 100) &amp;quot;,
              &amp;quot;format&amp;quot;: &amp;quot;time_series&amp;quot;,
              &amp;quot;intervalFactor&amp;quot;: 2,
              &amp;quot;refId&amp;quot;: &amp;quot;A&amp;quot;
            }
          ],
          &amp;quot;thresholds&amp;quot;: [],
          &amp;quot;timeFrom&amp;quot;: &amp;quot;1h&amp;quot;,
          &amp;quot;timeShift&amp;quot;: null,
          &amp;quot;title&amp;quot;: &amp;quot;Slave-0001 CPU使用率&amp;quot;,
          &amp;quot;tooltip&amp;quot;: {
            &amp;quot;shared&amp;quot;: true,
            &amp;quot;sort&amp;quot;: 0,
            &amp;quot;value_type&amp;quot;: &amp;quot;individual&amp;quot;
          },
          &amp;quot;type&amp;quot;: &amp;quot;graph&amp;quot;,
          &amp;quot;xaxis&amp;quot;: {
            &amp;quot;buckets&amp;quot;: null,
            &amp;quot;mode&amp;quot;: &amp;quot;time&amp;quot;,
            &amp;quot;name&amp;quot;: null,
            &amp;quot;show&amp;quot;: true,
            &amp;quot;values&amp;quot;: []
          },
          &amp;quot;yaxes&amp;quot;: [
            {
              &amp;quot;format&amp;quot;: &amp;quot;short&amp;quot;,
              &amp;quot;label&amp;quot;: null,
              &amp;quot;logBase&amp;quot;: 1,
              &amp;quot;max&amp;quot;: null,
              &amp;quot;min&amp;quot;: null,
              &amp;quot;show&amp;quot;: true
            },
            {
              &amp;quot;format&amp;quot;: &amp;quot;short&amp;quot;,
              &amp;quot;label&amp;quot;: null,
              &amp;quot;logBase&amp;quot;: 1,
              &amp;quot;max&amp;quot;: null,
              &amp;quot;min&amp;quot;: null,
              &amp;quot;show&amp;quot;: true
            }
          ]
        },
        {
          &amp;quot;aliasColors&amp;quot;: {},
          &amp;quot;bars&amp;quot;: true,
          &amp;quot;dashLength&amp;quot;: 10,
          &amp;quot;dashes&amp;quot;: false,
          &amp;quot;datasource&amp;quot;: &amp;quot;${DS_FAAS}&amp;quot;,
          &amp;quot;fill&amp;quot;: 1,
          &amp;quot;id&amp;quot;: 14,
          &amp;quot;legend&amp;quot;: {
            &amp;quot;alignAsTable&amp;quot;: true,
            &amp;quot;avg&amp;quot;: false,
            &amp;quot;current&amp;quot;: false,
            &amp;quot;max&amp;quot;: false,
            &amp;quot;min&amp;quot;: false,
            &amp;quot;show&amp;quot;: true,
            &amp;quot;total&amp;quot;: false,
            &amp;quot;values&amp;quot;: false
          },
          &amp;quot;lines&amp;quot;: true,
          &amp;quot;linewidth&amp;quot;: 1,
          &amp;quot;links&amp;quot;: [],
          &amp;quot;nullPointMode&amp;quot;: &amp;quot;null&amp;quot;,
          &amp;quot;percentage&amp;quot;: false,
          &amp;quot;pointradius&amp;quot;: 5,
          &amp;quot;points&amp;quot;: false,
          &amp;quot;renderer&amp;quot;: &amp;quot;flot&amp;quot;,
          &amp;quot;seriesOverrides&amp;quot;: [],
          &amp;quot;spaceLength&amp;quot;: 10,
          &amp;quot;span&amp;quot;: 4,
          &amp;quot;stack&amp;quot;: false,
          &amp;quot;steppedLine&amp;quot;: false,
          &amp;quot;targets&amp;quot;: [
            {
              &amp;quot;expr&amp;quot;: &amp;quot;100 - (avg by(instance) (irate(node_cpu_seconds_total{mode=\&amp;quot;idle\&amp;quot;, job=\&amp;quot;slave-0002_node_exporter_metrics\&amp;quot;}[5m])) * 100) &amp;quot;,
              &amp;quot;format&amp;quot;: &amp;quot;time_series&amp;quot;,
              &amp;quot;intervalFactor&amp;quot;: 2,
              &amp;quot;refId&amp;quot;: &amp;quot;A&amp;quot;
            }
          ],
          &amp;quot;thresholds&amp;quot;: [],
          &amp;quot;timeFrom&amp;quot;: &amp;quot;1h&amp;quot;,
          &amp;quot;timeShift&amp;quot;: null,
          &amp;quot;title&amp;quot;: &amp;quot;Slave-0002 CPU使用率&amp;quot;,
          &amp;quot;tooltip&amp;quot;: {
            &amp;quot;shared&amp;quot;: true,
            &amp;quot;sort&amp;quot;: 0,
            &amp;quot;value_type&amp;quot;: &amp;quot;individual&amp;quot;
          },
          &amp;quot;type&amp;quot;: &amp;quot;graph&amp;quot;,
          &amp;quot;xaxis&amp;quot;: {
            &amp;quot;buckets&amp;quot;: null,
            &amp;quot;mode&amp;quot;: &amp;quot;time&amp;quot;,
            &amp;quot;name&amp;quot;: null,
            &amp;quot;show&amp;quot;: true,
            &amp;quot;values&amp;quot;: []
          },
          &amp;quot;yaxes&amp;quot;: [
            {
              &amp;quot;format&amp;quot;: &amp;quot;short&amp;quot;,
              &amp;quot;label&amp;quot;: null,
              &amp;quot;logBase&amp;quot;: 1,
              &amp;quot;max&amp;quot;: null,
              &amp;quot;min&amp;quot;: null,
              &amp;quot;show&amp;quot;: true
            },
            {
              &amp;quot;format&amp;quot;: &amp;quot;short&amp;quot;,
              &amp;quot;label&amp;quot;: null,
              &amp;quot;logBase&amp;quot;: 1,
              &amp;quot;max&amp;quot;: null,
              &amp;quot;min&amp;quot;: null,
              &amp;quot;show&amp;quot;: true
            }
          ]
        }
      ],
      &amp;quot;repeat&amp;quot;: null,
      &amp;quot;repeatIteration&amp;quot;: null,
      &amp;quot;repeatRowId&amp;quot;: null,
      &amp;quot;showTitle&amp;quot;: false,
      &amp;quot;title&amp;quot;: &amp;quot;Dashboard Row&amp;quot;,
      &amp;quot;titleSize&amp;quot;: &amp;quot;h6&amp;quot;
    },
    {
      &amp;quot;collapse&amp;quot;: false,
      &amp;quot;height&amp;quot;: 250,
      &amp;quot;panels&amp;quot;: [
        {
          &amp;quot;aliasColors&amp;quot;: {},
          &amp;quot;bars&amp;quot;: false,
          &amp;quot;dashLength&amp;quot;: 10,
          &amp;quot;dashes&amp;quot;: false,
          &amp;quot;datasource&amp;quot;: &amp;quot;${DS_FAAS}&amp;quot;,
          &amp;quot;fill&amp;quot;: 1,
          &amp;quot;id&amp;quot;: 2,
          &amp;quot;legend&amp;quot;: {
            &amp;quot;alignAsTable&amp;quot;: true,
            &amp;quot;avg&amp;quot;: false,
            &amp;quot;current&amp;quot;: false,
            &amp;quot;max&amp;quot;: false,
            &amp;quot;min&amp;quot;: false,
            &amp;quot;show&amp;quot;: true,
            &amp;quot;total&amp;quot;: false,
            &amp;quot;values&amp;quot;: false
          },
          &amp;quot;lines&amp;quot;: true,
          &amp;quot;linewidth&amp;quot;: 1,
          &amp;quot;links&amp;quot;: [],
          &amp;quot;nullPointMode&amp;quot;: &amp;quot;null&amp;quot;,
          &amp;quot;percentage&amp;quot;: false,
          &amp;quot;pointradius&amp;quot;: 5,
          &amp;quot;points&amp;quot;: false,
          &amp;quot;renderer&amp;quot;: &amp;quot;flot&amp;quot;,
          &amp;quot;seriesOverrides&amp;quot;: [],
          &amp;quot;spaceLength&amp;quot;: 10,
          &amp;quot;span&amp;quot;: 6,
          &amp;quot;stack&amp;quot;: false,
          &amp;quot;steppedLine&amp;quot;: false,
          &amp;quot;targets&amp;quot;: [
            {
              &amp;quot;expr&amp;quot;: &amp;quot;(node_filesystem_size_bytes{fstype=~\&amp;quot;xfs|ext4\&amp;quot;} - node_filesystem_free_bytes) / node_filesystem_size_bytes&amp;quot;,
              &amp;quot;format&amp;quot;: &amp;quot;time_series&amp;quot;,
              &amp;quot;intervalFactor&amp;quot;: 2,
              &amp;quot;refId&amp;quot;: &amp;quot;A&amp;quot;
            }
          ],
          &amp;quot;thresholds&amp;quot;: [],
          &amp;quot;timeFrom&amp;quot;: &amp;quot;1h&amp;quot;,
          &amp;quot;timeShift&amp;quot;: null,
          &amp;quot;title&amp;quot;: &amp;quot;各节点磁盘使用率&amp;quot;,
          &amp;quot;tooltip&amp;quot;: {
            &amp;quot;shared&amp;quot;: true,
            &amp;quot;sort&amp;quot;: 0,
            &amp;quot;value_type&amp;quot;: &amp;quot;individual&amp;quot;
          },
          &amp;quot;transparent&amp;quot;: false,
          &amp;quot;type&amp;quot;: &amp;quot;graph&amp;quot;,
          &amp;quot;xaxis&amp;quot;: {
            &amp;quot;buckets&amp;quot;: null,
            &amp;quot;mode&amp;quot;: &amp;quot;time&amp;quot;,
            &amp;quot;name&amp;quot;: null,
            &amp;quot;show&amp;quot;: true,
            &amp;quot;values&amp;quot;: []
          },
          &amp;quot;yaxes&amp;quot;: [
            {
              &amp;quot;format&amp;quot;: &amp;quot;short&amp;quot;,
              &amp;quot;label&amp;quot;: null,
              &amp;quot;logBase&amp;quot;: 1,
              &amp;quot;max&amp;quot;: null,
              &amp;quot;min&amp;quot;: null,
              &amp;quot;show&amp;quot;: true
            },
            {
              &amp;quot;format&amp;quot;: &amp;quot;short&amp;quot;,
              &amp;quot;label&amp;quot;: null,
              &amp;quot;logBase&amp;quot;: 1,
              &amp;quot;max&amp;quot;: null,
              &amp;quot;min&amp;quot;: null,
              &amp;quot;show&amp;quot;: true
            }
          ]
        },
        {
          &amp;quot;aliasColors&amp;quot;: {},
          &amp;quot;bars&amp;quot;: false,
          &amp;quot;dashLength&amp;quot;: 10,
          &amp;quot;dashes&amp;quot;: false,
          &amp;quot;datasource&amp;quot;: &amp;quot;${DS_FAAS}&amp;quot;,
          &amp;quot;fill&amp;quot;: 1,
          &amp;quot;hideTimeOverride&amp;quot;: false,
          &amp;quot;id&amp;quot;: 1,
          &amp;quot;legend&amp;quot;: {
            &amp;quot;alignAsTable&amp;quot;: true,
            &amp;quot;avg&amp;quot;: false,
            &amp;quot;current&amp;quot;: false,
            &amp;quot;max&amp;quot;: false,
            &amp;quot;min&amp;quot;: false,
            &amp;quot;rightSide&amp;quot;: false,
            &amp;quot;show&amp;quot;: true,
            &amp;quot;total&amp;quot;: false,
            &amp;quot;values&amp;quot;: false
          },
          &amp;quot;lines&amp;quot;: true,
          &amp;quot;linewidth&amp;quot;: 1,
          &amp;quot;links&amp;quot;: [],
          &amp;quot;nullPointMode&amp;quot;: &amp;quot;null&amp;quot;,
          &amp;quot;percentage&amp;quot;: false,
          &amp;quot;pointradius&amp;quot;: 5,
          &amp;quot;points&amp;quot;: false,
          &amp;quot;renderer&amp;quot;: &amp;quot;flot&amp;quot;,
          &amp;quot;seriesOverrides&amp;quot;: [],
          &amp;quot;spaceLength&amp;quot;: 10,
          &amp;quot;span&amp;quot;: 6,
          &amp;quot;stack&amp;quot;: false,
          &amp;quot;steppedLine&amp;quot;: false,
          &amp;quot;targets&amp;quot;: [
            {
              &amp;quot;expr&amp;quot;: &amp;quot;(node_memory_MemTotal_bytes - node_memory_MemAvailable_bytes) / node_memory_MemTotal_bytes&amp;quot;,
              &amp;quot;format&amp;quot;: &amp;quot;time_series&amp;quot;,
              &amp;quot;intervalFactor&amp;quot;: 2,
              &amp;quot;refId&amp;quot;: &amp;quot;A&amp;quot;
            }
          ],
          &amp;quot;thresholds&amp;quot;: [],
          &amp;quot;timeFrom&amp;quot;: &amp;quot;1h&amp;quot;,
          &amp;quot;timeShift&amp;quot;: null,
          &amp;quot;title&amp;quot;: &amp;quot;各节点内存使用率&amp;quot;,
          &amp;quot;tooltip&amp;quot;: {
            &amp;quot;shared&amp;quot;: true,
            &amp;quot;sort&amp;quot;: 0,
            &amp;quot;value_type&amp;quot;: &amp;quot;individual&amp;quot;
          },
          &amp;quot;type&amp;quot;: &amp;quot;graph&amp;quot;,
          &amp;quot;xaxis&amp;quot;: {
            &amp;quot;buckets&amp;quot;: null,
            &amp;quot;mode&amp;quot;: &amp;quot;time&amp;quot;,
            &amp;quot;name&amp;quot;: null,
            &amp;quot;show&amp;quot;: true,
            &amp;quot;values&amp;quot;: []
          },
          &amp;quot;yaxes&amp;quot;: [
            {
              &amp;quot;format&amp;quot;: &amp;quot;short&amp;quot;,
              &amp;quot;label&amp;quot;: null,
              &amp;quot;logBase&amp;quot;: 1,
              &amp;quot;max&amp;quot;: null,
              &amp;quot;min&amp;quot;: null,
              &amp;quot;show&amp;quot;: true
            },
            {
              &amp;quot;format&amp;quot;: &amp;quot;short&amp;quot;,
              &amp;quot;label&amp;quot;: null,
              &amp;quot;logBase&amp;quot;: 1,
              &amp;quot;max&amp;quot;: null,
              &amp;quot;min&amp;quot;: null,
              &amp;quot;show&amp;quot;: true
            }
          ]
        }
      ],
      &amp;quot;repeat&amp;quot;: null,
      &amp;quot;repeatIteration&amp;quot;: null,
      &amp;quot;repeatRowId&amp;quot;: null,
      &amp;quot;showTitle&amp;quot;: false,
      &amp;quot;title&amp;quot;: &amp;quot;Dashboard Row&amp;quot;,
      &amp;quot;titleSize&amp;quot;: &amp;quot;h6&amp;quot;
    },
    {
      &amp;quot;collapse&amp;quot;: false,
      &amp;quot;height&amp;quot;: 278,
      &amp;quot;panels&amp;quot;: [
        {
          &amp;quot;aliasColors&amp;quot;: {},
          &amp;quot;bars&amp;quot;: false,
          &amp;quot;dashLength&amp;quot;: 10,
          &amp;quot;dashes&amp;quot;: false,
          &amp;quot;datasource&amp;quot;: &amp;quot;${DS_FAAS}&amp;quot;,
          &amp;quot;fill&amp;quot;: 1,
          &amp;quot;id&amp;quot;: 4,
          &amp;quot;legend&amp;quot;: {
            &amp;quot;alignAsTable&amp;quot;: true,
            &amp;quot;avg&amp;quot;: false,
            &amp;quot;current&amp;quot;: false,
            &amp;quot;max&amp;quot;: false,
            &amp;quot;min&amp;quot;: false,
            &amp;quot;show&amp;quot;: true,
            &amp;quot;total&amp;quot;: false,
            &amp;quot;values&amp;quot;: false
          },
          &amp;quot;lines&amp;quot;: true,
          &amp;quot;linewidth&amp;quot;: 2,
          &amp;quot;links&amp;quot;: [],
          &amp;quot;nullPointMode&amp;quot;: &amp;quot;null&amp;quot;,
          &amp;quot;percentage&amp;quot;: false,
          &amp;quot;pointradius&amp;quot;: 5,
          &amp;quot;points&amp;quot;: false,
          &amp;quot;renderer&amp;quot;: &amp;quot;flot&amp;quot;,
          &amp;quot;seriesOverrides&amp;quot;: [],
          &amp;quot;spaceLength&amp;quot;: 10,
          &amp;quot;span&amp;quot;: 6,
          &amp;quot;stack&amp;quot;: false,
          &amp;quot;steppedLine&amp;quot;: false,
          &amp;quot;targets&amp;quot;: [
            {
              &amp;quot;expr&amp;quot;: &amp;quot;irate(node_disk_read_bytes_total{}[5m]) / 1024 / 1024&amp;quot;,
              &amp;quot;format&amp;quot;: &amp;quot;time_series&amp;quot;,
              &amp;quot;intervalFactor&amp;quot;: 2,
              &amp;quot;refId&amp;quot;: &amp;quot;A&amp;quot;
            }
          ],
          &amp;quot;thresholds&amp;quot;: [],
          &amp;quot;timeFrom&amp;quot;: &amp;quot;1h&amp;quot;,
          &amp;quot;timeShift&amp;quot;: null,
          &amp;quot;title&amp;quot;: &amp;quot;各节点磁盘IO读速率(MiB/s)&amp;quot;,
          &amp;quot;tooltip&amp;quot;: {
            &amp;quot;shared&amp;quot;: true,
            &amp;quot;sort&amp;quot;: 0,
            &amp;quot;value_type&amp;quot;: &amp;quot;individual&amp;quot;
          },
          &amp;quot;type&amp;quot;: &amp;quot;graph&amp;quot;,
          &amp;quot;xaxis&amp;quot;: {
            &amp;quot;buckets&amp;quot;: null,
            &amp;quot;mode&amp;quot;: &amp;quot;time&amp;quot;,
            &amp;quot;name&amp;quot;: null,
            &amp;quot;show&amp;quot;: true,
            &amp;quot;values&amp;quot;: []
          },
          &amp;quot;yaxes&amp;quot;: [
            {
              &amp;quot;format&amp;quot;: &amp;quot;short&amp;quot;,
              &amp;quot;label&amp;quot;: null,
              &amp;quot;logBase&amp;quot;: 1,
              &amp;quot;max&amp;quot;: null,
              &amp;quot;min&amp;quot;: null,
              &amp;quot;show&amp;quot;: true
            },
            {
              &amp;quot;format&amp;quot;: &amp;quot;short&amp;quot;,
              &amp;quot;label&amp;quot;: null,
              &amp;quot;logBase&amp;quot;: 1,
              &amp;quot;max&amp;quot;: null,
              &amp;quot;min&amp;quot;: null,
              &amp;quot;show&amp;quot;: true
            }
          ]
        },
        {
          &amp;quot;aliasColors&amp;quot;: {},
          &amp;quot;bars&amp;quot;: false,
          &amp;quot;dashLength&amp;quot;: 10,
          &amp;quot;dashes&amp;quot;: false,
          &amp;quot;datasource&amp;quot;: &amp;quot;${DS_FAAS}&amp;quot;,
          &amp;quot;fill&amp;quot;: 1,
          &amp;quot;id&amp;quot;: 3,
          &amp;quot;legend&amp;quot;: {
            &amp;quot;alignAsTable&amp;quot;: true,
            &amp;quot;avg&amp;quot;: false,
            &amp;quot;current&amp;quot;: false,
            &amp;quot;max&amp;quot;: false,
            &amp;quot;min&amp;quot;: false,
            &amp;quot;show&amp;quot;: true,
            &amp;quot;total&amp;quot;: false,
            &amp;quot;values&amp;quot;: false
          },
          &amp;quot;lines&amp;quot;: true,
          &amp;quot;linewidth&amp;quot;: 1,
          &amp;quot;links&amp;quot;: [],
          &amp;quot;nullPointMode&amp;quot;: &amp;quot;null&amp;quot;,
          &amp;quot;percentage&amp;quot;: false,
          &amp;quot;pointradius&amp;quot;: 5,
          &amp;quot;points&amp;quot;: false,
          &amp;quot;renderer&amp;quot;: &amp;quot;flot&amp;quot;,
          &amp;quot;seriesOverrides&amp;quot;: [],
          &amp;quot;spaceLength&amp;quot;: 10,
          &amp;quot;span&amp;quot;: 6,
          &amp;quot;stack&amp;quot;: false,
          &amp;quot;steppedLine&amp;quot;: false,
          &amp;quot;targets&amp;quot;: [
            {
              &amp;quot;expr&amp;quot;: &amp;quot;irate(node_disk_written_bytes_total{}[5m]) / 1024 / 1024&amp;quot;,
              &amp;quot;format&amp;quot;: &amp;quot;time_series&amp;quot;,
              &amp;quot;intervalFactor&amp;quot;: 2,
              &amp;quot;refId&amp;quot;: &amp;quot;A&amp;quot;
            }
          ],
          &amp;quot;thresholds&amp;quot;: [],
          &amp;quot;timeFrom&amp;quot;: &amp;quot;1h&amp;quot;,
          &amp;quot;timeShift&amp;quot;: null,
          &amp;quot;title&amp;quot;: &amp;quot;各节点磁盘IO写速率(MiB/s)&amp;quot;,
          &amp;quot;tooltip&amp;quot;: {
            &amp;quot;shared&amp;quot;: true,
            &amp;quot;sort&amp;quot;: 0,
            &amp;quot;value_type&amp;quot;: &amp;quot;individual&amp;quot;
          },
          &amp;quot;type&amp;quot;: &amp;quot;graph&amp;quot;,
          &amp;quot;xaxis&amp;quot;: {
            &amp;quot;buckets&amp;quot;: null,
            &amp;quot;mode&amp;quot;: &amp;quot;time&amp;quot;,
            &amp;quot;name&amp;quot;: null,
            &amp;quot;show&amp;quot;: true,
            &amp;quot;values&amp;quot;: []
          },
          &amp;quot;yaxes&amp;quot;: [
            {
              &amp;quot;format&amp;quot;: &amp;quot;short&amp;quot;,
              &amp;quot;label&amp;quot;: null,
              &amp;quot;logBase&amp;quot;: 1,
              &amp;quot;max&amp;quot;: null,
              &amp;quot;min&amp;quot;: null,
              &amp;quot;show&amp;quot;: true
            },
            {
              &amp;quot;format&amp;quot;: &amp;quot;short&amp;quot;,
              &amp;quot;label&amp;quot;: null,
              &amp;quot;logBase&amp;quot;: 1,
              &amp;quot;max&amp;quot;: null,
              &amp;quot;min&amp;quot;: null,
              &amp;quot;show&amp;quot;: true
            }
          ]
        }
      ],
      &amp;quot;repeat&amp;quot;: null,
      &amp;quot;repeatIteration&amp;quot;: null,
      &amp;quot;repeatRowId&amp;quot;: null,
      &amp;quot;showTitle&amp;quot;: false,
      &amp;quot;title&amp;quot;: &amp;quot;Dashboard Row&amp;quot;,
      &amp;quot;titleSize&amp;quot;: &amp;quot;h6&amp;quot;
    },
    {
      &amp;quot;collapse&amp;quot;: false,
      &amp;quot;height&amp;quot;: 250,
      &amp;quot;panels&amp;quot;: [
        {
          &amp;quot;aliasColors&amp;quot;: {},
          &amp;quot;bars&amp;quot;: false,
          &amp;quot;dashLength&amp;quot;: 10,
          &amp;quot;dashes&amp;quot;: false,
          &amp;quot;datasource&amp;quot;: &amp;quot;${DS_FAAS}&amp;quot;,
          &amp;quot;fill&amp;quot;: 1,
          &amp;quot;id&amp;quot;: 6,
          &amp;quot;legend&amp;quot;: {
            &amp;quot;alignAsTable&amp;quot;: true,
            &amp;quot;avg&amp;quot;: false,
            &amp;quot;current&amp;quot;: false,
            &amp;quot;max&amp;quot;: false,
            &amp;quot;min&amp;quot;: false,
            &amp;quot;rightSide&amp;quot;: true,
            &amp;quot;show&amp;quot;: true,
            &amp;quot;total&amp;quot;: false,
            &amp;quot;values&amp;quot;: false
          },
          &amp;quot;lines&amp;quot;: true,
          &amp;quot;linewidth&amp;quot;: 1,
          &amp;quot;links&amp;quot;: [],
          &amp;quot;nullPointMode&amp;quot;: &amp;quot;null&amp;quot;,
          &amp;quot;percentage&amp;quot;: false,
          &amp;quot;pointradius&amp;quot;: 5,
          &amp;quot;points&amp;quot;: false,
          &amp;quot;renderer&amp;quot;: &amp;quot;flot&amp;quot;,
          &amp;quot;seriesOverrides&amp;quot;: [],
          &amp;quot;spaceLength&amp;quot;: 10,
          &amp;quot;span&amp;quot;: 12,
          &amp;quot;stack&amp;quot;: false,
          &amp;quot;steppedLine&amp;quot;: false,
          &amp;quot;targets&amp;quot;: [
            {
              &amp;quot;expr&amp;quot;: &amp;quot;irate(node_network_transmit_bytes_total{job=\&amp;quot;master_node_exporter_metrics\&amp;quot;}[5m]) / 1024 / 1024&amp;quot;,
              &amp;quot;format&amp;quot;: &amp;quot;time_series&amp;quot;,
              &amp;quot;intervalFactor&amp;quot;: 2,
              &amp;quot;refId&amp;quot;: &amp;quot;A&amp;quot;
            }
          ],
          &amp;quot;thresholds&amp;quot;: [],
          &amp;quot;timeFrom&amp;quot;: &amp;quot;1h&amp;quot;,
          &amp;quot;timeShift&amp;quot;: null,
          &amp;quot;title&amp;quot;: &amp;quot;Master 网络IO速率:出速率(MiB/s)&amp;quot;,
          &amp;quot;tooltip&amp;quot;: {
            &amp;quot;shared&amp;quot;: true,
            &amp;quot;sort&amp;quot;: 0,
            &amp;quot;value_type&amp;quot;: &amp;quot;individual&amp;quot;
          },
          &amp;quot;type&amp;quot;: &amp;quot;graph&amp;quot;,
          &amp;quot;xaxis&amp;quot;: {
            &amp;quot;buckets&amp;quot;: null,
            &amp;quot;mode&amp;quot;: &amp;quot;time&amp;quot;,
            &amp;quot;name&amp;quot;: null,
            &amp;quot;show&amp;quot;: true,
            &amp;quot;values&amp;quot;: []
          },
          &amp;quot;yaxes&amp;quot;: [
            {
              &amp;quot;format&amp;quot;: &amp;quot;short&amp;quot;,
              &amp;quot;label&amp;quot;: null,
              &amp;quot;logBase&amp;quot;: 1,
              &amp;quot;max&amp;quot;: null,
              &amp;quot;min&amp;quot;: null,
              &amp;quot;show&amp;quot;: true
            },
            {
              &amp;quot;format&amp;quot;: &amp;quot;short&amp;quot;,
              &amp;quot;label&amp;quot;: null,
              &amp;quot;logBase&amp;quot;: 1,
              &amp;quot;max&amp;quot;: null,
              &amp;quot;min&amp;quot;: null,
              &amp;quot;show&amp;quot;: true
            }
          ]
        }
      ],
      &amp;quot;repeat&amp;quot;: null,
      &amp;quot;repeatIteration&amp;quot;: null,
      &amp;quot;repeatRowId&amp;quot;: null,
      &amp;quot;showTitle&amp;quot;: false,
      &amp;quot;title&amp;quot;: &amp;quot;Dashboard Row&amp;quot;,
      &amp;quot;titleSize&amp;quot;: &amp;quot;h6&amp;quot;
    },
    {
      &amp;quot;collapse&amp;quot;: false,
      &amp;quot;height&amp;quot;: 250,
      &amp;quot;panels&amp;quot;: [
        {
          &amp;quot;aliasColors&amp;quot;: {},
          &amp;quot;bars&amp;quot;: false,
          &amp;quot;dashLength&amp;quot;: 10,
          &amp;quot;dashes&amp;quot;: false,
          &amp;quot;datasource&amp;quot;: &amp;quot;${DS_FAAS}&amp;quot;,
          &amp;quot;fill&amp;quot;: 1,
          &amp;quot;id&amp;quot;: 5,
          &amp;quot;legend&amp;quot;: {
            &amp;quot;alignAsTable&amp;quot;: true,
            &amp;quot;avg&amp;quot;: false,
            &amp;quot;current&amp;quot;: false,
            &amp;quot;max&amp;quot;: false,
            &amp;quot;min&amp;quot;: false,
            &amp;quot;rightSide&amp;quot;: true,
            &amp;quot;show&amp;quot;: true,
            &amp;quot;total&amp;quot;: false,
            &amp;quot;values&amp;quot;: false
          },
          &amp;quot;lines&amp;quot;: true,
          &amp;quot;linewidth&amp;quot;: 1,
          &amp;quot;links&amp;quot;: [],
          &amp;quot;nullPointMode&amp;quot;: &amp;quot;null&amp;quot;,
          &amp;quot;percentage&amp;quot;: false,
          &amp;quot;pointradius&amp;quot;: 5,
          &amp;quot;points&amp;quot;: false,
          &amp;quot;renderer&amp;quot;: &amp;quot;flot&amp;quot;,
          &amp;quot;seriesOverrides&amp;quot;: [],
          &amp;quot;spaceLength&amp;quot;: 10,
          &amp;quot;span&amp;quot;: 12,
          &amp;quot;stack&amp;quot;: false,
          &amp;quot;steppedLine&amp;quot;: false,
          &amp;quot;targets&amp;quot;: [
            {
              &amp;quot;expr&amp;quot;: &amp;quot;irate(node_network_receive_bytes_total{job=\&amp;quot;master_node_exporter_metrics\&amp;quot;}[5m]) / 1024 / 1024&amp;quot;,
              &amp;quot;format&amp;quot;: &amp;quot;time_series&amp;quot;,
              &amp;quot;intervalFactor&amp;quot;: 2,
              &amp;quot;refId&amp;quot;: &amp;quot;A&amp;quot;
            }
          ],
          &amp;quot;thresholds&amp;quot;: [],
          &amp;quot;timeFrom&amp;quot;: &amp;quot;1h&amp;quot;,
          &amp;quot;timeShift&amp;quot;: null,
          &amp;quot;title&amp;quot;: &amp;quot;Master 网络IO速率:入速率(MiB/s)&amp;quot;,
          &amp;quot;tooltip&amp;quot;: {
            &amp;quot;shared&amp;quot;: true,
            &amp;quot;sort&amp;quot;: 0,
            &amp;quot;value_type&amp;quot;: &amp;quot;individual&amp;quot;
          },
          &amp;quot;type&amp;quot;: &amp;quot;graph&amp;quot;,
          &amp;quot;xaxis&amp;quot;: {
            &amp;quot;buckets&amp;quot;: null,
            &amp;quot;mode&amp;quot;: &amp;quot;time&amp;quot;,
            &amp;quot;name&amp;quot;: null,
            &amp;quot;show&amp;quot;: true,
            &amp;quot;values&amp;quot;: []
          },
          &amp;quot;yaxes&amp;quot;: [
            {
              &amp;quot;format&amp;quot;: &amp;quot;short&amp;quot;,
              &amp;quot;label&amp;quot;: null,
              &amp;quot;logBase&amp;quot;: 1,
              &amp;quot;max&amp;quot;: null,
              &amp;quot;min&amp;quot;: null,
              &amp;quot;show&amp;quot;: true
            },
            {
              &amp;quot;format&amp;quot;: &amp;quot;short&amp;quot;,
              &amp;quot;label&amp;quot;: null,
              &amp;quot;logBase&amp;quot;: 1,
              &amp;quot;max&amp;quot;: null,
              &amp;quot;min&amp;quot;: null,
              &amp;quot;show&amp;quot;: true
            }
          ]
        }
      ],
      &amp;quot;repeat&amp;quot;: null,
      &amp;quot;repeatIteration&amp;quot;: null,
      &amp;quot;repeatRowId&amp;quot;: null,
      &amp;quot;showTitle&amp;quot;: false,
      &amp;quot;title&amp;quot;: &amp;quot;Dashboard Row&amp;quot;,
      &amp;quot;titleSize&amp;quot;: &amp;quot;h6&amp;quot;
    },
    {
      &amp;quot;collapse&amp;quot;: false,
      &amp;quot;height&amp;quot;: 250,
      &amp;quot;panels&amp;quot;: [
        {
          &amp;quot;aliasColors&amp;quot;: {},
          &amp;quot;bars&amp;quot;: false,
          &amp;quot;dashLength&amp;quot;: 10,
          &amp;quot;dashes&amp;quot;: false,
          &amp;quot;datasource&amp;quot;: &amp;quot;${DS_FAAS}&amp;quot;,
          &amp;quot;fill&amp;quot;: 1,
          &amp;quot;id&amp;quot;: 7,
          &amp;quot;legend&amp;quot;: {
            &amp;quot;alignAsTable&amp;quot;: true,
            &amp;quot;avg&amp;quot;: false,
            &amp;quot;current&amp;quot;: false,
            &amp;quot;max&amp;quot;: false,
            &amp;quot;min&amp;quot;: false,
            &amp;quot;rightSide&amp;quot;: true,
            &amp;quot;show&amp;quot;: true,
            &amp;quot;total&amp;quot;: false,
            &amp;quot;values&amp;quot;: false
          },
          &amp;quot;lines&amp;quot;: true,
          &amp;quot;linewidth&amp;quot;: 1,
          &amp;quot;links&amp;quot;: [],
          &amp;quot;nullPointMode&amp;quot;: &amp;quot;null&amp;quot;,
          &amp;quot;percentage&amp;quot;: false,
          &amp;quot;pointradius&amp;quot;: 5,
          &amp;quot;points&amp;quot;: false,
          &amp;quot;renderer&amp;quot;: &amp;quot;flot&amp;quot;,
          &amp;quot;seriesOverrides&amp;quot;: [],
          &amp;quot;spaceLength&amp;quot;: 10,
          &amp;quot;span&amp;quot;: 12,
          &amp;quot;stack&amp;quot;: false,
          &amp;quot;steppedLine&amp;quot;: false,
          &amp;quot;targets&amp;quot;: [
            {
              &amp;quot;expr&amp;quot;: &amp;quot;irate(node_network_receive_bytes_total{job=\&amp;quot;slave-0001_node_exporter_metrics\&amp;quot;}[5m]) / 1024 / 1024&amp;quot;,
              &amp;quot;format&amp;quot;: &amp;quot;time_series&amp;quot;,
              &amp;quot;intervalFactor&amp;quot;: 2,
              &amp;quot;refId&amp;quot;: &amp;quot;A&amp;quot;
            }
          ],
          &amp;quot;thresholds&amp;quot;: [],
          &amp;quot;timeFrom&amp;quot;: &amp;quot;1h&amp;quot;,
          &amp;quot;timeShift&amp;quot;: null,
          &amp;quot;title&amp;quot;: &amp;quot;Slave-0001 网络IO速率:入速率(MiB/s)&amp;quot;,
          &amp;quot;tooltip&amp;quot;: {
            &amp;quot;shared&amp;quot;: true,
            &amp;quot;sort&amp;quot;: 0,
            &amp;quot;value_type&amp;quot;: &amp;quot;individual&amp;quot;
          },
          &amp;quot;type&amp;quot;: &amp;quot;graph&amp;quot;,
          &amp;quot;xaxis&amp;quot;: {
            &amp;quot;buckets&amp;quot;: null,
            &amp;quot;mode&amp;quot;: &amp;quot;time&amp;quot;,
            &amp;quot;name&amp;quot;: null,
            &amp;quot;show&amp;quot;: true,
            &amp;quot;values&amp;quot;: []
          },
          &amp;quot;yaxes&amp;quot;: [
            {
              &amp;quot;format&amp;quot;: &amp;quot;short&amp;quot;,
              &amp;quot;label&amp;quot;: null,
              &amp;quot;logBase&amp;quot;: 1,
              &amp;quot;max&amp;quot;: null,
              &amp;quot;min&amp;quot;: null,
              &amp;quot;show&amp;quot;: true
            },
            {
              &amp;quot;format&amp;quot;: &amp;quot;short&amp;quot;,
              &amp;quot;label&amp;quot;: null,
              &amp;quot;logBase&amp;quot;: 1,
              &amp;quot;max&amp;quot;: null,
              &amp;quot;min&amp;quot;: null,
              &amp;quot;show&amp;quot;: true
            }
          ]
        }
      ],
      &amp;quot;repeat&amp;quot;: null,
      &amp;quot;repeatIteration&amp;quot;: null,
      &amp;quot;repeatRowId&amp;quot;: null,
      &amp;quot;showTitle&amp;quot;: false,
      &amp;quot;title&amp;quot;: &amp;quot;Dashboard Row&amp;quot;,
      &amp;quot;titleSize&amp;quot;: &amp;quot;h6&amp;quot;
    },
    {
      &amp;quot;collapse&amp;quot;: false,
      &amp;quot;height&amp;quot;: 250,
      &amp;quot;panels&amp;quot;: [
        {
          &amp;quot;aliasColors&amp;quot;: {},
          &amp;quot;bars&amp;quot;: false,
          &amp;quot;dashLength&amp;quot;: 10,
          &amp;quot;dashes&amp;quot;: false,
          &amp;quot;datasource&amp;quot;: &amp;quot;${DS_FAAS}&amp;quot;,
          &amp;quot;fill&amp;quot;: 1,
          &amp;quot;id&amp;quot;: 8,
          &amp;quot;legend&amp;quot;: {
            &amp;quot;alignAsTable&amp;quot;: true,
            &amp;quot;avg&amp;quot;: false,
            &amp;quot;current&amp;quot;: false,
            &amp;quot;max&amp;quot;: false,
            &amp;quot;min&amp;quot;: false,
            &amp;quot;rightSide&amp;quot;: true,
            &amp;quot;show&amp;quot;: true,
            &amp;quot;total&amp;quot;: false,
            &amp;quot;values&amp;quot;: false
          },
          &amp;quot;lines&amp;quot;: true,
          &amp;quot;linewidth&amp;quot;: 1,
          &amp;quot;links&amp;quot;: [],
          &amp;quot;nullPointMode&amp;quot;: &amp;quot;null&amp;quot;,
          &amp;quot;percentage&amp;quot;: false,
          &amp;quot;pointradius&amp;quot;: 5,
          &amp;quot;points&amp;quot;: false,
          &amp;quot;renderer&amp;quot;: &amp;quot;flot&amp;quot;,
          &amp;quot;seriesOverrides&amp;quot;: [],
          &amp;quot;spaceLength&amp;quot;: 10,
          &amp;quot;span&amp;quot;: 12,
          &amp;quot;stack&amp;quot;: false,
          &amp;quot;steppedLine&amp;quot;: false,
          &amp;quot;targets&amp;quot;: [
            {
              &amp;quot;expr&amp;quot;: &amp;quot;irate(node_network_transmit_bytes_total{job=\&amp;quot;slave-0001_node_exporter_metrics\&amp;quot;}[5m]) / 1024 / 1024&amp;quot;,
              &amp;quot;format&amp;quot;: &amp;quot;time_series&amp;quot;,
              &amp;quot;intervalFactor&amp;quot;: 2,
              &amp;quot;refId&amp;quot;: &amp;quot;A&amp;quot;
            }
          ],
          &amp;quot;thresholds&amp;quot;: [],
          &amp;quot;timeFrom&amp;quot;: &amp;quot;1h&amp;quot;,
          &amp;quot;timeShift&amp;quot;: null,
          &amp;quot;title&amp;quot;: &amp;quot;Slave-0001 网络IO速率:出速率(MiB/s)&amp;quot;,
          &amp;quot;tooltip&amp;quot;: {
            &amp;quot;shared&amp;quot;: true,
            &amp;quot;sort&amp;quot;: 0,
            &amp;quot;value_type&amp;quot;: &amp;quot;individual&amp;quot;
          },
          &amp;quot;type&amp;quot;: &amp;quot;graph&amp;quot;,
          &amp;quot;xaxis&amp;quot;: {
            &amp;quot;buckets&amp;quot;: null,
            &amp;quot;mode&amp;quot;: &amp;quot;time&amp;quot;,
            &amp;quot;name&amp;quot;: null,
            &amp;quot;show&amp;quot;: true,
            &amp;quot;values&amp;quot;: []
          },
          &amp;quot;yaxes&amp;quot;: [
            {
              &amp;quot;format&amp;quot;: &amp;quot;short&amp;quot;,
              &amp;quot;label&amp;quot;: null,
              &amp;quot;logBase&amp;quot;: 1,
              &amp;quot;max&amp;quot;: null,
              &amp;quot;min&amp;quot;: null,
              &amp;quot;show&amp;quot;: true
            },
            {
              &amp;quot;format&amp;quot;: &amp;quot;short&amp;quot;,
              &amp;quot;label&amp;quot;: null,
              &amp;quot;logBase&amp;quot;: 1,
              &amp;quot;max&amp;quot;: null,
              &amp;quot;min&amp;quot;: null,
              &amp;quot;show&amp;quot;: true
            }
          ]
        }
      ],
      &amp;quot;repeat&amp;quot;: null,
      &amp;quot;repeatIteration&amp;quot;: null,
      &amp;quot;repeatRowId&amp;quot;: null,
      &amp;quot;showTitle&amp;quot;: false,
      &amp;quot;title&amp;quot;: &amp;quot;Dashboard Row&amp;quot;,
      &amp;quot;titleSize&amp;quot;: &amp;quot;h6&amp;quot;
    },
    {
      &amp;quot;collapse&amp;quot;: false,
      &amp;quot;height&amp;quot;: 250,
      &amp;quot;panels&amp;quot;: [
        {
          &amp;quot;aliasColors&amp;quot;: {},
          &amp;quot;bars&amp;quot;: false,
          &amp;quot;dashLength&amp;quot;: 10,
          &amp;quot;dashes&amp;quot;: false,
          &amp;quot;datasource&amp;quot;: &amp;quot;${DS_FAAS}&amp;quot;,
          &amp;quot;fill&amp;quot;: 1,
          &amp;quot;id&amp;quot;: 9,
          &amp;quot;legend&amp;quot;: {
            &amp;quot;alignAsTable&amp;quot;: true,
            &amp;quot;avg&amp;quot;: false,
            &amp;quot;current&amp;quot;: false,
            &amp;quot;max&amp;quot;: false,
            &amp;quot;min&amp;quot;: false,
            &amp;quot;rightSide&amp;quot;: true,
            &amp;quot;show&amp;quot;: true,
            &amp;quot;total&amp;quot;: false,
            &amp;quot;values&amp;quot;: false
          },
          &amp;quot;lines&amp;quot;: true,
          &amp;quot;linewidth&amp;quot;: 1,
          &amp;quot;links&amp;quot;: [],
          &amp;quot;nullPointMode&amp;quot;: &amp;quot;null&amp;quot;,
          &amp;quot;percentage&amp;quot;: false,
          &amp;quot;pointradius&amp;quot;: 5,
          &amp;quot;points&amp;quot;: false,
          &amp;quot;renderer&amp;quot;: &amp;quot;flot&amp;quot;,
          &amp;quot;seriesOverrides&amp;quot;: [],
          &amp;quot;spaceLength&amp;quot;: 10,
          &amp;quot;span&amp;quot;: 12,
          &amp;quot;stack&amp;quot;: false,
          &amp;quot;steppedLine&amp;quot;: false,
          &amp;quot;targets&amp;quot;: [
            {
              &amp;quot;expr&amp;quot;: &amp;quot;irate(node_network_receive_bytes_total{job=\&amp;quot;slave-0002_node_exporter_metrics\&amp;quot;}[5m]) / 1024 / 1024&amp;quot;,
              &amp;quot;format&amp;quot;: &amp;quot;time_series&amp;quot;,
              &amp;quot;intervalFactor&amp;quot;: 2,
              &amp;quot;refId&amp;quot;: &amp;quot;A&amp;quot;
            }
          ],
          &amp;quot;thresholds&amp;quot;: [],
          &amp;quot;timeFrom&amp;quot;: &amp;quot;1h&amp;quot;,
          &amp;quot;timeShift&amp;quot;: null,
          &amp;quot;title&amp;quot;: &amp;quot;Slave-0002 网络IO速率:入速率(MiB/s)&amp;quot;,
          &amp;quot;tooltip&amp;quot;: {
            &amp;quot;shared&amp;quot;: true,
            &amp;quot;sort&amp;quot;: 0,
            &amp;quot;value_type&amp;quot;: &amp;quot;individual&amp;quot;
          },
          &amp;quot;type&amp;quot;: &amp;quot;graph&amp;quot;,
          &amp;quot;xaxis&amp;quot;: {
            &amp;quot;buckets&amp;quot;: null,
            &amp;quot;mode&amp;quot;: &amp;quot;time&amp;quot;,
            &amp;quot;name&amp;quot;: null,
            &amp;quot;show&amp;quot;: true,
            &amp;quot;values&amp;quot;: []
          },
          &amp;quot;yaxes&amp;quot;: [
            {
              &amp;quot;format&amp;quot;: &amp;quot;short&amp;quot;,
              &amp;quot;label&amp;quot;: null,
              &amp;quot;logBase&amp;quot;: 1,
              &amp;quot;max&amp;quot;: null,
              &amp;quot;min&amp;quot;: null,
              &amp;quot;show&amp;quot;: true
            },
            {
              &amp;quot;format&amp;quot;: &amp;quot;short&amp;quot;,
              &amp;quot;label&amp;quot;: null,
              &amp;quot;logBase&amp;quot;: 1,
              &amp;quot;max&amp;quot;: null,
              &amp;quot;min&amp;quot;: null,
              &amp;quot;show&amp;quot;: true
            }
          ]
        }
      ],
      &amp;quot;repeat&amp;quot;: null,
      &amp;quot;repeatIteration&amp;quot;: null,
      &amp;quot;repeatRowId&amp;quot;: null,
      &amp;quot;showTitle&amp;quot;: false,
      &amp;quot;title&amp;quot;: &amp;quot;Dashboard Row&amp;quot;,
      &amp;quot;titleSize&amp;quot;: &amp;quot;h6&amp;quot;
    },
    {
      &amp;quot;collapse&amp;quot;: false,
      &amp;quot;height&amp;quot;: 250,
      &amp;quot;panels&amp;quot;: [
        {
          &amp;quot;aliasColors&amp;quot;: {},
          &amp;quot;bars&amp;quot;: false,
          &amp;quot;dashLength&amp;quot;: 10,
          &amp;quot;dashes&amp;quot;: false,
          &amp;quot;datasource&amp;quot;: &amp;quot;${DS_FAAS}&amp;quot;,
          &amp;quot;fill&amp;quot;: 1,
          &amp;quot;id&amp;quot;: 10,
          &amp;quot;legend&amp;quot;: {
            &amp;quot;alignAsTable&amp;quot;: true,
            &amp;quot;avg&amp;quot;: false,
            &amp;quot;current&amp;quot;: false,
            &amp;quot;max&amp;quot;: false,
            &amp;quot;min&amp;quot;: false,
            &amp;quot;rightSide&amp;quot;: true,
            &amp;quot;show&amp;quot;: true,
            &amp;quot;total&amp;quot;: false,
            &amp;quot;values&amp;quot;: false
          },
          &amp;quot;lines&amp;quot;: true,
          &amp;quot;linewidth&amp;quot;: 1,
          &amp;quot;links&amp;quot;: [],
          &amp;quot;nullPointMode&amp;quot;: &amp;quot;null&amp;quot;,
          &amp;quot;percentage&amp;quot;: false,
          &amp;quot;pointradius&amp;quot;: 5,
          &amp;quot;points&amp;quot;: false,
          &amp;quot;renderer&amp;quot;: &amp;quot;flot&amp;quot;,
          &amp;quot;seriesOverrides&amp;quot;: [],
          &amp;quot;spaceLength&amp;quot;: 10,
          &amp;quot;span&amp;quot;: 12,
          &amp;quot;stack&amp;quot;: false,
          &amp;quot;steppedLine&amp;quot;: false,
          &amp;quot;targets&amp;quot;: [
            {
              &amp;quot;expr&amp;quot;: &amp;quot;irate(node_network_transmit_bytes_total{job=\&amp;quot;slave-0002_node_exporter_metrics\&amp;quot;}[5m]) / 1024 / 1024&amp;quot;,
              &amp;quot;format&amp;quot;: &amp;quot;time_series&amp;quot;,
              &amp;quot;intervalFactor&amp;quot;: 2,
              &amp;quot;refId&amp;quot;: &amp;quot;A&amp;quot;
            }
          ],
          &amp;quot;thresholds&amp;quot;: [],
          &amp;quot;timeFrom&amp;quot;: &amp;quot;1h&amp;quot;,
          &amp;quot;timeShift&amp;quot;: null,
          &amp;quot;title&amp;quot;: &amp;quot;Slave-0002 网络IO速率:出速率(MiB/s)&amp;quot;,
          &amp;quot;tooltip&amp;quot;: {
            &amp;quot;shared&amp;quot;: true,
            &amp;quot;sort&amp;quot;: 0,
            &amp;quot;value_type&amp;quot;: &amp;quot;individual&amp;quot;
          },
          &amp;quot;type&amp;quot;: &amp;quot;graph&amp;quot;,
          &amp;quot;xaxis&amp;quot;: {
            &amp;quot;buckets&amp;quot;: null,
            &amp;quot;mode&amp;quot;: &amp;quot;time&amp;quot;,
            &amp;quot;name&amp;quot;: null,
            &amp;quot;show&amp;quot;: true,
            &amp;quot;values&amp;quot;: []
          },
          &amp;quot;yaxes&amp;quot;: [
            {
              &amp;quot;format&amp;quot;: &amp;quot;short&amp;quot;,
              &amp;quot;label&amp;quot;: null,
              &amp;quot;logBase&amp;quot;: 1,
              &amp;quot;max&amp;quot;: null,
              &amp;quot;min&amp;quot;: null,
              &amp;quot;show&amp;quot;: true
            },
            {
              &amp;quot;format&amp;quot;: &amp;quot;short&amp;quot;,
              &amp;quot;label&amp;quot;: null,
              &amp;quot;logBase&amp;quot;: 1,
              &amp;quot;max&amp;quot;: null,
              &amp;quot;min&amp;quot;: null,
              &amp;quot;show&amp;quot;: true
            }
          ]
        }
      ],
      &amp;quot;repeat&amp;quot;: null,
      &amp;quot;repeatIteration&amp;quot;: null,
      &amp;quot;repeatRowId&amp;quot;: null,
      &amp;quot;showTitle&amp;quot;: false,
      &amp;quot;title&amp;quot;: &amp;quot;Dashboard Row&amp;quot;,
      &amp;quot;titleSize&amp;quot;: &amp;quot;h6&amp;quot;
    },
    {
      &amp;quot;collapse&amp;quot;: false,
      &amp;quot;height&amp;quot;: 250,
      &amp;quot;panels&amp;quot;: [],
      &amp;quot;repeat&amp;quot;: null,
      &amp;quot;repeatIteration&amp;quot;: null,
      &amp;quot;repeatRowId&amp;quot;: null,
      &amp;quot;showTitle&amp;quot;: false,
      &amp;quot;title&amp;quot;: &amp;quot;Dashboard Row&amp;quot;,
      &amp;quot;titleSize&amp;quot;: &amp;quot;h6&amp;quot;
    },
    {
      &amp;quot;collapse&amp;quot;: false,
      &amp;quot;height&amp;quot;: 250,
      &amp;quot;panels&amp;quot;: [],
      &amp;quot;repeat&amp;quot;: null,
      &amp;quot;repeatIteration&amp;quot;: null,
      &amp;quot;repeatRowId&amp;quot;: null,
      &amp;quot;showTitle&amp;quot;: false,
      &amp;quot;title&amp;quot;: &amp;quot;Dashboard Row&amp;quot;,
      &amp;quot;titleSize&amp;quot;: &amp;quot;h6&amp;quot;
    },
    {
      &amp;quot;collapse&amp;quot;: false,
      &amp;quot;height&amp;quot;: 250,
      &amp;quot;panels&amp;quot;: [],
      &amp;quot;repeat&amp;quot;: null,
      &amp;quot;repeatIteration&amp;quot;: null,
      &amp;quot;repeatRowId&amp;quot;: null,
      &amp;quot;showTitle&amp;quot;: false,
      &amp;quot;title&amp;quot;: &amp;quot;Dashboard Row&amp;quot;,
      &amp;quot;titleSize&amp;quot;: &amp;quot;h6&amp;quot;
    }
  ],
  &amp;quot;schemaVersion&amp;quot;: 14,
  &amp;quot;style&amp;quot;: &amp;quot;dark&amp;quot;,
  &amp;quot;tags&amp;quot;: [],
  &amp;quot;templating&amp;quot;: {
    &amp;quot;list&amp;quot;: []
  },
  &amp;quot;time&amp;quot;: {
    &amp;quot;from&amp;quot;: &amp;quot;now-6h&amp;quot;,
    &amp;quot;to&amp;quot;: &amp;quot;now&amp;quot;
  },
  &amp;quot;timepicker&amp;quot;: {
    &amp;quot;refresh_intervals&amp;quot;: [
      &amp;quot;5s&amp;quot;,
      &amp;quot;10s&amp;quot;,
      &amp;quot;30s&amp;quot;,
      &amp;quot;1m&amp;quot;,
      &amp;quot;5m&amp;quot;,
      &amp;quot;15m&amp;quot;,
      &amp;quot;30m&amp;quot;,
      &amp;quot;1h&amp;quot;,
      &amp;quot;2h&amp;quot;,
      &amp;quot;1d&amp;quot;
    ],
    &amp;quot;time_options&amp;quot;: [
      &amp;quot;5m&amp;quot;,
      &amp;quot;15m&amp;quot;,
      &amp;quot;1h&amp;quot;,
      &amp;quot;6h&amp;quot;,
      &amp;quot;12h&amp;quot;,
      &amp;quot;24h&amp;quot;,
      &amp;quot;2d&amp;quot;,
      &amp;quot;7d&amp;quot;,
      &amp;quot;30d&amp;quot;
    ]
  },
  &amp;quot;timezone&amp;quot;: &amp;quot;&amp;quot;,
  &amp;quot;title&amp;quot;: &amp;quot;Kubernetes&amp;quot;,
  &amp;quot;version&amp;quot;: 7
}
&lt;/code&gt;&lt;/pre&gt;
">2021.04.27：Grafana监控平台部署（对于K8s集群各节点）</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://Czardas42.github.io/post/20210426_kubernetes/"" data-c="
          &lt;p&gt;🤡🤡🤡🤡🤡🤡&lt;/p&gt;
&lt;h3 id=&#34;1-error-kubeletversionthe-kubelet-version-is-higher-than-the-control-plane-version-this-is-not-a-supportted-version-skew-and-may-lead-to-a-malfunctional-cluster&#34;&gt;1. 【ERROR KubeletVersion】：the kubelet version is higher than the control plane version. This is not a supportted version skew and may lead to a malfunctional cluster.&lt;/h3&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://Czardas42.github.io//post-images/1619426268228.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;版本不匹配的问题，需要重新安装 kubelet kubeadm kubectl(与Kubernetes版本一致)&lt;/p&gt;
&lt;p&gt;Kubernetes版本：&lt;br&gt;
&lt;img src=&#34;https://Czardas42.github.io//post-images/1619426325673.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;【解决方法】&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;yum -y remove kubelet kubeadm kubectl
yum -y install kubelet-1.20.5 kubeadm-1.20.5 kubectl-1.20.5
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;【参考】&lt;br&gt;
&lt;a href=&#34;https://www.cnblogs.com/siren27/p/10211920.html&#34;&gt;https://www.cnblogs.com/siren27/p/10211920.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;&lt;br/&gt;&lt;/p&gt;
&lt;h3 id=&#34;2-解决安装k8s时flannel镜像拉取失败的问题&#34;&gt;2. 解决安装K8S时flannel镜像拉取失败的问题&lt;/h3&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;2&#34;&gt;&lt;img src=&#34;https://Czardas42.github.io//post-images/1619425933210.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;&lt;strong&gt;【解决方法】&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;curl -O https://raw.githubusercontent.com/coreos/flannel/master/Documentation/kube-flannel.yml
sed -i &#39;s/quay.io\/coreos/registry.cn-beijing.aliyuncs.com\/imcto/g&#39; kube-flannel.yml
docker pull registry.cn-hangzhou.aliyuncs.com/k8sos/flannel:v0.13.1-rc2
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;vim kube-flannel.yml
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;修改kube-flannel.yml将里面使用的官方镜像的名字改为自己拉取的镜像名称&lt;/strong&gt;&lt;br&gt;
即：image: registry.cn-hangzhou.aliyuncs.com/k8sos/flannel:v0.13.1-rc2&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;安装flannel&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;kubectl apply -f kube-flannel.yml
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;【参考】&lt;br&gt;
&lt;a href=&#34;https://blog.csdn.net/telundusiji/article/details/114033799&#34;&gt;https://blog.csdn.net/telundusiji/article/details/114033799&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;&lt;br/&gt;&lt;/p&gt;
&lt;h3 id=&#34;3-unable-to-connect-to-the-server-x509-certificate-signed-by-unknown-authority&#34;&gt;3. Unable to connect to the server: x509: certificate signed by unknown authority&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;【解决方法】&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;原因在于&lt;code&gt;kubeadm init&lt;/code&gt;命令之后的执行三条命令：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;mkdir -p $HOME/.kube
sudo cp -i /etc/kubernetes/admin.conf $HOME/.kube/config
sudo chown $(id -u):$(id -g) $HOME/.kube/config
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这几个命令会创建一个目录，并复制几个配置文件，重新创建集群时，&lt;strong&gt;这个目录还是存在的&lt;/strong&gt;，需要在执行这几个命令前先执行&lt;code&gt;rm -rf $HOME/.kube&lt;/code&gt;命令删除这个目录，最后解决了这个问题&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;正确操作：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;kubeadm reset
rm -rf $HOME/.kube
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;然后再进行init：&lt;/strong&gt;&lt;br&gt;
&lt;code&gt;kubeadm init --config kubeadm.yaml --ignore-preflight-errors=Swap&lt;/code&gt;&lt;br&gt;
或者&lt;br&gt;
&lt;code&gt;kubeadm init --kubernetes-version=v1.20.5 --pod-network-cidr=10.244.0.0/16 --service-cidr=10.96.0.0/12 --ignore-preflight-errors=Swap&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;【参考】&lt;br&gt;
&lt;a href=&#34;https://blog.csdn.net/woay2008/article/details/93250137&#34;&gt;https://blog.csdn.net/woay2008/article/details/93250137&lt;/a&gt;&lt;br&gt;
&lt;a href=&#34;https://blog.csdn.net/curry10086/article/details/107579113?utm_medium=distribute.pc_relevant.none-task-blog-baidujs_title-0&amp;amp;spm=1001.2101.3001.4242&#34;&gt;https://blog.csdn.net/curry10086/article/details/107579113?utm_medium=distribute.pc_relevant.none-task-blog-baidujs_title-0&amp;amp;spm=1001.2101.3001.4242&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;&lt;br/&gt;&lt;/p&gt;
">2021.04.26：Kubernetes安装踩坑记录</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://Czardas42.github.io/post/at_first/"" data-c="
          &lt;h1 id=&#34;have-a-try&#34;&gt;have a try😀😀😀&lt;/h1&gt;
">写在最前面</a>
      </div>
      
    </div>
    <div class="page">
      <div id="page_ul"></div>
    </div>
  </div>
</div>
<script>
  !function () {
    let searchMask = document.querySelector('#search_mask');
    let result = document.querySelector('#result');
    let items = document.querySelectorAll('.item');
    let searchBox = document.querySelector('#search');
    let statCount = document.querySelector('#stat_count');
    let statTimes = document.querySelector('#stat_times');
    let pageUl = document.querySelector('#page_ul');
    let close = document.querySelector('#close');
    
    close.addEventListener('click', function() {
      searchMask.style = 'display: none;'
    })

    let finds = [];
    let contents = [];
    let pageSize = 10;
    items.forEach(item => {
      let a = item.querySelector('a');
      contents.push({
        title: a.innerText,
        details: a.dataset.c,
        link: a.href
      })
      item.remove();
    })

    function insertStr(soure, start, count) {
      let newStr = soure.substr(start, count);
      return soure.slice(0, start) + '<em>' + newStr + '</em>' + soure.slice(start + count);
    }

    pageUl.addEventListener('click', function(event) {
      let target = event.target;
      if (target.__proto__ === HTMLSpanElement.prototype) {
        appendResults(parseInt(target.dataset.i));
      }
    })

    function appendResults(index) {
      let htmlResult = '';
      let start = index || 0;
      let end = Math.min(start + pageSize, finds.length);
      for (let i = start; i < end; i++) {
        const current = finds[i];
        let html = current.title;
        let sum = 0;
        let positions = current.positions;
        positions.forEach(position => {
          html = insertStr(html, position.start + sum, position.count);
          sum += 9;
        })
        htmlResult += `<div class="item"><a class="result-title" href="${current.link}">${html}</a></div>`;
      }
      result.innerHTML = htmlResult;
      pageUl.innerHTML = '';
      let count = finds.length / pageSize;
      let lis = '';
      if (start !== 0) {
        lis += `<span class="fa fa-angle-left" data-i='${start - 1}'></span>`;
      }
      for (let i = 0; i < count; i++) {
        lis += `<span class='${i === start?'current':''}' data-i='${i}'>${i+1}</span>`;     
      }
      if (start+1 < count) {
        lis += `<span class="fa fa-angle-right" data-i='${start+1}'></span>`;  
      }
      pageUl.innerHTML = lis;
    }

    function search(delay) {
      let timer = null
      return function () {
        clearTimeout(timer)
        timer = setTimeout(() => {
          let start = Date.now();
          let segments = searchBox.value.split(' ').filter(c => c != '');
          if (segments.length <= 0) {
            return;
          }
          finds = [];
          let htmlResult = '';
          contents.forEach(content => {
            let title = content.title;
            let positions = [];
            let find = false;
            segments.forEach((segment) => {
              if (content.title.includes(segment)) {
                find = true;
                positions.push({
                  start: content.title.indexOf(segment),
                  count: segment.length
                })
              } else if (content.details.includes(segment)) {
                find = true;
              }
            });
            if (find) {
              finds.push({
                title: content.title,
                link: content.link,
                positions
              });
            }
          })
          appendResults(0);
          statCount.textContent = finds.length;
          statTimes.textContent = Date.now() - start;
        }, delay)
      }
    }
    searchBox.addEventListener('input', search(200));
  }()
</script>

<input hidden id="copy" />
<script>
  !function () {
    let times = document.querySelectorAll('.publish-time');
    for (let i = 0; i < times.length; i++) {
      let date = times[i].dataset.t;
      let time = Math.floor((new Date().getTime() - new Date(date).getTime()) / 1000);
      if (time < 60) {
        str = time + '秒之前';
      } else if (time < 3600) {
        str = Math.floor(time / 60) + '分钟之前';
      } else if (time >= 3600 && time < 86400) {
        str = Math.floor(time / 3600) + '小时之前';
      } else if (time >= 86400 && time < 259200) {
        str = Math.floor(time / 86400) + '天之前';
      } else {
        str = times[i].textContent;
      }
      times[i].textContent = str;
    }
  }();
</script>

<script>
  let language = '';
  if (language !== '') {
    let map = new Map();
    if (language === 'en') {
      map.set('search', 'Search');
      map.set('category', 'Categories');
      map.set('article', 'Articles');
      map.set('tag', 'Tags');
      map.set('top', 'Top');
      map.set('publish', 'published');
      map.set('minute', ' minutes');
      map.set('read-more', 'Read More');
      map.set('view', 'View');
      map.set('words', ' words');
      map.set('category-in', 'category in');
      map.set('preview', 'Meta');
      map.set('index', 'Toc');
      map.set('no-archives', "You haven't created yet");
      map.set('archives', " articles in total");
      map.set('cloud-tags', " tags in total");
      map.set('copyright', "Copyright: ");
      map.set('author', "Author: ");
      map.set('link', "Link: ");
      map.set('leave-message', "Leave a message");
      map.set('format', "Links Format");
      map.set('site-name', "Name: ");
      map.set('site-link', "Link: ");
      map.set('site-desc', "Desc: ");
      map.set('stat', " related results, taking ");
      map.set('stat-time', " ms");
      map.set('site-img', "Image: ");
    }

    if (map.size > 0) {
      let lanElems = document.querySelectorAll('.language');
      lanElems.forEach(elem => {
        let lan = elem.dataset.lan, text = map.get(lan);
        if (elem.__proto__ === HTMLInputElement.prototype) {
          elem.placeholder = text
        } else {
          if (elem.dataset.count) {
            text = elem.dataset.count + text;
          }
          elem.textContent = text;
        }
      })
    }
  }
  //拿来主义(真香)^_^，Clipboard 实现摘自掘金 https://juejin.im/post/5aefeb6e6fb9a07aa43c20af
  window.Clipboard = (function (window, document, navigator) {
    var textArea,
      copy;

    // 判断是不是ios端
    function isOS() {
      return navigator.userAgent.match(/ipad|iphone/i);
    }
    //创建文本元素
    function createTextArea(text) {
      textArea = document.createElement('textArea');
      textArea.value = text;
      textArea.style.width = 0;
      textArea.style.height = 0;
      textArea.clientHeight = 0;
      textArea.clientWidth = 0;
      document.body.appendChild(textArea);
    }
    //选择内容
    function selectText() {
      var range,
        selection;

      if (isOS()) {
        range = document.createRange();
        range.selectNodeContents(textArea);
        selection = window.getSelection();
        selection.removeAllRanges();
        selection.addRange(range);
        textArea.setSelectionRange(0, 999999);
      } else {
        textArea.select();
      }
    }

    //复制到剪贴板
    function copyToClipboard() {
      try {
        document.execCommand("Copy")
      } catch (err) {
        alert("复制错误！请手动复制！")
      }
      document.body.removeChild(textArea);
    }

    copy = function (text) {
      createTextArea(text);
      selectText();
      copyToClipboard();
    };

    return {
      copy: copy
    };
  })(window, document, navigator);

  function copyCode(e) {
    if (e.srcElement.tagName === 'SPAN' && e.srcElement.classList.contains('copy-code')) {
      let code = e.currentTarget.querySelector('code');
      var text = code.innerText;
      if (e.srcElement.textContent === '复制成功') {
        return;
      }
      e.srcElement.textContent = '复制成功';
      (function (elem) {
        setTimeout(() => {
          if (elem.textContent === '复制成功') {
            elem.textContent = '复制代码'
          }
        }, 1000);
      })(e.srcElement)
      Clipboard.copy(text);
    }
  }

  let pres = document.querySelectorAll('pre');
  pres.forEach(pre => {
    let code = pre.querySelector('code');
    let copyElem = document.createElement('span');
    copyElem.classList.add('copy-code');
    copyElem.textContent = '复制代码';
    pre.appendChild(copyElem);
    pre.onclick = copyCode
  })

</script>
<script src="/media/js/motion.js"></script>


<script src="https://cdn.jsdelivr.net/gh/cferdinandi/smooth-scroll/dist/smooth-scroll.polyfills.min.js"></script>
<script>
  var scroll = new SmoothScroll('a[href*="#"]', {
    speed: 200
  });
</script>





</html>