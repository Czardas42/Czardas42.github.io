<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://Czardas42.github.io/</id>
    <title>Czardas</title>
    <updated>2021-05-06T12:00:21.396Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://Czardas42.github.io/"/>
    <link rel="self" href="https://Czardas42.github.io/atom.xml"/>
    <subtitle>世界那么大，我想去看看</subtitle>
    <logo>https://Czardas42.github.io/images/avatar.png</logo>
    <icon>https://Czardas42.github.io/favicon.ico</icon>
    <rights>All rights reserved 2021, Czardas</rights>
    <entry>
        <title type="html"><![CDATA[Prometheus]]></title>
        <id>https://Czardas42.github.io/post/prometheus/</id>
        <link href="https://Czardas42.github.io/post/prometheus/">
        </link>
        <updated>2021-05-06T11:59:16.000Z</updated>
        <content type="html"><![CDATA[<h4 id="集群监控策略">集群监控策略：</h4>
<p>Prometheus监控Kubernetes集群监控的各个维度以及策略：</p>
<table>
<thead>
<tr>
<th>目标</th>
<th>服务发现模式</th>
<th><strong>监控方法</strong></th>
<th><strong>数据源</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>从集群各节点kubelet组件中获取节点kubelet的基本运行状态的监控指标</td>
<td>node</td>
<td>白盒监控</td>
<td>kubelet</td>
</tr>
<tr>
<td>从集群各节点kubelet内置的cAdvisor中获取，节点中运行的容器的监控指标</td>
<td>node</td>
<td>白盒监控</td>
<td>kubelet</td>
</tr>
<tr>
<td><strong>从部署到各个节点的Node Exporter中采集主机资源相关的运行资源</strong>（本次实验使用方法）</td>
<td><strong>node</strong></td>
<td><strong>白盒监控</strong></td>
<td><strong>node exporter</strong></td>
</tr>
<tr>
<td>对于内置了Promthues支持的应用，需要从Pod实例中采集其自定义监控指标</td>
<td>pod</td>
<td>白盒监控</td>
<td>custom pod</td>
</tr>
<tr>
<td>获取API Server组件的访问地址，并从中获取Kubernetes集群相关的运行监控指标</td>
<td>endpoints</td>
<td>白盒监控</td>
<td>api server</td>
</tr>
<tr>
<td>获取集群中Service<u>的访问地址</u>，并通过Blackbox Exporter获取网络探测指标</td>
<td>service</td>
<td>黑盒监控</td>
<td>blackbox exporter</td>
</tr>
<tr>
<td>获取集群中Ingress的访问信息，并通过Blackbox Exporter获取网络探测指标</td>
<td>ingress</td>
<td>黑盒监控</td>
<td>blackbox exporter</td>
</tr>
</tbody>
</table>
<h4 id="prometheus部署">Prometheus部署</h4>
<p><u><em>详细说一说，因为直接动了系统自带的配置文件</em></u></p>
<h4 id="node-exporter部署">Node Exporter部署</h4>
<h5 id="方法">方法：</h5>
<ol>
<li>
<p>创建自定义的Node Exporter服务，然后将服务器配置为Prometheus上的Target（本次实验使用方法）</p>
<p>【参考】<a href="https://devopscube.com/monitor-linux-servers-prometheus-node-exporter/">https://devopscube.com/monitor-linux-servers-prometheus-node-exporter/</a></p>
</li>
<li>
<p>还可以使用Daemonset控制器部署Node Exporter</p>
<p>为了能够采集集群中各个节点的资源使用情况，需要在各节点中部署一个Node Exporter实例。在部署Prometheus时，我们使用了Kubernetes内置的控制器之一Deployment。Deployment能够确保Prometheus的Pod能够按照预期的状态在集群中运行，而Pod实例可能随机运行在任意节点上。</p>
<p>而与Prometheus的部署不同的是，<strong>对于Node Exporter而言每个节点只需要运行一个唯一的实例</strong>，所以需要使用Kubernetes的另外一种控制器Daemonset。Daemonset的管理方式类似于操作系统中的守护进程。Daemonset会确保在集群中所有（也可以指定）节点上运行一个唯一的Pod实例。</p>
</li>
</ol>
<h5 id="daemonset-与-deployment-的区别">DaemonSet 与 Deployment 的区别</h5>
<ul>
<li><strong>Deployment</strong> 部署的副本 <strong>Pod</strong> 会分布在各个 <strong>Node</strong> 上，每个 <strong>Node</strong> 都可能运行好几个副本。</li>
<li><strong>DaemonSet</strong> 的不同之处在于：每个 <strong>Node</strong> 上最多只能运行一个副本。</li>
</ul>
<h5 id="daemonset-的典型应用场景">DaemonSet 的典型应用场景</h5>
<ul>
<li>在集群的每个节点上运行存储 <strong>Daemon</strong>，比如：<strong>glusterd</strong> 或 <strong>ceph</strong>。</li>
<li>在每个节点上运行日志收集 <strong>Daemon</strong>，比如：<strong>flunentd</strong> 或 <strong>logstash</strong>。</li>
<li>在每个节点上运行监控 <strong>Daemon</strong>，比如：<strong>Prometheus Node Exporter</strong> 或 <strong>collectd</strong>。</li>
</ul>
<h5 id="查看k8s-的-daemonset">查看k8s 的 DaemonSet</h5>
<p><strong>Kubernetes</strong> 自己就在用 <strong>DaemonSet</strong> 运行系统组件。执行如下命令查看：</p>
<p><code>kubectl get daemonset --``namespace``=kube-system</code></p>
<p><em><u>(配一张截图)</u></em></p>
<h4 id="promql概念应用实例">PromQL概念&amp;应用实例</h4>
<h5 id="概念">概念</h5>
<p>Prometheus通过指标名称（metrics name）以及对应的一组标签（labelset）唯一定义一条时间序列。指标名称反映了监控样本的基本标识，而label则在这个基本特征上为采集到的数据提供了多种特征维度。用户可以基于这些特征维度过滤，聚合，统计从而产生新的计算后的一条时间序列。</p>
<h5 id="应用实例">应用实例</h5>
<ol>
<li>各节点磁盘使用率</li>
</ol>
<p><code>node_filesystem_size_bytes{fstype=~\&quot;xfs|ext4\&quot;} - node_filesystem_free_bytes) / node_filesystem_size_bytes</code></p>
<ol start="2">
<li>各节点内存使用率</li>
</ol>
<p><code>node_memory_MemTotal_bytes - node_memory_MemAvailable_bytes) / node_memory_MemTotal_bytes</code></p>
<ol start="3">
<li>各节点磁盘IO读速率(MiB/s)</li>
</ol>
<p><code>irate(node_disk_read_bytes_total{}[5m]) / 1024 / 1024</code></p>
<ol start="4">
<li>各节点磁盘IO写速率(MiB/s)</li>
</ol>
<p><code>irate(node_disk_written_bytes_total{}[5m]) / 1024 / 1024</code></p>
<ol start="5">
<li>某节点网络IO速率:入速率(MiB/s)</li>
</ol>
<p><code>irate(node_network_receive_bytes_total{job=\&quot;节点名称_node_exporter_metrics\&quot;}[5m]) / 1024 / 1024</code></p>
<ol start="6">
<li>某节点网络IO速率:出速率(MiB/s)</li>
</ol>
<p><code>irate(node_network_transmit_bytes_total{job=\&quot;节点名称_node_exporter_metrics\&quot;}[5m]) / 1024 / 1024</code></p>
<ol start="7">
<li><strong>某节点CPU使用率</strong></li>
</ol>
<p><code>100 - (avg by(instance) (irate(node_cpu_seconds_total{mode=\&quot;idle\&quot;, job=\&quot;节点名称_node_exporter_metrics\&quot;}[5m])) * 100)</code></p>
<p><strong>CPU使用率的计算公式：</strong></p>
<ol>
<li>
<p>CPU0在5分钟内处于空闲状态的时间：<code>increase(node_cpu_seconds_total{cpu=&quot;0&quot;,mode=&quot;idle&quot;}[5m])</code>，increase 的意思是表示增量，刚才说了 <code>node_cpu_seconds_total</code>是单调递增的，这个公式的结果是当前时点的 <code>node_cpu_seconds_total</code> 减去5分钟之前的 <code>node_cpu_seconds_total</code>，也就是这5分钟之内处于<code>idle</code>状态的 CPU时间。</p>
</li>
<li>
<p>CPU0在5分钟内处于空闲状态的时间占比：<code>increase(node_cpu_seconds_total{cpu=&quot;0&quot;,mode=&quot;idle&quot;}[5m]) / increase(node_cpu_seconds_total{cpu=&quot;0&quot;}[5m])</code>，分母其实就是5分钟=300秒。</p>
</li>
<li>
<p>一台主机所有CPU在5分钟内处于空闲状态的时间占比</p>
<p>用 <code>sum()</code>函数累加各核数值：</p>
<p><code>sum (increase(node_cpu_seconds_total{mode=&quot;idle&quot;}[5m])) / sum (increase(node_cpu_seconds_total{mode=&quot;idle&quot;}[5m]))</code></p>
</li>
<li>
<p>如果 Prometheus 监控多台主机，要根据每台主机做 sum：</p>
<p><code>sum by (instance)(increase(node_cpu_seconds_total{mode=&quot;idle&quot;}[5m])) / sum by (instance)(increase(node_cpu_seconds_total[5m]))</code></p>
</li>
<li>
<p>CPU使用率 = 1 - CPU空闲率：</p>
<p><code>100 * (1 - sum by (instance)(increase(node_cpu_seconds_total{mode=&quot;idle&quot;}[5m])) / sum by (instance)(increase(node_cpu_seconds_total[5m])))</code></p>
</li>
<li>
<p>PromQL 有计算比率的函数：<code>rate()</code> 和 <code>irate()</code>，可以简化计算公式为:</p>
<p><strong><code>100 - (avg by(instance) (irate(node_cpu_seconds_total{mode=&quot;idle&quot;}[5m])) * 100)</code></strong></p>
</li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Chapter6数学问题：6.3质数]]></title>
        <id>https://Czardas42.github.io/post/chapter6_6.3/</id>
        <link href="https://Czardas42.github.io/post/chapter6_6.3/">
        </link>
        <updated>2021-05-05T07:52:58.000Z</updated>
        <content type="html"><![CDATA[<h2 id="判断记录质数的方法">判断/记录质数的方法</h2>
<ol>
<li><code>sqrt(n)</code></li>
<li>素数筛法</li>
</ol>
<h2 id="1-素数判定">1.  素数判定</h2>
<h3 id="题目描述"><strong>题目描述</strong></h3>
<p>给定一个数n，要求判断其是否为素数（0,1，负数都是非素数）。</p>
<h3 id="要点"><strong>要点</strong></h3>
<p>对于负数、0、1要特别处理</p>
<h3 id="提交地址">提交地址</h3>
<p><a href="https://www.nowcoder.com/practice/5fd9c28b1ce746dd99287a04d8fa9002?tpId=40&amp;qru=%2Fta%2Ftsing-kaoyan%2Fquestion-ranking&amp;tab=answerKey">https://www.nowcoder.com/practice/5fd9c28b1ce746dd99287a04d8fa9002?tpId=40&amp;qru=%2Fta%2Ftsing-kaoyan%2Fquestion-ranking&amp;tab=answerKey</a></p>
<h3 id="代码">代码</h3>
<pre><code class="language-c++">#include &lt;iostream&gt;
#include &lt;cstdio&gt;
#include &lt;cmath&gt;
using namespace std;

int main()
{
    int num;
    while (cin &gt;&gt; num)
    {
        if (num&lt;=1)
        {
            cout &lt;&lt; &quot;no&quot; &lt;&lt; endl;
            continue;
        }
        
        bool flag = true;
        for (int i=num-1; i&gt;=sqrt(num); i--)
        {
            if (num % i ==0)
            {
                flag = false;
                break;
            }
        }
        
        if (flag == true)
        {
            cout &lt;&lt; &quot;yes&quot; &lt;&lt; endl;
        }
        else
        {
            cout &lt;&lt; &quot;no&quot; &lt;&lt; endl;
        }
    }
}
</code></pre>
<h2 id="2-素数">2.  素数</h2>
<h3 id="题目描述-2"><strong>题目描述</strong></h3>
<p>输入一个整数n(2&lt;=n&lt;=10000)，要求输出所有从1到这个整数之间(不包括1和这个整数)个位为1的素数，如果没有则输出-1。</p>
<h3 id="要点-2"><strong>要点</strong></h3>
<p>方法一：穷举</p>
<p><strong>方法二【素数筛法】：找到一个素数，就要标记其所有倍数为非负数无需再针对每个数字进行判断</strong></p>
<p><strong>（实际操作中，只需从平方开始标记即可）</strong></p>
<h3 id="提交地址-2">提交地址</h3>
<p><a href="https://www.nowcoder.com/practice/7f4be54b37a04fdaa4ee545819151114?tpId=40&amp;qru=%2Fta%2Ftsing-kaoyan%2Fquestion-ranking&amp;tab=answerKey">https://www.nowcoder.com/practice/7f4be54b37a04fdaa4ee545819151114?tpId=40&amp;qru=%2Fta%2Ftsing-kaoyan%2Fquestion-ranking&amp;tab=answerKey</a></p>
<h3 id="代码穷举">代码（穷举）</h3>
<pre><code class="language-c++">#include &lt;iostream&gt;
#include &lt;cstdio&gt;
#include &lt;cmath&gt;

using namespace std;

int main()
{
    int range;
    while (cin &gt;&gt; range)
    {
        if (range &lt;= 11)
        {
            cout &lt;&lt; &quot;-1&quot; &lt;&lt; endl;
            continue;
        }
        
        for (int num =11; num&lt;range; num++)
        {
            bool flag = true;
            for (int i=num-1; i&gt;=sqrt(num); i--)
            {
                if (num % i == 0)
                {
                    flag = false;
                    break;
                }
            }
            
            if ((flag == true) &amp;&amp; (num%10 == 1))
            {
                if (num == 11)
                    cout &lt;&lt; num;
                else
                    cout &lt;&lt; &quot; &quot; &lt;&lt; num ;
            }
        }
        cout &lt;&lt; endl;
    }
    
    return 0;
}
</code></pre>
<h3 id="代码素数筛法">代码（素数筛法）</h3>
<pre><code class="language-c++">#include &lt;iostream&gt;
#include &lt;cstdio&gt;
#include &lt;cmath&gt;
#include &lt;vector&gt;

using namespace std;

int main()
{
    int range;
    while (cin &gt;&gt; range)
    {
        if (range &lt;=11)
        {
            cout &lt;&lt; &quot;-1\n&quot;;
            break;
        }
        
        bool num[10000];
        vector&lt;int&gt; prime;
        //初始化
        num[0] = false;
        num[1] = false;
        for (int i=2; i&lt;10000; i++)
            num[i] = true;
        
        for (int temp=2; temp&lt;range; temp++)
        {           
            if (num[temp] == true)
            {
                prime.push_back(temp);//加入素数组
                //标记之后temp的倍数不是素数
                for (int j=temp*temp; j&lt;range; j=j+temp)
                    num[j] = false;
            }
        }
        
        //输出
        for (int i=0; i&lt;prime.size(); i++)
        {
            if(prime[i] % 10 == 1)
            {
                if (prime[i] == 11)
                    cout &lt;&lt; prime[i];
                else                
                    cout &lt;&lt; &quot; &quot; &lt;&lt; prime[i];
            }
        }
        cout &lt;&lt; endl;        
    }
    
    return 0;
}
</code></pre>
<h2 id="3-prime-number">3.  Prime Number</h2>
<h3 id="题目描述-3"><strong>题目描述</strong></h3>
<p>Output the k-th prime number.</p>
<h3 id="要点-3"><strong>要点</strong></h3>
<ol>
<li>素数筛法</li>
<li>提前存好10000个素数：范围开到1000000就够用，或者可以记录素数个数</li>
<li><strong>适当可以使用void函数，让main函数看起来更加简洁</strong></li>
</ol>
<h3 id="提交地址-3">提交地址</h3>
<p><a href="https://www.nowcoder.com/practice/c5f8688cea8a4a9a88edbd67d1358415?tpId=40&amp;qru=%2Fta%2Ftsing-kaoyan%2Fquestion-ranking&amp;tab=answerKey">https://www.nowcoder.com/practice/c5f8688cea8a4a9a88edbd67d1358415?tpId=40&amp;qru=%2Fta%2Ftsing-kaoyan%2Fquestion-ranking&amp;tab=answerKey</a></p>
<pre><code class="language-c++">#include &lt;iostream&gt;
#include &lt;cstdio&gt;
#include &lt;vector&gt;

using namespace std;

int order;
vector&lt;int&gt; prime;
const int range = 1000000;

void Initial()
{
    bool num[range];
    for (int i=0; i&lt;range; i++)
        num[i] = true;
    num[0] = false;
    num[1] = false;
    
    for (int temp=0; temp&lt;range; temp++)
    {
        if (num[temp] == true)
        {
            prime.push_back(temp);
            
            for (int j=temp*temp; j&lt;range; j=j+temp)
                num[j] = false;
        }
    }
};

int main()
{
    Initial();      
    while (cin &gt;&gt; order)
    {
        cout &lt;&lt; prime[order-1] &lt;&lt; endl;
    }
    return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Chapter6数学问题：6.2 最大公约数和最小公倍数]]></title>
        <id>https://Czardas42.github.io/post/chapter6_6.2/</id>
        <link href="https://Czardas42.github.io/post/chapter6_6.2/">
        </link>
        <updated>2021-05-05T07:51:36.000Z</updated>
        <content type="html"><![CDATA[<h2 id="辗转相除法">辗转相除法</h2>
<h2 id="1-最大公约数">1.  最大公约数</h2>
<h3 id="题目描述"><strong>题目描述</strong></h3>
<p>输入两个正整数，求其最大公约数。</p>
<h3 id="要点"><strong>要点</strong></h3>
<p>递归实现辗转相除法GCD</p>
<h3 id="提交地址">提交地址</h3>
<p><a href="https://www.nowcoder.com/practice/20216f2c84bc438eb5ef05e382536fd3?tpId=40&amp;qru=%2Fta%2Ftsing-kaoyan%2Fquestion-ranking&amp;tab=answerKey">https://www.nowcoder.com/practice/20216f2c84bc438eb5ef05e382536fd3?tpId=40&amp;qru=%2Fta%2Ftsing-kaoyan%2Fquestion-ranking&amp;tab=answerKey</a></p>
<h3 id="代码">代码</h3>
<pre><code class="language-c++">#include &lt;iostream&gt;
#include &lt;cstdio&gt;

using namespace std;

int GCD(int a, int b)
{
    if(a%b == 0) //a可以整除b：b是最大公约数
    {
        return b;
    }
    else
    {
        return GCD(b, a%b);
    }
}

int main()
{
    int num1, num2;
    while(cin &gt;&gt; num1 &gt;&gt; num2)
    {
        cout &lt;&lt; GCD(num1, num2) &lt;&lt; endl;
    }
    
    return 0;
}
</code></pre>
<h2 id="2-最小公倍数">2.  最小公倍数</h2>
<h3 id="题目描述-2"><strong>题目描述</strong></h3>
<p>输入两个正整数，求其最小公约数。</p>
<h3 id="要点-2"><strong>要点</strong></h3>
<ol>
<li>
<p><strong>最小公倍数 = 两数乘积 / 最大公约数</strong></p>
</li>
<li>
<p>递归实现辗转相除法</p>
</li>
</ol>
<h3 id="提交地址-2">提交地址</h3>
<p><a href="https://www.nowcoder.com/practice/22948c2cad484e0291350abad86136c3?tpId=37&amp;qru=%2Fta%2Ftsing-kaoyan%2Fquestion-ranking&amp;tab=answerKey">https://www.nowcoder.com/practice/22948c2cad484e0291350abad86136c3?tpId=37&amp;qru=%2Fta%2Ftsing-kaoyan%2Fquestion-ranking&amp;tab=answerKey</a></p>
<h3 id="代码-2">代码</h3>
<pre><code class="language-c++">#include &lt;iostream&gt;
#include &lt;cstdio&gt;

using namespace std;

int GCD(int a, int b)
{
    if(a%b == 0)
    {
        return b;
    }
    else
    {
        return GCD(b, a%b);
    }
}

int main()
{
    int num1, num2;
    while (cin &gt;&gt; num1 &gt;&gt; num2)
    {
        int temp = num1 * num2;
        int result = temp / GCD(num1, num2);
        cout &lt;&lt; result &lt;&lt; endl;
    }
}
</code></pre>
<h2 id="3-最简真分数">3.  最简真分数</h2>
<h3 id="题目描述-3"><strong>题目描述</strong></h3>
<p>给出n个正整数，任取两个数分别作为分子和分母组成最简真分数，编程求共有几个这样的组合。</p>
<h3 id="要点-3"><strong>要点</strong></h3>
<ol>
<li>
<p><strong>最简真分数：分子&lt;分母；分子分母最大公约数为1</strong></p>
</li>
<li>
<p>因为真分数的要求，最终结果/2</p>
</li>
</ol>
<h3 id="提交地址-3">提交地址</h3>
<p><a href="https://www.nowcoder.com/practice/1f1db273eeb745c6ac83e91ff14d2ec9?tpId=40&amp;qru=%2Fta%2Ftsing-kaoyan%2Fquestion-ranking&amp;tab=answerKey">https://www.nowcoder.com/practice/1f1db273eeb745c6ac83e91ff14d2ec9?tpId=40&amp;qru=%2Fta%2Ftsing-kaoyan%2Fquestion-ranking&amp;tab=answerKey</a></p>
<h3 id="代码-3">代码</h3>
<pre><code class="language-c++">#include &lt;iostream&gt;
#include &lt;cstdio&gt;
#include &lt;vector&gt;

using namespace std;

int GCD(int a, int b)
{
    if(a%b == 0)
        return b;
    else
        return GCD(b, a%b);
};

int main()
{
    int count;
    while(cin &gt;&gt; count)
    {
        if (count == 0)
            break;
        //存入数据
        vector&lt;int&gt; number;
        int num;
        for (int i=0; i&lt;count; i++)
        {
            cin &gt;&gt; num;
            number.push_back(num);
        }
        //遍历
        int result = 0;
        for (int i=0; i&lt;number.size(); i++)
        {
            for (int j=0; j&lt;number.size(); j++)
            {
                int temp = GCD(number[i], number[j]);
                if (temp==1)
                {//两数最大公约数是1
                    result++;
                }
            }
        }
        cout &lt;&lt; result/2 &lt;&lt; endl;  //真分数&lt;1,所以结果/2         
    }
    
    return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Chapter6数学问题：6.1 进制转换]]></title>
        <id>https://Czardas42.github.io/post/chapter6_6.1/</id>
        <link href="https://Czardas42.github.io/post/chapter6_6.1/">
        </link>
        <updated>2021-05-05T07:48:49.000Z</updated>
        <content type="html"><![CDATA[<h2 id="进制转换原理">进制转换原理</h2>
<h2 id="1-二进制数">1.  二进制数</h2>
<h3 id="题目描述"><strong>题目描述</strong></h3>
<p>大家都知道，数据在计算机里中存储是以二进制的形式存储的。 有一天，小明学了C语言之后，他想知道一个类型为unsigned int 类型的数字，存储在计算机中的二进制串是什么样子的。 你能帮帮小明吗？并且，小明不想要二进制串中前面的没有意义的0串，即要去掉前导0。</p>
<h3 id="要点"><strong>要点</strong></h3>
<ol>
<li>进制转换标准公式</li>
<li>以及while循环判断条件<code>while (num != 0)</code></li>
</ol>
<h3 id="提交地址">提交地址</h3>
<p><a href="https://www.nowcoder.com/practice/103dd589fed14457a673c613d8de3841?tpId=40&amp;qru=%2Fta%2Ftsing-kaoyan%2Fquestion-ranking&amp;tab=answerKey">https://www.nowcoder.com/practice/103dd589fed14457a673c613d8de3841?tpId=40&amp;qru=%2Fta%2Ftsing-kaoyan%2Fquestion-ranking&amp;tab=answerKey</a></p>
<h3 id="代码">代码</h3>
<pre><code class="language-c++">#include &lt;iostream&gt;
#include &lt;cstdio&gt;
#include &lt;string&gt;

using namespace std;

int main()
{
    int num;
    while (cin &gt;&gt; num)
    {
        string result = &quot;&quot;;
        
        while (num != 0)
        {
            int temp = num % 2;
            char num_now = char('0'+temp);
            result = num_now + result;
            num = num / 2;
        }
        
        cout  &lt;&lt; result &lt;&lt; endl;
    }
}
</code></pre>
<h2 id="2-进制转换">2. <strong>进制转换</strong></h2>
<h3 id="题目描述-2"><strong>题目描述</strong></h3>
<p>将一个长度最多为30位数字的十进制非负整数转换为二进制数输出。</p>
<h3 id="要点-2"><strong>要点</strong></h3>
<ol>
<li>
<p>数字长度：https://www.runoob.com/cplusplus/cpp-data-types.html</p>
<table>
<thead>
<tr>
<th>unsigned long int</th>
<th>0 到 18,446,744,073,709,551,615（20位）</th>
</tr>
</thead>
<tbody></tbody>
</table>
<p><strong>超过20位的数字运算就只能通过字符串实现</strong></p>
</li>
<li>
<p>字符串类型计算乘除法的方法：模仿手动计算</p>
</li>
<li>
<p><strong>从第一个非0位开始输出：</strong></p>
<p>设置flag，在第一次遇到非0时将其变为true；</p>
<p>提前获得非0位的编号</p>
</li>
</ol>
<h3 id="提交地址-2">提交地址</h3>
<p><a href="https://www.nowcoder.com/practice/53447aa04f32460aa20ee11d02416e3b?tpId=40&amp;qru=%2Fta%2Ftsing-kaoyan%2Fquestion-ranking&amp;tab=answerKey">https://www.nowcoder.com/practice/53447aa04f32460aa20ee11d02416e3b?tpId=40&amp;qru=%2Fta%2Ftsing-kaoyan%2Fquestion-ranking&amp;tab=answerKey</a></p>
<h3 id="代码-2">代码</h3>
<pre><code class="language-c++">#include &lt;iostream&gt;
#include &lt;cstdio&gt;
#include &lt;string&gt;

using namespace std;

char GetTemp(string num)//取得字符串num的%2结果
{   //num%2结果 = num最后一位%2的结果
    int temp0 = int(num[num.size()-1] - '0') % 2;
    char temp = char(temp0 + '0');
    return temp;
};

string GetNum(string num)//取得字符串num的/2结果
{
    int m = 0;
    string result = num;
    for (int i=0; i&lt;num.size(); i++)
    {   //模仿手动计算除法的过程
        int num_now = int(num[i] - '0') + m*10;
        result[i] = char(num_now / 2 + '0');
        m = num_now % 2;
    }
    
    return result;
};

int main()
{
    string num;
    while (cin &gt;&gt; num)
    {
        string result = &quot;&quot;;
        
        //flag：和num位数相同的全零串
        string flag = num;
        for (int i=0; i&lt;flag.size(); i++)
            flag[i] = '0';
        
        while(num != flag)
        {
            result = GetTemp(num) + result;
            num = GetNum(num);
        }

        //输出：从首个非零位开始
        bool flag2 = false;
        for (int j=0; j&lt;result.size(); j++)
        {
            if (result[j] != '0')
                flag2 = true;
            
            if (flag2 == true)
                cout &lt;&lt; result[j];
        }
        cout &lt;&lt; endl;        
    }
}
</code></pre>
<h2 id="3-十进制vs二进制">3. <strong>十进制VS二进制</strong></h2>
<h3 id="题目描述-3"><strong>题目描述</strong></h3>
<p>对于一个十进制数A，将A转换为二进制数，然后按位逆序排列，再转换为十进制数B，我们称B为A的二进制逆序数。   例如对于十进制数173，它的二进制形式为10101101，逆序排列得到10110101，其十进制数为181，181即为173的二进制逆序数。</p>
<p><strong>注意：一个1000位(即10^999)以内的十进制数。</strong></p>
<h3 id="要点-3"><strong>要点</strong></h3>
<ol>
<li>
<p><strong>法一：字符串类型的加法，乘法，除法，取余</strong></p>
</li>
<li>
<p><strong>法二：大数进制转换</strong></p>
<p>参考：<a href="https://blog.csdn.net/StrongerL/article/details/92702052">https://blog.csdn.net/StrongerL/article/details/92702052</a></p>
</li>
</ol>
<h3 id="提交地址-3">提交地址</h3>
<p><a href="https://www.nowcoder.com/practice/53447aa04f32460aa20ee11d02416e3b?tpId=40&amp;qru=%2Fta%2Ftsing-kaoyan%2Fquestion-ranking&amp;tab=answerKey">https://www.nowcoder.com/practice/53447aa04f32460aa20ee11d02416e3b?tpId=40&amp;qru=%2Fta%2Ftsing-kaoyan%2Fquestion-ranking&amp;tab=answerKey</a></p>
<h3 id="代码-3">代码</h3>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Chapter5数据结构一：5.3 栈]]></title>
        <id>https://Czardas42.github.io/post/chapter5-5.3/</id>
        <link href="https://Czardas42.github.io/post/chapter5-5.3/">
        </link>
        <updated>2021-05-05T07:45:56.000Z</updated>
        <content type="html"><![CDATA[<h2 id="栈的基本操作">栈的基本操作</h2>
<p>只能在栈顶进行操作</p>
<p>重点用于处理逆序问题</p>
<h2 id="1-zero-complexity-transposition逆序输出">1.  Zero-complexity Transposition（逆序输出）</h2>
<h3 id="题目描述"><strong>题目描述</strong></h3>
<p>You are given a sequence of integer numbers. Zero-complexity transposition of the sequence is the reverse of this sequence. Your task is to write a program that prints zero-complexity transposition of the given sequence.</p>
<h3 id="要点"><strong>要点</strong></h3>
<ol>
<li>利用栈的结构完成逆序输出</li>
</ol>
<h3 id="提交地址">提交地址</h3>
<p><a href="https://www.nowcoder.com/practice/c54775799f634c72b447ef31eb36e975?tpId=40&amp;qru=%2Fta%2Ftsing-kaoyan%2Fquestion-ranking&amp;tab=answerKey">https://www.nowcoder.com/practice/c54775799f634c72b447ef31eb36e975?tpId=40&amp;qru=%2Fta%2Ftsing-kaoyan%2Fquestion-ranking&amp;tab=answerKey</a></p>
<h3 id="代码">代码</h3>
<pre><code class="language-c++">#include &lt;iostream&gt;
#include &lt;stack&gt;
#include &lt;cstdio&gt;

using namespace std;

int main()
{
    int count;
    stack&lt;int&gt; record;
    
    while(cin &gt;&gt; count)
    {
        int num;
        for (int i=0; i&lt;count; i++)
        {
            cin &gt;&gt; num;
            record.push(num);
        }
        
        for (int i=0; i&lt;count; i++)
        {
            if (record.empty())
            {
                cout &lt;&lt; record.top() &lt;&lt; endl;
                record.pop();
            }
            else
            {
                cout &lt;&lt; record.top() &lt;&lt; &quot; &quot;;
                record.pop();
            }          
        }    
    }
}
</code></pre>
<h2 id="2-括号序列">2. <strong>括号序列</strong></h2>
<h3 id="题目描述-2"><strong>题目描述</strong></h3>
<p>给出一个仅包含字符'(',')','{','}','['和']',的字符串，判断给出的字符串是否是合法的括号序列<br>
括号必须以正确的顺序关闭，&quot;()&quot;和&quot;()[]{}&quot;都是合法的括号序列，但&quot;(]&quot;和&quot;([)]&quot;不合法。</p>
<h3 id="要点-2"><strong>要点</strong></h3>
<ol>
<li>利用栈的结构完成序号匹配（思想参考编译原理）</li>
<li>若符合规则，就将一对符号弹出</li>
</ol>
<h3 id="提交地址-2">提交地址</h3>
<p><a href="https://www.nowcoder.com/practice/6235a76b1e404f748f7c820583125c50?tpId=8&amp;qru=%2Fta%2Ftsing-kaoyan%2Fquestion-ranking&amp;tab=answerKey">https://www.nowcoder.com/practice/6235a76b1e404f748f7c820583125c50?tpId=8&amp;qru=%2Fta%2Ftsing-kaoyan%2Fquestion-ranking&amp;tab=answerKey</a></p>
<h3 id="代码-2">代码</h3>
<pre><code class="language-c++">class Solution {
public:
    /**
     * 
     * @param s string字符串 
     * @return bool布尔型
     */
    bool isValid(string s) {
        // write code here
        stack&lt;char&gt; record;
        for (int i=0; i&lt;s.size(); i++)
        {
            int temp = s[i];
            if (!record.empty())
            {                
                int symbol = record.top();
                if (  (temp==')' &amp;&amp; symbol=='(')
                    ||(temp==']' &amp;&amp; symbol=='[')
                    ||(temp=='}' &amp;&amp; symbol=='{')
                   )
                {
                    record.pop();
                }
                else
                {
                    record.push(temp);
                }
                   
            }
            else
            {
                record.push(temp);
            }           
        }
        
        if (record.empty())
            return true;
        else
            return false;
    }
};
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Chapter5数据结构一：5.2 队列]]></title>
        <id>https://Czardas42.github.io/post/chapter5_5.2/</id>
        <link href="https://Czardas42.github.io/post/chapter5_5.2/">
        </link>
        <updated>2021-05-05T07:45:56.000Z</updated>
        <content type="html"><![CDATA[<h2 id="队列基本操作">队列基本操作</h2>
<h2 id="1-约瑟夫问题">1. <strong>约瑟夫问题</strong></h2>
<h3 id="题目描述"><strong>题目描述</strong></h3>
<p>编号为 1 到 n的 n个人围成一圈。从编号为 11 的人开始报数，报到 m的人离开。</p>
<p>下一个人继续从 11 开始报数。</p>
<p>n-1轮结束以后，只剩下一个人，问最后留下的这个人编号是多少？</p>
<h3 id="要点"><strong>要点</strong></h3>
<ol>
<li>利用队列模拟的思想</li>
<li>不需循环列表也可以完成</li>
</ol>
<h3 id="提交地址">提交地址</h3>
<p><a href="https://www.nowcoder.com/practice/41c399fdb6004b31a6cbb047c641ed8a?tpId=196&amp;qru=%2Fta%2Ftsing-kaoyan%2Fquestion-ranking&amp;tab=answerKey">https://www.nowcoder.com/practice/41c399fdb6004b31a6cbb047c641ed8a?tpId=196&amp;qru=%2Fta%2Ftsing-kaoyan%2Fquestion-ranking&amp;tab=answerKey</a></p>
<h3 id="代码">代码</h3>
<pre><code class="language-c++">class Solution {
public:
    /**
     * @param n int整型 
     * @param m int整型 
     * @return int整型
     */
    int ysf(int n, int m) {
        // write code here
        queue&lt;int&gt; line;
        //全部入队
        for (int i=1; i&lt;=n; i++)
        {
            line.push(i);
        }
        //开始模拟
        for (int j=1; j&lt;n; j++)//n-1轮游戏
        {
            for (int i=1; i&lt;m; i++)
            {
                int temp = line.front();
                line.pop();
                line.push(temp);
            }
            line.pop();
        }
        
        return line.front();
    }
};
</code></pre>
<h2 id="2-猫狗收容所">2. <strong>猫狗收容所</strong></h2>
<h3 id="题目描述-2"><strong>题目描述</strong></h3>
<p>有家动物收容所只收留猫和狗，但有特殊的收养规则，收养人有两种收养方式，第一种为直接收养所有动物中最早进入收容所的，第二种为选择收养的动物类型（猫或狗），并收养该种动物中最早进入收容所的。</p>
<p>给定一个操作序列int[][2] ope(C++中为vector<vector>)代表所有事件。若第一个元素为1，则代表有动物进入收容所，第二个元素为动物的编号，正数代表狗，负数代表猫；若第一个元素为2，则代表有人收养动物，第二个元素若为0，则采取第一种收养方式，若为1，则指定收养狗，若为-1则指定收养猫。请按顺序返回收养的序列。若出现不合法的操作，即没有可以符合领养要求的动物，则将这次领养操作忽略。</p>
<h3 id="要点-2"><strong>要点</strong></h3>
<ol>
<li>利用两个队列分别记录猫狗</li>
<li>animal结构体：<strong>记录type和时间tag</strong></li>
<li><strong>注意讨论收养时猫狗列表可能为空的情况</strong></li>
</ol>
<h3 id="提交地址-2">提交地址</h3>
<p><a href="https://www.nowcoder.com/practice/6235a76b1e404f748f7c820583125c50?tpId=8&amp;qru=%2Fta%2Ftsing-kaoyan%2Fquestion-ranking&amp;tab=answerKey">https://www.nowcoder.com/practice/6235a76b1e404f748f7c820583125c50?tpId=8&amp;qru=%2Fta%2Ftsing-kaoyan%2Fquestion-ranking&amp;tab=answerKey</a></p>
<h3 id="代码-2">代码</h3>
<pre><code class="language-c++">class CatDogAsylum {
public:
    struct animal
    {
        int type;
        int order;
        animal(int t, int o)
        {
            type = t;
            order = o;
        }
    };
    vector&lt;int&gt; asylum(vector&lt;vector&lt;int&gt; &gt; ope) 
    {
        // write code here
        queue&lt;animal&gt; cats, dogs;
        int order = 0;
        vector&lt;int&gt; result;
        for (int i=0; i&lt;ope.size(); i++)
        {
            vector&lt;int&gt; item = ope[i];
            int method = item[0];
            int type = item[1];
            
            if (method == 1) //有动物进入
            {
                if (type &gt; 0) //狗
                {
                    order++;
                    dogs.push(animal(type, order));
                }
                else if (type &lt; 0) //猫
                {
                    order++;
                    cats.push(animal(type, order));
                }
            }
            else if (method == 2) //有人收养
            {
                animal dog = dogs.front();
                animal cat = cats.front();
                
                if (type == 0) //直接收养最早进入的
                {
                    if (dog.order&lt;cat.order &amp;&amp; !dogs.empty() &amp;&amp; !cats.empty())
                    {
                        result.push_back(dog.type);
                        dogs.pop();
                    }
                    else if (dog.order&gt;cat.order &amp;&amp; !dogs.empty() &amp;&amp; !cats.empty())
                    {
                        result.push_back(cat.type);
                        cats.pop();
                    }
                    else if (dogs.empty())
                    {
                        result.push_back(cat.type);
                        cats.pop();
                    }
                    else if (cats.empty())
                    {
                        result.push_back(dog.type);
                        dogs.pop();
                    }
                }
                else if (type == 1 &amp;&amp; !dogs.empty()) //指定收养狗
                {
                    result.push_back(dog.type);
                    dogs.pop();
                }
                else if (type == -1 &amp;&amp; !cats.empty()) //指定收养猫
                {
                    result.push_back(cat.type);
                    cats.pop();
                }
            }
        }
        return result;
    }
};
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Chapter5数据结构一：5.1 向量]]></title>
        <id>https://Czardas42.github.io/post/chapter5_5.1/</id>
        <link href="https://Czardas42.github.io/post/chapter5_5.1/">
        </link>
        <updated>2021-05-05T07:44:06.000Z</updated>
        <content type="html"><![CDATA[<h2 id="向量基本操作">向量基本操作</h2>
<h2 id="完数与盈数"><strong>完数与盈数</strong></h2>
<h3 id="题目描述"><strong>题目描述</strong></h3>
<p>一个数如果恰好等于它的各因子（该数本身除外）子和，如：6=3+2+1，则称其为“完数”；若因子之和大于该数，则称其为“盈数”。求出2 到60 之间所有“完数”和“盈数”，并以如下形式输出： E: e1 e2 e3 ......(ei 为完数) G: g1 g2 g3 ......(gi 为盈数)</p>
<h3 id="要点"><strong>要点</strong></h3>
<ol>
<li><code>vector.pop_back()</code>是弹出最后一个元素</li>
<li>vector遍历方法：<code>vector.size()</code></li>
<li>求因子的方法：<code>num % i == 0</code></li>
</ol>
<h3 id="提交地址">提交地址</h3>
<p><a href="https://www.nowcoder.com/practice/df0d850e41894d06a165bf445ec8a8b4?tpId=40&amp;qru=%2Fta%2Ftsing-kaoyan%2Fquestion-ranking&amp;tab=answerKey">https://www.nowcoder.com/practice/df0d850e41894d06a165bf445ec8a8b4?tpId=40&amp;qru=%2Fta%2Ftsing-kaoyan%2Fquestion-ranking&amp;tab=answerKey</a></p>
<h3 id="代码">代码</h3>
<pre><code class="language-c++">#include &lt;iostream&gt;
#include &lt;cstdio&gt;
#include &lt;vector&gt;

using namespace std;

int Sum(int num)
{
    int sum = 0;
    for (int i=1; i&lt;num; i++)
    {
        if (num % i == 0)
        {
            sum += i;
        }
    }
    return sum;
};

int main()
{
    vector&lt;int&gt; E, G;
    for (int i=2; i&lt;=60; i++)
    {
        int sum = Sum(i);
        if (i == sum)
        {   
            E.push_back(i);
        }
        else if (i &lt; sum)
        {
            G.push_back(i);
        }
    }
    //输出E
    cout &lt;&lt; &quot;E:&quot;;
    for (int j=0; j&lt;E.size(); j++)
    {
        cout &lt;&lt; &quot; &quot; &lt;&lt; E[j];
    }
    //输出G
    cout &lt;&lt; &quot; G:&quot;;
    for (int j=0; j&lt;G.size(); j++)
    {
        cout &lt;&lt; &quot; &quot; &lt;&lt; G[j];
    }
    cout &lt;&lt; endl;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Chapter4字符串：4.3 字符串匹配]]></title>
        <id>https://Czardas42.github.io/post/chapter4_4.3/</id>
        <link href="https://Czardas42.github.io/post/chapter4_4.3/">
        </link>
        <updated>2021-05-05T07:40:00.000Z</updated>
        <content type="html"><![CDATA[<h2 id="kmp算法">KMP算法</h2>
<h2 id="1-string-matching"><strong>1. String Matching</strong></h2>
<h3 id="题目描述"><strong>题目描述</strong></h3>
<p>Finding all occurrences of a pattern in a text is a problem that arises frequently in text-editing programs.   Typically,the text is a document being edited,and the pattern searched for is a particular word supplied by the user.    We assume that the text is an array T[1..n] of length n and that the pattern is an array P[1..m] of length m&lt;=n.We further assume that the elements of P and T are all alphabets(∑={a,b...,z}).The character arrays P and T are often called strings of characters.    We say that pattern P occurs with shift s in the text T if 0&lt;=s&lt;=n and T[s+1..s+m] = P[1..m](that is if T[s+j]=P[j],for 1&lt;=j&lt;=m).    If P occurs with shift s in T,then we call s a valid shift;otherwise,we calls a invalid shift.   Your task is to calculate the number of vald shifts for the given text T and p attern P.</p>
<h3 id="要点"><strong>要点</strong></h3>
<ol>
<li>
<p><strong>KMP算法</strong>，nextTable构建方式 <strong>（两个函数）</strong></p>
</li>
<li>
<p>返回第一个匹配子串/返回全部匹配子串个数</p>
</li>
</ol>
<h3 id="提交地址">提交地址</h3>
<p><a href="https://www.nowcoder.com/practice/00438b0bc9384ceeb65613346b42e88a?tpId=40&amp;qru=%2Fta%2Ftsing-kaoyan%2Fquestion-ranking&amp;tab=answerKey">https://www.nowcoder.com/practice/00438b0bc9384ceeb65613346b42e88a?tpId=40&amp;qru=%2Fta%2Ftsing-kaoyan%2Fquestion-ranking&amp;tab=answerKey</a></p>
<h3 id="代码">代码</h3>
<pre><code class="language-c++">#include &lt;iostream&gt;
#include &lt;cstdio&gt;
#include &lt;string&gt;

using namespace std;

int text[1000000];
int pattern[1000000];
int nextTable[1000000];

void getNextTable(string pattern)
{
    int m = pattern.size();
    nextTable[0] = -1;
    int i=0, j=-1;
    while(i &lt; m)
    {
        if (j == -1 || pattern[i] == pattern[j])
        {
            i++;
            j++;
            nextTable[i] = j;
        }
        else
        {
            j = nextTable[j];
        }
    }
};

int kmp(string text, string pattern)
{
    int m = text.size();
    int n = pattern.size();
    getNextTable(pattern);
    
    int count = 0;
    int i = 0;
    int j = 0;

    while(i &lt; m)
    {
        //匹配
        if ((j == -1) || (text[i] == pattern[j]))
        {
            i++;
            j++;
        }
        else
        {
            j = nextTable[j];
        }
        
        //判断
        if(j == n)
        {
            count++;
            j = nextTable[j];
        }
    }
    
    return count;
};

int main()
{
    string text, pattern;
    while(cin &gt;&gt; text &gt;&gt; pattern)
    {
        int count = kmp(text,pattern);
        cout &lt;&lt; count &lt;&lt; endl;
    }
    return 0;
}
</code></pre>
<h2 id="2-字符串匹配">2. 字符串匹配</h2>
<h3 id="题目描述-2"><strong>题目描述</strong></h3>
<p>读入数据string[ ]，然后读入一个短字符串。要求查找string[ ]中和短字符串的所有匹配，输出行号、匹配字符串。匹配时不区分大小写，并且可以有一个用中括号表示的模式匹配。如“aa[123]bb”，就是说aa1bb、aa2bb、aa3bb都算匹配。</p>
<h3 id="要点-2"><strong>要点</strong></h3>
<ol>
<li>
<p>注意：题目要求的是完全匹配，即长度完全一样，忽略大小写</p>
</li>
<li>
<p>可以使用<strong>正则表达式</strong></p>
<p><code>#include &lt;regex&gt;</code></p>
<p><code>regex r(st[0], regex::icase); // regex::icase 不区分大小写,建立正则表达式</code></p>
<p><code>regex_match(st[i], r)</code></p>
</li>
</ol>
<h3 id="提交地址-2">提交地址</h3>
<p><a href="https://www.nowcoder.com/practice/fbdc522ef958455687654b38a4ca01e0?tpId=40&amp;qru=%2Fta%2Ftsing-kaoyan%2Fquestion-ranking&amp;tab=answerKey">https://www.nowcoder.com/practice/fbdc522ef958455687654b38a4ca01e0?tpId=40&amp;qru=%2Fta%2Ftsing-kaoyan%2Fquestion-ranking&amp;tab=answerKey</a></p>
<h3 id="代码-2">代码</h3>
<pre><code class="language-C++">#include &lt;cstdio&gt;
#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;regex&gt;

using namespace std;
string st[1001];

int main () {
    int n;
    scanf(&quot;%d &quot;, &amp;n);
    for (int i=1; i&lt;=n; ++i)
        getline(cin, st[i]);
    getline(cin, st[0]);
    regex r(st[0], regex::icase);  // regex::icase 不区分大小写
    for (int i=1; i&lt;=n; ++i)
        if (regex_match(st[i], r))  // 这是完全匹配，部分匹配用regex_search
            cout &lt;&lt; i &lt;&lt; ' ' &lt;&lt; st[i] &lt;&lt; endl;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[VPC对等连接]]></title>
        <id>https://Czardas42.github.io/post/vpc_p2p/</id>
        <link href="https://Czardas42.github.io/post/vpc_p2p/">
        </link>
        <updated>2021-05-05T07:33:40.000Z</updated>
        <content type="html"><![CDATA[<h4 id="概念">概念</h4>
<p>对等连接是指两个VPC之间的网络连接。可以使用私有IP地址在两个VPC之间进行通信，就像两个VPC在同一个网络中一样。同一区域内，可以在自己的VPC之间创建对等连接，也可以在自己的VPC与其他帐户的VPC之间创建对等连接。不同区域间的VPC之间不能创建对等连接。</p>
<figure data-type="image" tabindex="1"><img src="https://Czardas42.github.io//post-images/1620200083815.png" alt="" loading="lazy"></figure>
<h4 id="约束与限制">约束与限制</h4>
<ul>
<li>有重叠子网网段的VPC建立的对等连接，可能不生效。</li>
<li>两个VPC之间不能同时建立多个VPC对等连接。</li>
<li>不同区域的VPC不能创建对等连接。</li>
</ul>
<h4 id="路由配置">路由配置</h4>
<p>如图1所示，VPC1和VPC2需要通过添加路由来建立对等关系。对等连接路由配置如图2所示，配置完成后，VPC1和VPC2就建立了对等关系，可以相互通信。</p>
<p>指向整个VPC的对等连接的路由配置，目的地址为对端VPC的CIDR，下一跳地址为对等连接ID。</p>
<blockquote>
<p>无类域间路由（Classless Inter-Domain Routing，CIDR）可以将路由集中起来，在路由表中更灵活地定义地址。它不区分 A 类、B 类、C 类地址，而是使用 CIDR 前缀的值指定地址中作为网络 ID 的位数。</p>
</blockquote>
<figure data-type="image" tabindex="2"><img src="https://Czardas42.github.io//post-images/1620200105962.png" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="3"><img src="https://Czardas42.github.io//post-images/1620200120934.png" alt="" loading="lazy"></figure>
<h4 id="操作流程以跨用户为例">操作流程（以跨用户为例）</h4>
<p>跨帐户创建VPC对等连接时，一端VPC发起创建对等连接请求，对等连接状态为待接受。待对方接受该创建请求后，对等连接状态变为已接受，请求方和接受方须分别配置对等连接路由信息，才能使两个VPC互通。</p>
<figure data-type="image" tabindex="4"><img src="https://Czardas42.github.io//post-images/1620200145251.png" alt="" loading="lazy"></figure>
<p><a href="https://support.huaweicloud.com/usermanual-vpc/zh-cn_topic_0046655038.html">https://support.huaweicloud.com/usermanual-vpc/zh-cn_topic_0046655038.html</a></p>
<p><u><strong>实验过程中搭建K8s集群所用到VPC对等连接操作实例</strong></u></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[OpenFaaS]]></title>
        <id>https://Czardas42.github.io/post/openfaas/</id>
        <link href="https://Czardas42.github.io/post/openfaas/">
        </link>
        <updated>2021-05-05T07:30:28.000Z</updated>
        <content type="html"><![CDATA[<h4 id="layers-工作流程">Layers &amp; 工作流程</h4>
<figure data-type="image" tabindex="1"><img src="https://Czardas42.github.io//post-images/1620199885176.png" alt="" loading="lazy"></figure>
<p><strong>无服务器函数变得简单</strong></p>
<ul>
<li>推荐的部署OpenFaaS平台都是Kubernetes</li>
<li>OpenFaaS Cloud建立在OpenFaaS的基础上，可通过GitHub.com或自行托管的GitLab交付GitOps</li>
<li>NATS提供异步执行和排队</li>
<li>Prometheus提供指标并通过AlertManager启用自动缩放</li>
<li>容器注册表包含每个可以通过API部署在OpenFaaS上的不可变工件</li>
</ul>
<figure data-type="image" tabindex="2"><img src="https://Czardas42.github.io//post-images/1620199913601.png" alt="" loading="lazy"></figure>
<p>可以通过其REST API，CLI或UI来访问网关。所有服务或功能都会暴露默认路由，但是自定义域也可以用于每个端点。</p>
<h4 id="gateway">Gateway</h4>
<p>OpenFaaS的Gateway是一个golang实现的请求转发的网关，在这个网关服务中，主要有以下几个功能：</p>
<ul>
<li>UI</li>
<li>部署函数</li>
<li>监控</li>
<li>自动伸缩</li>
</ul>
<figure data-type="image" tabindex="3"><img src="https://Czardas42.github.io//post-images/1620199930497.png" alt="" loading="lazy"></figure>
<p>从图中可以发现，当Gateway作为一个入口，当CLI或者web页面发来要部署或者调用一个函数的时候，Gateway会将请求转发给Provider，同时会将监控指标发给Prometheus。AlterManager会根据需求，调用API自动伸缩函数。</p>
<p>Gateway是OpenFaaS最为重要的一个组件。Gateway本质上就是一个rest转发服务，一个一个的handler，每个模块之间的耦合性不是很高，可以很容易的去拆卸，自定义实现相应的模块。</p>
<blockquote>
<p>源码解读：<a href="https://zhuanlan.zhihu.com/p/41056766">https://zhuanlan.zhihu.com/p/41056766</a></p>
</blockquote>
<h4 id="watchdog">watchdog</h4>
<p>watchdog提供了一个外部世界和函数之间的非托管的通用接口。它的工作是收集从API网关来的HTTP请求，然后调用程序。watchdog是一个小型的Golang服务</p>
<p>下图展示了它是如何工作的：</p>
<p>一个小型的web服务，可以为每个传入的HTTP请求分配所需要的进程。</p>
<figure data-type="image" tabindex="4"><img src="https://Czardas42.github.io//post-images/1620199949953.png" alt="" loading="lazy"></figure>
<p>每个函数都需要嵌入这个二进制文件并将其作为<code>ENTRYPOINT</code> 或 <code>CMD</code>，实际上是把它作为容器的初始化进程。一旦进程被创建分支，watchdog就会通过<code>stdin</code> 传递HTTP请求并从<code>stdout</code>中读取HTTP响应。这意味着程序无需知道web和HTTP的任何信息。</p>
<h4 id="of-watchdog">of-watchdog</h4>
<p><code>of-watchdog</code>项目于2017年10月启动，该组件适合在生产中使用，并且是<a href="https://github.com/openfaas">openfaas</a> GitHub组织的一部分。</p>
<p>of-watchdog是函数和微服务之间的<strong>反向代理</strong>。</p>
<p>of-watchdog的默认模式是http模式，部署服务时of-watchdog会fork一个进程（假设为进程A），进程A会监听一个端口，of-wahtchdog收到的所有请求都会转发到进程A监听的端口，HTTP模式的官方架构图如下：</p>
<figure data-type="image" tabindex="5"><img src="https://Czardas42.github.io//post-images/1620199965913.png" alt="" loading="lazy"></figure>
<p>如图所示，代码是在右侧的child里面执行的，这个child从3000端口收到of-watchdog转发过来的外部请求，然后内部处理掉。</p>
<p>主要区别在于：经典的看门狗会为每个请求派生一个进程，以提供最高级别的可移植性，<strong>但是of-watchdog启用了一种<code>http</code>模式，在该模式下，该进程可以重复使用，以抵消分叉的延迟</strong>。</p>
<p>of-watchdog的优点：</p>
<ul>
<li>第一，并发性能和吞吐量最优；</li>
<li>第二，相比watchdog，对内存的使用更高效；</li>
<li>第三，建好的数据库连接可以反复使用；</li>
<li>第四，容器操作系统的临时文件夹(/tmp/目录)，是所有请求共用的，例如可以做临时缓存用</li>
</ul>
<h4 id="函数请求处理流程感觉写好了很亮眼">函数请求处理流程（感觉写好了很亮眼）</h4>
<p>【参考】</p>
<p><a href="https://blog.csdn.net/weixin_38616705/article/details/107385293">https://blog.csdn.net/weixin_38616705/article/details/107385293</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/41056766">https://zhuanlan.zhihu.com/p/41056766</a></p>
<ol>
<li>
<p><strong>访问openfaas的gateway的service。</strong></p>
<p>对于一个函数请求而言，其由一个客户端发出，首先访问的是openfaas的gateway的service，通过iptables将对于Service的访问路由到pod所连接的网卡。</p>
<p>iptables中的处理流程：</p>
<p><em><u>需要真实操作的真实截图</u></em></p>
<p>该流程画成图就是如下图所示的过程*<u>（图需要自己重新画）</u>*</p>
</li>
</ol>
<figure data-type="image" tabindex="6"><img src="https://Czardas42.github.io//post-images/1620302159529.png" alt="" loading="lazy"></figure>
<ol start="2">
<li>
<p><strong>pod的连接</strong></p>
<p>在多节点集群中，请求进行DNAT之后会被转发到flannel网卡上，然后由一个flanneld的程序进行处理（也就是路由，flanneld通过etcd储存了一个集群的网络信息，通过此进行路由），接着flanneld会根据路由选择的结果将请求转发到目的pod所在机器上，而在目的pod所在机器上，请求先是被转发到flannel网卡上。</p>
<p><em><u>（下图需要自己重新画）</u></em></p>
</li>
</ol>
<figure data-type="image" tabindex="7"><img src="https://Czardas42.github.io//post-images/1620302193199.png" alt="" loading="lazy"></figure>
<ol start="3">
<li><strong>找到了相应的pod，接下来需要发送给具体的容器。</strong></li>
</ol>
<figure data-type="image" tabindex="8"><img src="https://Czardas42.github.io//post-images/1620302206521.png" alt="" loading="lazy"></figure>
<p>在每个pod之中，都有一个pause容器，这是kubernetes创建的系统容器，pause容器会创建网络命名空间并将直接的网络桥接到cni0网桥（通过veth pair），然后所有的用户容器都会共享这个网络命名空间，即共享一块网卡。那么请求转发的流程就是直接在cni0通过veth pair传向了pod内的eth0，接着容器就可以直接接收网卡eth0上的信息了。</p>
<ol>
<li><strong>Gateway中的请求处理</strong></li>
</ol>
<p>在gateway中存在处理函数请求的handler</p>
<p><strong>代理转发</strong></p>
<p>Gateway本身不做任何和部署发布函数的事情，它只是作为一个代理，把请求转发给相应的Provider去处理，所有的请求都要通过这个网关。</p>
<p><strong>4.1 同步函数转发</strong></p>
<p>主要转发的API有：</p>
<ul>
<li>RoutelessProxy</li>
<li>ListFunctions</li>
<li>DeployFunction</li>
<li>DeleteFunction</li>
<li>UpdateFunction</li>
</ul>
<pre><code class="language-C">faasHandlers.RoutelessProxy = handlers.MakeForwardingProxyHandler(reverseProxy, forwardingNotifiers, urlResolver)
    faasHandlers.ListFunctions = handlers.MakeForwardingProxyHandler(reverseProxy, forwardingNotifiers, urlResolver)
    faasHandlers.DeployFunction = handlers.MakeForwardingProxyHandler(reverseProxy, forwardingNotifiers, urlResolver)
    faasHandlers.DeleteFunction = handlers.MakeForwardingProxyHandler(reverseProxy, forwardingNotifiers, urlResolver)
    faasHandlers.UpdateFunction = handlers.MakeForwardingProxyHandler(reverseProxy, forwardingNotifiers, urlResolver)
</code></pre>
<p>MakeForwardingProxyHandler()有三个参数：</p>
<ul>
<li>proxy<br>
这是一个http的客户端，作者把这个客户端抽成一个类，然后使用该类的NewHTTPClientReverseProxy方法创建实例，这样就简化了代码，不用每次都得写一堆相同的配置。</li>
<li>notifiers<br>
这个其实是要打印的日志，这里是一个HTTPNotifier的接口。而在这个MakeForwardingProxyHandler中其实有两个实现类，一个是LoggingNotifier，一个是PrometheusFunctionNotifier，分别用来打印和函数http请求相关的日志以及和Prometheus监控相关的日志。</li>
<li>baseURLResolver<br>
这个就是Provider的url地址。</li>
</ul>
<p>MakeForwardingProxyHandler中主要做了三件事儿：</p>
<ul>
<li>解析要转发的url</li>
<li>调用forwardRequest方法转发请求，</li>
<li>打印日志</li>
</ul>
<pre><code class="language-C">// MakeForwardingProxyHandler create a handler which forwards HTTP requests
func MakeForwardingProxyHandler(proxy *types.HTTPClientReverseProxy, notifiers []HTTPNotifier, baseURLResolver BaseURLResolver) http.HandlerFunc {
    return func(w http.ResponseWriter, r *http.Request) {
        baseURL := baseURLResolver.Resolve(r)
        requestURL := r.URL.Path
        start := time.Now()
        statusCode, err := forwardRequest(w, r, proxy.Client, baseURL, requestURL, proxy.Timeout)
        seconds := time.Since(start)
        if err != nil {
            log.Printf(&quot;error with upstream request to: %s, %s\n&quot;, requestURL, err.Error())
        }
        for _, notifier := range notifiers {
            notifier.Notify(r.Method, requestURL, statusCode, seconds)
        }
    }
}
</code></pre>
<p><strong>4.2 异步函数转发</strong></p>
<p>如果是异步函数，Gateway就作为一个发布者，将函数放到队列里。MakeQueuedProxy方法就是做这件事的：</p>
<ol>
<li>读取请求体</li>
<li>将<code>X-Callback-Url</code>参数从参数中http的header中读出来</li>
<li>实例化用于异步处理的Request对象</li>
<li>调用canQueueRequests.Queue(req)，将请求发布到队列中</li>
</ol>
<pre><code class="language-C">// MakeQueuedProxy accepts work onto a queue
func MakeQueuedProxy(metrics metrics.MetricOptions, wildcard bool, canQueueRequests queue.CanQueueRequests) http.HandlerFunc {
    return func(w http.ResponseWriter, r *http.Request) {
        defer r.Body.Close()
        body, err := ioutil.ReadAll(r.Body)
        // 省略错误处理代码
        vars := mux.Vars(r)
        name := vars[&quot;name&quot;]
​
        callbackURLHeader := r.Header.Get(&quot;X-Callback-Url&quot;)
        var callbackURL *url.URL
        if len(callbackURLHeader) &gt; 0 {
            urlVal, urlErr := url.Parse(callbackURLHeader)
            // 省略错误处理代码
            callbackURL = urlVal
        }
        req := &amp;queue.Request{
            Function:    name,
            Body:        body,
            Method:      r.Method,
            QueryString: r.URL.RawQuery,
            Header:      r.Header,
            CallbackURL: callbackURL,
        }
        err = canQueueRequests.Queue(req)
        // 省略错误处理代码
        w.WriteHeader(http.StatusAccepted)
    }
}
</code></pre>
<ol start="5">
<li>
<p><strong>函数pod内部的请求处理</strong></p>
<p>接下来gateway就会把请求转发给具体的function所对应的Service，这里Service的访问流程如前所述，但是也有一点需要注意，因为每个function都会对应多个pod副本，那么Service在进行iptables处理的时候就需要选择一个具体的pod来转发请求，这个时候就会有一个负载均衡的问题，而Kubernetes在这里的处理是随机选择一个pod进行转发。</p>
<p><strong>目前，对于openfaas，如前文所述，函数的部署是通过of-watchdog。</strong></p>
</li>
</ol>
<figure data-type="image" tabindex="9"><img src="https://Czardas42.github.io//post-images/1620199965913.png" alt="" loading="lazy"></figure>
<p>在Http的方式下当这个watchdog启动时，父进程会fork一个子进程（也就是用户提交的函数程序），这个函数程序不是简单的函数逻辑，也要包含一个Http服务器用来处理Http请求，且这个函数程序会一直运行，监听容器网卡上的端口以获得请求。</p>
<h4 id="自动伸缩"><strong>自动伸缩</strong></h4>
<p>【参考】</p>
<p><a href="https://zhuanlan.zhihu.com/p/41056766">https://zhuanlan.zhihu.com/p/41056766</a></p>
<p>伸缩性其实有两种，一种是可以通过调用API接口，来将函数进行缩放。另外一种就是通过AlertHandler。</p>
<p>自动伸缩是OpenFaaS的一大特点，触发自动伸缩主要是根据不同的指标需求。</p>
<ul>
<li>
<p>根据每秒请求数来做伸缩<br>
OpenFaaS附带了一个自动伸缩的规则，这个规则是在AlertManager配置文件中定义。AlertManager从Prometheus中读取使用情况（每秒请求数），然后在满足一定条件时向Gateway发送警报。<br>
可以通过删除AlertManager，或者将部署扩展的环境变量设置为0，来禁用此方式。</p>
</li>
<li>
<p>最小/最大副本数<br>
通过向函数添加标签, 可以在部署时设置最小 (初始) 和最大副本数。</p>
</li>
<li>
<ul>
<li><code>com.openfaas.scale.min</code> 默认是 <code>1</code></li>
<li><code>com.openfaas.scale.max</code> 默认是 <code>20</code></li>
<li><code>com.openfaas.scale.factor</code> 默认是 <code>20%</code> ，在0-100之间，这是每次扩容的时候，新增实例的百分比，若是100的话，会瞬间飙升到副本数的最大值。</li>
</ul>
</li>
</ul>
<p><code>com.openfaas.scale.min</code> 和 <code>com.openfaas.scale.max</code>值一样的时候，可以关闭自动伸缩。<br>
<code>com.openfaas.scale.factor</code>是0时，也会关闭自动伸缩。</p>
<p><strong>scaleService</strong></p>
<p>Gateway的源码中，<code>scaleService</code>是真正处理伸缩服务的函数：</p>
<pre><code class="language-C">func scaleService(alert requests.PrometheusInnerAlert, service ServiceQuery) error {
    var err error
    serviceName := alert.Labels.FunctionName
​
    if len(serviceName) &gt; 0 {
        queryResponse, getErr := service.GetReplicas(serviceName)
        if getErr == nil {
            status := alert.Status
​
            newReplicas := CalculateReplicas(status, queryResponse.Replicas, uint64(queryResponse.MaxReplicas), queryResponse.MinReplicas, queryResponse.ScalingFactor)
​
            log.Printf(&quot;[Scale] function=%s %d =&gt; %d.\n&quot;, serviceName, queryResponse.Replicas, newReplicas)
            if newReplicas == queryResponse.Replicas {
                return nil
            }
​
            updateErr := service.SetReplicas(serviceName, newReplicas)
            if updateErr != nil {
                err = updateErr
            }
        }
    }
    return err
}
</code></pre>
<p>从代码z中可以看到，scaleService做了三件事：</p>
<ul>
<li>获取现在的副本数</li>
<li>计算新的副本数<br>
新副本数的计算方法是根据<code>com.openfaas.scale.factor</code>计算步长：<br>
<code>step := uint64((float64(maxReplicas) / 100) * float64(scalingFactor))</code></li>
<li>设置为新的副本数</li>
</ul>
<p><strong>MakeScalingHandler</strong></p>
<p>在调用函数的时候，用的路由是：<code>/function/:name</code>。如果环境变量里有配置<code>scale_from_zero</code>为true，先用<code>MakeScalingHandler()</code>方法对proxyHandler进行一次包装。</p>
<p><code>MakeScalingHandler</code>接受参数主要是：</p>
<ul>
<li>
<p>next：就是下一个httpHandlerFunc，中间件都会有这样一个参数</p>
</li>
<li>
<p>config：<code>ScalingConfig</code>的对象：</p>
<pre><code class="language-C">// ScalingConfig for scaling behaviours
type ScalingConfig struct {
MaxPollCount uint // 查到的最大数量
FunctionPollInterval time.Duration // 函数调用时间间隔
CacheExpiry time.Duration // 缓存过期时间
ServiceQuery ServiceQuery // 外部服务调用的一个接口
}
</code></pre>
</li>
</ul>
<p>这个<code>MakeScalingHandler</code>中间件主要做了如下的事情：</p>
<ul>
<li>
<p>先从FunctionCache缓存中获取该函数的基本信息，从这个缓存可以拿到每个函数的副本数量。</p>
</li>
<li>
<p>为了加快函数的启动速度，如果缓存中可以获该得函数，且函数的副本数大于0，满足条件，return即可。</p>
</li>
<li>
<p>如果不满足上一步，就会调用<code>SetReplicas</code>方法设置副本数，并更新FunctionCache的缓存。</p>
<pre><code class="language-C">// MakeScalingHandler creates handler which can scale a function from
// zero to 1 replica(s).
func MakeScalingHandler(next http.HandlerFunc, upstream http.HandlerFunc, config ScalingConfig) http.HandlerFunc {
    cache := FunctionCache{
        Cache:  make(map[string]*FunctionMeta),
        Expiry: config.CacheExpiry,
    }
    return func(w http.ResponseWriter, r *http.Request) {
        functionName := getServiceName(r.URL.String())
        if serviceQueryResponse, hit := cache.Get(functionName); hit &amp;&amp; serviceQueryResponse.AvailableReplicas &gt; 0 {
            next.ServeHTTP(w, r)
            return
        } 
        queryResponse, err := config.ServiceQuery.GetReplicas(functionName)
        cache.Set(functionName, queryResponse)
        // 省略错误处理
        if queryResponse.AvailableReplicas == 0 {
            minReplicas := uint64(1)
            if queryResponse.MinReplicas &gt; 0 {
                minReplicas = queryResponse.MinReplicas
            }
            err := config.ServiceQuery.SetReplicas(functionName, minReplicas)
            // 省略错误处理代码
            for i := 0; i &lt; int(config.MaxPollCount); i++ {
                queryResponse, err := config.ServiceQuery.GetReplicas(functionName)
                cache.Set(functionName, queryResponse)
                // 省略错误处理
                time.Sleep(config.FunctionPollInterval)
            }
        }
        next.ServeHTTP(w, r)
    }
}
</code></pre>
<p>注：</p>
</li>
<li>
<p><code>GetReplicas</code>方法<br>
从<code>system/function/:name</code>接口获取到函数的信息，组装一个<code>ServiceQueryResponse</code>对象即可。</p>
</li>
<li>
<p><code>SetReplicas</code>方法<br>
调用<code>system/scale-function/:name</code>接口，设置副本数。</p>
</li>
</ul>
]]></content>
    </entry>
</feed>