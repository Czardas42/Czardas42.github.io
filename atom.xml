<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://Czardas42.github.io/</id>
    <title>Czardas</title>
    <updated>2021-05-05T07:55:23.866Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://Czardas42.github.io/"/>
    <link rel="self" href="https://Czardas42.github.io/atom.xml"/>
    <subtitle>世界那么大，我想去看看</subtitle>
    <logo>https://Czardas42.github.io/images/avatar.png</logo>
    <icon>https://Czardas42.github.io/favicon.ico</icon>
    <rights>All rights reserved 2021, Czardas</rights>
    <entry>
        <title type="html"><![CDATA[Chapter6数学问题：6.3质数]]></title>
        <id>https://Czardas42.github.io/post/chapter6_6.3/</id>
        <link href="https://Czardas42.github.io/post/chapter6_6.3/">
        </link>
        <updated>2021-05-05T07:52:58.000Z</updated>
        <content type="html"><![CDATA[<h2 id="判断记录质数的方法">判断/记录质数的方法</h2>
<ol>
<li><code>sqrt(n)</code></li>
<li>素数筛法</li>
</ol>
<h2 id="1-素数判定">1.  素数判定</h2>
<h3 id="题目描述"><strong>题目描述</strong></h3>
<p>给定一个数n，要求判断其是否为素数（0,1，负数都是非素数）。</p>
<h3 id="要点"><strong>要点</strong></h3>
<p>对于负数、0、1要特别处理</p>
<h3 id="提交地址">提交地址</h3>
<p><a href="https://www.nowcoder.com/practice/5fd9c28b1ce746dd99287a04d8fa9002?tpId=40&amp;qru=%2Fta%2Ftsing-kaoyan%2Fquestion-ranking&amp;tab=answerKey">https://www.nowcoder.com/practice/5fd9c28b1ce746dd99287a04d8fa9002?tpId=40&amp;qru=%2Fta%2Ftsing-kaoyan%2Fquestion-ranking&amp;tab=answerKey</a></p>
<h3 id="代码">代码</h3>
<pre><code class="language-c++">#include &lt;iostream&gt;
#include &lt;cstdio&gt;
#include &lt;cmath&gt;
using namespace std;

int main()
{
    int num;
    while (cin &gt;&gt; num)
    {
        if (num&lt;=1)
        {
            cout &lt;&lt; &quot;no&quot; &lt;&lt; endl;
            continue;
        }
        
        bool flag = true;
        for (int i=num-1; i&gt;=sqrt(num); i--)
        {
            if (num % i ==0)
            {
                flag = false;
                break;
            }
        }
        
        if (flag == true)
        {
            cout &lt;&lt; &quot;yes&quot; &lt;&lt; endl;
        }
        else
        {
            cout &lt;&lt; &quot;no&quot; &lt;&lt; endl;
        }
    }
}
</code></pre>
<h2 id="2-素数">2.  素数</h2>
<h3 id="题目描述-2"><strong>题目描述</strong></h3>
<p>输入一个整数n(2&lt;=n&lt;=10000)，要求输出所有从1到这个整数之间(不包括1和这个整数)个位为1的素数，如果没有则输出-1。</p>
<h3 id="要点-2"><strong>要点</strong></h3>
<p>方法一：穷举</p>
<p><strong>方法二【素数筛法】：找到一个素数，就要标记其所有倍数为非负数无需再针对每个数字进行判断</strong></p>
<p><strong>（实际操作中，只需从平方开始标记即可）</strong></p>
<h3 id="提交地址-2">提交地址</h3>
<p><a href="https://www.nowcoder.com/practice/7f4be54b37a04fdaa4ee545819151114?tpId=40&amp;qru=%2Fta%2Ftsing-kaoyan%2Fquestion-ranking&amp;tab=answerKey">https://www.nowcoder.com/practice/7f4be54b37a04fdaa4ee545819151114?tpId=40&amp;qru=%2Fta%2Ftsing-kaoyan%2Fquestion-ranking&amp;tab=answerKey</a></p>
<h3 id="代码穷举">代码（穷举）</h3>
<pre><code class="language-c++">#include &lt;iostream&gt;
#include &lt;cstdio&gt;
#include &lt;cmath&gt;

using namespace std;

int main()
{
    int range;
    while (cin &gt;&gt; range)
    {
        if (range &lt;= 11)
        {
            cout &lt;&lt; &quot;-1&quot; &lt;&lt; endl;
            continue;
        }
        
        for (int num =11; num&lt;range; num++)
        {
            bool flag = true;
            for (int i=num-1; i&gt;=sqrt(num); i--)
            {
                if (num % i == 0)
                {
                    flag = false;
                    break;
                }
            }
            
            if ((flag == true) &amp;&amp; (num%10 == 1))
            {
                if (num == 11)
                    cout &lt;&lt; num;
                else
                    cout &lt;&lt; &quot; &quot; &lt;&lt; num ;
            }
        }
        cout &lt;&lt; endl;
    }
    
    return 0;
}
</code></pre>
<h3 id="代码素数筛法">代码（素数筛法）</h3>
<pre><code class="language-c++">#include &lt;iostream&gt;
#include &lt;cstdio&gt;
#include &lt;cmath&gt;
#include &lt;vector&gt;

using namespace std;

int main()
{
    int range;
    while (cin &gt;&gt; range)
    {
        if (range &lt;=11)
        {
            cout &lt;&lt; &quot;-1\n&quot;;
            break;
        }
        
        bool num[10000];
        vector&lt;int&gt; prime;
        //初始化
        num[0] = false;
        num[1] = false;
        for (int i=2; i&lt;10000; i++)
            num[i] = true;
        
        for (int temp=2; temp&lt;range; temp++)
        {           
            if (num[temp] == true)
            {
                prime.push_back(temp);//加入素数组
                //标记之后temp的倍数不是素数
                for (int j=temp*temp; j&lt;range; j=j+temp)
                    num[j] = false;
            }
        }
        
        //输出
        for (int i=0; i&lt;prime.size(); i++)
        {
            if(prime[i] % 10 == 1)
            {
                if (prime[i] == 11)
                    cout &lt;&lt; prime[i];
                else                
                    cout &lt;&lt; &quot; &quot; &lt;&lt; prime[i];
            }
        }
        cout &lt;&lt; endl;        
    }
    
    return 0;
}
</code></pre>
<h2 id="3-prime-number">3.  Prime Number</h2>
<h3 id="题目描述-3"><strong>题目描述</strong></h3>
<p>Output the k-th prime number.</p>
<h3 id="要点-3"><strong>要点</strong></h3>
<ol>
<li>素数筛法</li>
<li>提前存好10000个素数：范围开到1000000就够用，或者可以记录素数个数</li>
<li><strong>适当可以使用void函数，让main函数看起来更加简洁</strong></li>
</ol>
<h3 id="提交地址-3">提交地址</h3>
<p><a href="https://www.nowcoder.com/practice/c5f8688cea8a4a9a88edbd67d1358415?tpId=40&amp;qru=%2Fta%2Ftsing-kaoyan%2Fquestion-ranking&amp;tab=answerKey">https://www.nowcoder.com/practice/c5f8688cea8a4a9a88edbd67d1358415?tpId=40&amp;qru=%2Fta%2Ftsing-kaoyan%2Fquestion-ranking&amp;tab=answerKey</a></p>
<pre><code class="language-c++">#include &lt;iostream&gt;
#include &lt;cstdio&gt;
#include &lt;vector&gt;

using namespace std;

int order;
vector&lt;int&gt; prime;
const int range = 1000000;

void Initial()
{
    bool num[range];
    for (int i=0; i&lt;range; i++)
        num[i] = true;
    num[0] = false;
    num[1] = false;
    
    for (int temp=0; temp&lt;range; temp++)
    {
        if (num[temp] == true)
        {
            prime.push_back(temp);
            
            for (int j=temp*temp; j&lt;range; j=j+temp)
                num[j] = false;
        }
    }
};

int main()
{
    Initial();      
    while (cin &gt;&gt; order)
    {
        cout &lt;&lt; prime[order-1] &lt;&lt; endl;
    }
    return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Chapter6数学问题：6.2 最大公约数和最小公倍数]]></title>
        <id>https://Czardas42.github.io/post/chapter6_6.2/</id>
        <link href="https://Czardas42.github.io/post/chapter6_6.2/">
        </link>
        <updated>2021-05-05T07:51:36.000Z</updated>
        <content type="html"><![CDATA[<h2 id="辗转相除法">辗转相除法</h2>
<h2 id="1-最大公约数">1.  最大公约数</h2>
<h3 id="题目描述"><strong>题目描述</strong></h3>
<p>输入两个正整数，求其最大公约数。</p>
<h3 id="要点"><strong>要点</strong></h3>
<p>递归实现辗转相除法GCD</p>
<h3 id="提交地址">提交地址</h3>
<p><a href="https://www.nowcoder.com/practice/20216f2c84bc438eb5ef05e382536fd3?tpId=40&amp;qru=%2Fta%2Ftsing-kaoyan%2Fquestion-ranking&amp;tab=answerKey">https://www.nowcoder.com/practice/20216f2c84bc438eb5ef05e382536fd3?tpId=40&amp;qru=%2Fta%2Ftsing-kaoyan%2Fquestion-ranking&amp;tab=answerKey</a></p>
<h3 id="代码">代码</h3>
<pre><code class="language-c++">#include &lt;iostream&gt;
#include &lt;cstdio&gt;

using namespace std;

int GCD(int a, int b)
{
    if(a%b == 0) //a可以整除b：b是最大公约数
    {
        return b;
    }
    else
    {
        return GCD(b, a%b);
    }
}

int main()
{
    int num1, num2;
    while(cin &gt;&gt; num1 &gt;&gt; num2)
    {
        cout &lt;&lt; GCD(num1, num2) &lt;&lt; endl;
    }
    
    return 0;
}
</code></pre>
<h2 id="2-最小公倍数">2.  最小公倍数</h2>
<h3 id="题目描述-2"><strong>题目描述</strong></h3>
<p>输入两个正整数，求其最小公约数。</p>
<h3 id="要点-2"><strong>要点</strong></h3>
<ol>
<li>
<p><strong>最小公倍数 = 两数乘积 / 最大公约数</strong></p>
</li>
<li>
<p>递归实现辗转相除法</p>
</li>
</ol>
<h3 id="提交地址-2">提交地址</h3>
<p><a href="https://www.nowcoder.com/practice/22948c2cad484e0291350abad86136c3?tpId=37&amp;qru=%2Fta%2Ftsing-kaoyan%2Fquestion-ranking&amp;tab=answerKey">https://www.nowcoder.com/practice/22948c2cad484e0291350abad86136c3?tpId=37&amp;qru=%2Fta%2Ftsing-kaoyan%2Fquestion-ranking&amp;tab=answerKey</a></p>
<h3 id="代码-2">代码</h3>
<pre><code class="language-c++">#include &lt;iostream&gt;
#include &lt;cstdio&gt;

using namespace std;

int GCD(int a, int b)
{
    if(a%b == 0)
    {
        return b;
    }
    else
    {
        return GCD(b, a%b);
    }
}

int main()
{
    int num1, num2;
    while (cin &gt;&gt; num1 &gt;&gt; num2)
    {
        int temp = num1 * num2;
        int result = temp / GCD(num1, num2);
        cout &lt;&lt; result &lt;&lt; endl;
    }
}
</code></pre>
<h2 id="3-最简真分数">3.  最简真分数</h2>
<h3 id="题目描述-3"><strong>题目描述</strong></h3>
<p>给出n个正整数，任取两个数分别作为分子和分母组成最简真分数，编程求共有几个这样的组合。</p>
<h3 id="要点-3"><strong>要点</strong></h3>
<ol>
<li>
<p><strong>最简真分数：分子&lt;分母；分子分母最大公约数为1</strong></p>
</li>
<li>
<p>因为真分数的要求，最终结果/2</p>
</li>
</ol>
<h3 id="提交地址-3">提交地址</h3>
<p><a href="https://www.nowcoder.com/practice/1f1db273eeb745c6ac83e91ff14d2ec9?tpId=40&amp;qru=%2Fta%2Ftsing-kaoyan%2Fquestion-ranking&amp;tab=answerKey">https://www.nowcoder.com/practice/1f1db273eeb745c6ac83e91ff14d2ec9?tpId=40&amp;qru=%2Fta%2Ftsing-kaoyan%2Fquestion-ranking&amp;tab=answerKey</a></p>
<h3 id="代码-3">代码</h3>
<pre><code class="language-c++">#include &lt;iostream&gt;
#include &lt;cstdio&gt;
#include &lt;vector&gt;

using namespace std;

int GCD(int a, int b)
{
    if(a%b == 0)
        return b;
    else
        return GCD(b, a%b);
};

int main()
{
    int count;
    while(cin &gt;&gt; count)
    {
        if (count == 0)
            break;
        //存入数据
        vector&lt;int&gt; number;
        int num;
        for (int i=0; i&lt;count; i++)
        {
            cin &gt;&gt; num;
            number.push_back(num);
        }
        //遍历
        int result = 0;
        for (int i=0; i&lt;number.size(); i++)
        {
            for (int j=0; j&lt;number.size(); j++)
            {
                int temp = GCD(number[i], number[j]);
                if (temp==1)
                {//两数最大公约数是1
                    result++;
                }
            }
        }
        cout &lt;&lt; result/2 &lt;&lt; endl;  //真分数&lt;1,所以结果/2         
    }
    
    return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Chapter6数学问题：6.1 进制转换]]></title>
        <id>https://Czardas42.github.io/post/chapter6_6.1/</id>
        <link href="https://Czardas42.github.io/post/chapter6_6.1/">
        </link>
        <updated>2021-05-05T07:48:49.000Z</updated>
        <content type="html"><![CDATA[<h2 id="进制转换原理">进制转换原理</h2>
<h2 id="1-二进制数">1.  二进制数</h2>
<h3 id="题目描述"><strong>题目描述</strong></h3>
<p>大家都知道，数据在计算机里中存储是以二进制的形式存储的。 有一天，小明学了C语言之后，他想知道一个类型为unsigned int 类型的数字，存储在计算机中的二进制串是什么样子的。 你能帮帮小明吗？并且，小明不想要二进制串中前面的没有意义的0串，即要去掉前导0。</p>
<h3 id="要点"><strong>要点</strong></h3>
<ol>
<li>进制转换标准公式</li>
<li>以及while循环判断条件<code>while (num != 0)</code></li>
</ol>
<h3 id="提交地址">提交地址</h3>
<p><a href="https://www.nowcoder.com/practice/103dd589fed14457a673c613d8de3841?tpId=40&amp;qru=%2Fta%2Ftsing-kaoyan%2Fquestion-ranking&amp;tab=answerKey">https://www.nowcoder.com/practice/103dd589fed14457a673c613d8de3841?tpId=40&amp;qru=%2Fta%2Ftsing-kaoyan%2Fquestion-ranking&amp;tab=answerKey</a></p>
<h3 id="代码">代码</h3>
<pre><code class="language-c++">#include &lt;iostream&gt;
#include &lt;cstdio&gt;
#include &lt;string&gt;

using namespace std;

int main()
{
    int num;
    while (cin &gt;&gt; num)
    {
        string result = &quot;&quot;;
        
        while (num != 0)
        {
            int temp = num % 2;
            char num_now = char('0'+temp);
            result = num_now + result;
            num = num / 2;
        }
        
        cout  &lt;&lt; result &lt;&lt; endl;
    }
}
</code></pre>
<h2 id="2-进制转换">2. <strong>进制转换</strong></h2>
<h3 id="题目描述-2"><strong>题目描述</strong></h3>
<p>将一个长度最多为30位数字的十进制非负整数转换为二进制数输出。</p>
<h3 id="要点-2"><strong>要点</strong></h3>
<ol>
<li>
<p>数字长度：https://www.runoob.com/cplusplus/cpp-data-types.html</p>
<table>
<thead>
<tr>
<th>unsigned long int</th>
<th>0 到 18,446,744,073,709,551,615（20位）</th>
</tr>
</thead>
<tbody></tbody>
</table>
<p><strong>超过20位的数字运算就只能通过字符串实现</strong></p>
</li>
<li>
<p>字符串类型计算乘除法的方法：模仿手动计算</p>
</li>
<li>
<p><strong>从第一个非0位开始输出：</strong></p>
<p>设置flag，在第一次遇到非0时将其变为true；</p>
<p>提前获得非0位的编号</p>
</li>
</ol>
<h3 id="提交地址-2">提交地址</h3>
<p><a href="https://www.nowcoder.com/practice/53447aa04f32460aa20ee11d02416e3b?tpId=40&amp;qru=%2Fta%2Ftsing-kaoyan%2Fquestion-ranking&amp;tab=answerKey">https://www.nowcoder.com/practice/53447aa04f32460aa20ee11d02416e3b?tpId=40&amp;qru=%2Fta%2Ftsing-kaoyan%2Fquestion-ranking&amp;tab=answerKey</a></p>
<h3 id="代码-2">代码</h3>
<pre><code class="language-c++">#include &lt;iostream&gt;
#include &lt;cstdio&gt;
#include &lt;string&gt;

using namespace std;

char GetTemp(string num)//取得字符串num的%2结果
{   //num%2结果 = num最后一位%2的结果
    int temp0 = int(num[num.size()-1] - '0') % 2;
    char temp = char(temp0 + '0');
    return temp;
};

string GetNum(string num)//取得字符串num的/2结果
{
    int m = 0;
    string result = num;
    for (int i=0; i&lt;num.size(); i++)
    {   //模仿手动计算除法的过程
        int num_now = int(num[i] - '0') + m*10;
        result[i] = char(num_now / 2 + '0');
        m = num_now % 2;
    }
    
    return result;
};

int main()
{
    string num;
    while (cin &gt;&gt; num)
    {
        string result = &quot;&quot;;
        
        //flag：和num位数相同的全零串
        string flag = num;
        for (int i=0; i&lt;flag.size(); i++)
            flag[i] = '0';
        
        while(num != flag)
        {
            result = GetTemp(num) + result;
            num = GetNum(num);
        }

        //输出：从首个非零位开始
        bool flag2 = false;
        for (int j=0; j&lt;result.size(); j++)
        {
            if (result[j] != '0')
                flag2 = true;
            
            if (flag2 == true)
                cout &lt;&lt; result[j];
        }
        cout &lt;&lt; endl;        
    }
}
</code></pre>
<h2 id="3-十进制vs二进制">3. <strong>十进制VS二进制</strong></h2>
<h3 id="题目描述-3"><strong>题目描述</strong></h3>
<p>对于一个十进制数A，将A转换为二进制数，然后按位逆序排列，再转换为十进制数B，我们称B为A的二进制逆序数。   例如对于十进制数173，它的二进制形式为10101101，逆序排列得到10110101，其十进制数为181，181即为173的二进制逆序数。</p>
<p><strong>注意：一个1000位(即10^999)以内的十进制数。</strong></p>
<h3 id="要点-3"><strong>要点</strong></h3>
<ol>
<li>
<p><strong>法一：字符串类型的加法，乘法，除法，取余</strong></p>
</li>
<li>
<p><strong>法二：大数进制转换</strong></p>
<p>参考：<a href="https://blog.csdn.net/StrongerL/article/details/92702052">https://blog.csdn.net/StrongerL/article/details/92702052</a></p>
</li>
</ol>
<h3 id="提交地址-3">提交地址</h3>
<p><a href="https://www.nowcoder.com/practice/53447aa04f32460aa20ee11d02416e3b?tpId=40&amp;qru=%2Fta%2Ftsing-kaoyan%2Fquestion-ranking&amp;tab=answerKey">https://www.nowcoder.com/practice/53447aa04f32460aa20ee11d02416e3b?tpId=40&amp;qru=%2Fta%2Ftsing-kaoyan%2Fquestion-ranking&amp;tab=answerKey</a></p>
<h3 id="代码-3">代码</h3>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Chapter5数据结构一：5.3 栈]]></title>
        <id>https://Czardas42.github.io/post/chapter5-5.3/</id>
        <link href="https://Czardas42.github.io/post/chapter5-5.3/">
        </link>
        <updated>2021-05-05T07:45:56.000Z</updated>
        <content type="html"><![CDATA[<h2 id="栈的基本操作">栈的基本操作</h2>
<p>只能在栈顶进行操作</p>
<p>重点用于处理逆序问题</p>
<h2 id="1-zero-complexity-transposition逆序输出">1.  Zero-complexity Transposition（逆序输出）</h2>
<h3 id="题目描述"><strong>题目描述</strong></h3>
<p>You are given a sequence of integer numbers. Zero-complexity transposition of the sequence is the reverse of this sequence. Your task is to write a program that prints zero-complexity transposition of the given sequence.</p>
<h3 id="要点"><strong>要点</strong></h3>
<ol>
<li>利用栈的结构完成逆序输出</li>
</ol>
<h3 id="提交地址">提交地址</h3>
<p><a href="https://www.nowcoder.com/practice/c54775799f634c72b447ef31eb36e975?tpId=40&amp;qru=%2Fta%2Ftsing-kaoyan%2Fquestion-ranking&amp;tab=answerKey">https://www.nowcoder.com/practice/c54775799f634c72b447ef31eb36e975?tpId=40&amp;qru=%2Fta%2Ftsing-kaoyan%2Fquestion-ranking&amp;tab=answerKey</a></p>
<h3 id="代码">代码</h3>
<pre><code class="language-c++">#include &lt;iostream&gt;
#include &lt;stack&gt;
#include &lt;cstdio&gt;

using namespace std;

int main()
{
    int count;
    stack&lt;int&gt; record;
    
    while(cin &gt;&gt; count)
    {
        int num;
        for (int i=0; i&lt;count; i++)
        {
            cin &gt;&gt; num;
            record.push(num);
        }
        
        for (int i=0; i&lt;count; i++)
        {
            if (record.empty())
            {
                cout &lt;&lt; record.top() &lt;&lt; endl;
                record.pop();
            }
            else
            {
                cout &lt;&lt; record.top() &lt;&lt; &quot; &quot;;
                record.pop();
            }          
        }    
    }
}
</code></pre>
<h2 id="2-括号序列">2. <strong>括号序列</strong></h2>
<h3 id="题目描述-2"><strong>题目描述</strong></h3>
<p>给出一个仅包含字符'(',')','{','}','['和']',的字符串，判断给出的字符串是否是合法的括号序列<br>
括号必须以正确的顺序关闭，&quot;()&quot;和&quot;()[]{}&quot;都是合法的括号序列，但&quot;(]&quot;和&quot;([)]&quot;不合法。</p>
<h3 id="要点-2"><strong>要点</strong></h3>
<ol>
<li>利用栈的结构完成序号匹配（思想参考编译原理）</li>
<li>若符合规则，就将一对符号弹出</li>
</ol>
<h3 id="提交地址-2">提交地址</h3>
<p><a href="https://www.nowcoder.com/practice/6235a76b1e404f748f7c820583125c50?tpId=8&amp;qru=%2Fta%2Ftsing-kaoyan%2Fquestion-ranking&amp;tab=answerKey">https://www.nowcoder.com/practice/6235a76b1e404f748f7c820583125c50?tpId=8&amp;qru=%2Fta%2Ftsing-kaoyan%2Fquestion-ranking&amp;tab=answerKey</a></p>
<h3 id="代码-2">代码</h3>
<pre><code class="language-c++">class Solution {
public:
    /**
     * 
     * @param s string字符串 
     * @return bool布尔型
     */
    bool isValid(string s) {
        // write code here
        stack&lt;char&gt; record;
        for (int i=0; i&lt;s.size(); i++)
        {
            int temp = s[i];
            if (!record.empty())
            {                
                int symbol = record.top();
                if (  (temp==')' &amp;&amp; symbol=='(')
                    ||(temp==']' &amp;&amp; symbol=='[')
                    ||(temp=='}' &amp;&amp; symbol=='{')
                   )
                {
                    record.pop();
                }
                else
                {
                    record.push(temp);
                }
                   
            }
            else
            {
                record.push(temp);
            }           
        }
        
        if (record.empty())
            return true;
        else
            return false;
    }
};
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Chapter5数据结构一：5.2 队列]]></title>
        <id>https://Czardas42.github.io/post/chapter5_5.2/</id>
        <link href="https://Czardas42.github.io/post/chapter5_5.2/">
        </link>
        <updated>2021-05-05T07:45:56.000Z</updated>
        <content type="html"><![CDATA[<h2 id="队列基本操作">队列基本操作</h2>
<h2 id="1-约瑟夫问题">1. <strong>约瑟夫问题</strong></h2>
<h3 id="题目描述"><strong>题目描述</strong></h3>
<p>编号为 1 到 n的 n个人围成一圈。从编号为 11 的人开始报数，报到 m的人离开。</p>
<p>下一个人继续从 11 开始报数。</p>
<p>n-1轮结束以后，只剩下一个人，问最后留下的这个人编号是多少？</p>
<h3 id="要点"><strong>要点</strong></h3>
<ol>
<li>利用队列模拟的思想</li>
<li>不需循环列表也可以完成</li>
</ol>
<h3 id="提交地址">提交地址</h3>
<p><a href="https://www.nowcoder.com/practice/41c399fdb6004b31a6cbb047c641ed8a?tpId=196&amp;qru=%2Fta%2Ftsing-kaoyan%2Fquestion-ranking&amp;tab=answerKey">https://www.nowcoder.com/practice/41c399fdb6004b31a6cbb047c641ed8a?tpId=196&amp;qru=%2Fta%2Ftsing-kaoyan%2Fquestion-ranking&amp;tab=answerKey</a></p>
<h3 id="代码">代码</h3>
<pre><code class="language-c++">class Solution {
public:
    /**
     * @param n int整型 
     * @param m int整型 
     * @return int整型
     */
    int ysf(int n, int m) {
        // write code here
        queue&lt;int&gt; line;
        //全部入队
        for (int i=1; i&lt;=n; i++)
        {
            line.push(i);
        }
        //开始模拟
        for (int j=1; j&lt;n; j++)//n-1轮游戏
        {
            for (int i=1; i&lt;m; i++)
            {
                int temp = line.front();
                line.pop();
                line.push(temp);
            }
            line.pop();
        }
        
        return line.front();
    }
};
</code></pre>
<h2 id="2-猫狗收容所">2. <strong>猫狗收容所</strong></h2>
<h3 id="题目描述-2"><strong>题目描述</strong></h3>
<p>有家动物收容所只收留猫和狗，但有特殊的收养规则，收养人有两种收养方式，第一种为直接收养所有动物中最早进入收容所的，第二种为选择收养的动物类型（猫或狗），并收养该种动物中最早进入收容所的。</p>
<p>给定一个操作序列int[][2] ope(C++中为vector<vector>)代表所有事件。若第一个元素为1，则代表有动物进入收容所，第二个元素为动物的编号，正数代表狗，负数代表猫；若第一个元素为2，则代表有人收养动物，第二个元素若为0，则采取第一种收养方式，若为1，则指定收养狗，若为-1则指定收养猫。请按顺序返回收养的序列。若出现不合法的操作，即没有可以符合领养要求的动物，则将这次领养操作忽略。</p>
<h3 id="要点-2"><strong>要点</strong></h3>
<ol>
<li>利用两个队列分别记录猫狗</li>
<li>animal结构体：<strong>记录type和时间tag</strong></li>
<li><strong>注意讨论收养时猫狗列表可能为空的情况</strong></li>
</ol>
<h3 id="提交地址-2">提交地址</h3>
<p><a href="https://www.nowcoder.com/practice/6235a76b1e404f748f7c820583125c50?tpId=8&amp;qru=%2Fta%2Ftsing-kaoyan%2Fquestion-ranking&amp;tab=answerKey">https://www.nowcoder.com/practice/6235a76b1e404f748f7c820583125c50?tpId=8&amp;qru=%2Fta%2Ftsing-kaoyan%2Fquestion-ranking&amp;tab=answerKey</a></p>
<h3 id="代码-2">代码</h3>
<pre><code class="language-c++">class CatDogAsylum {
public:
    struct animal
    {
        int type;
        int order;
        animal(int t, int o)
        {
            type = t;
            order = o;
        }
    };
    vector&lt;int&gt; asylum(vector&lt;vector&lt;int&gt; &gt; ope) 
    {
        // write code here
        queue&lt;animal&gt; cats, dogs;
        int order = 0;
        vector&lt;int&gt; result;
        for (int i=0; i&lt;ope.size(); i++)
        {
            vector&lt;int&gt; item = ope[i];
            int method = item[0];
            int type = item[1];
            
            if (method == 1) //有动物进入
            {
                if (type &gt; 0) //狗
                {
                    order++;
                    dogs.push(animal(type, order));
                }
                else if (type &lt; 0) //猫
                {
                    order++;
                    cats.push(animal(type, order));
                }
            }
            else if (method == 2) //有人收养
            {
                animal dog = dogs.front();
                animal cat = cats.front();
                
                if (type == 0) //直接收养最早进入的
                {
                    if (dog.order&lt;cat.order &amp;&amp; !dogs.empty() &amp;&amp; !cats.empty())
                    {
                        result.push_back(dog.type);
                        dogs.pop();
                    }
                    else if (dog.order&gt;cat.order &amp;&amp; !dogs.empty() &amp;&amp; !cats.empty())
                    {
                        result.push_back(cat.type);
                        cats.pop();
                    }
                    else if (dogs.empty())
                    {
                        result.push_back(cat.type);
                        cats.pop();
                    }
                    else if (cats.empty())
                    {
                        result.push_back(dog.type);
                        dogs.pop();
                    }
                }
                else if (type == 1 &amp;&amp; !dogs.empty()) //指定收养狗
                {
                    result.push_back(dog.type);
                    dogs.pop();
                }
                else if (type == -1 &amp;&amp; !cats.empty()) //指定收养猫
                {
                    result.push_back(cat.type);
                    cats.pop();
                }
            }
        }
        return result;
    }
};
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Chapter5数据结构一：5.1 向量]]></title>
        <id>https://Czardas42.github.io/post/chapter5_5.1/</id>
        <link href="https://Czardas42.github.io/post/chapter5_5.1/">
        </link>
        <updated>2021-05-05T07:44:06.000Z</updated>
        <content type="html"><![CDATA[<h2 id="向量基本操作">向量基本操作</h2>
<h2 id="完数与盈数"><strong>完数与盈数</strong></h2>
<h3 id="题目描述"><strong>题目描述</strong></h3>
<p>一个数如果恰好等于它的各因子（该数本身除外）子和，如：6=3+2+1，则称其为“完数”；若因子之和大于该数，则称其为“盈数”。求出2 到60 之间所有“完数”和“盈数”，并以如下形式输出： E: e1 e2 e3 ......(ei 为完数) G: g1 g2 g3 ......(gi 为盈数)</p>
<h3 id="要点"><strong>要点</strong></h3>
<ol>
<li><code>vector.pop_back()</code>是弹出最后一个元素</li>
<li>vector遍历方法：<code>vector.size()</code></li>
<li>求因子的方法：<code>num % i == 0</code></li>
</ol>
<h3 id="提交地址">提交地址</h3>
<p><a href="https://www.nowcoder.com/practice/df0d850e41894d06a165bf445ec8a8b4?tpId=40&amp;qru=%2Fta%2Ftsing-kaoyan%2Fquestion-ranking&amp;tab=answerKey">https://www.nowcoder.com/practice/df0d850e41894d06a165bf445ec8a8b4?tpId=40&amp;qru=%2Fta%2Ftsing-kaoyan%2Fquestion-ranking&amp;tab=answerKey</a></p>
<h3 id="代码">代码</h3>
<pre><code class="language-c++">#include &lt;iostream&gt;
#include &lt;cstdio&gt;
#include &lt;vector&gt;

using namespace std;

int Sum(int num)
{
    int sum = 0;
    for (int i=1; i&lt;num; i++)
    {
        if (num % i == 0)
        {
            sum += i;
        }
    }
    return sum;
};

int main()
{
    vector&lt;int&gt; E, G;
    for (int i=2; i&lt;=60; i++)
    {
        int sum = Sum(i);
        if (i == sum)
        {   
            E.push_back(i);
        }
        else if (i &lt; sum)
        {
            G.push_back(i);
        }
    }
    //输出E
    cout &lt;&lt; &quot;E:&quot;;
    for (int j=0; j&lt;E.size(); j++)
    {
        cout &lt;&lt; &quot; &quot; &lt;&lt; E[j];
    }
    //输出G
    cout &lt;&lt; &quot; G:&quot;;
    for (int j=0; j&lt;G.size(); j++)
    {
        cout &lt;&lt; &quot; &quot; &lt;&lt; G[j];
    }
    cout &lt;&lt; endl;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Chapter4字符串：4.3 字符串匹配]]></title>
        <id>https://Czardas42.github.io/post/chapter4_4.3/</id>
        <link href="https://Czardas42.github.io/post/chapter4_4.3/">
        </link>
        <updated>2021-05-05T07:40:00.000Z</updated>
        <content type="html"><![CDATA[<h2 id="kmp算法">KMP算法</h2>
<h2 id="1-string-matching"><strong>1. String Matching</strong></h2>
<h3 id="题目描述"><strong>题目描述</strong></h3>
<p>Finding all occurrences of a pattern in a text is a problem that arises frequently in text-editing programs.   Typically,the text is a document being edited,and the pattern searched for is a particular word supplied by the user.    We assume that the text is an array T[1..n] of length n and that the pattern is an array P[1..m] of length m&lt;=n.We further assume that the elements of P and T are all alphabets(∑={a,b...,z}).The character arrays P and T are often called strings of characters.    We say that pattern P occurs with shift s in the text T if 0&lt;=s&lt;=n and T[s+1..s+m] = P[1..m](that is if T[s+j]=P[j],for 1&lt;=j&lt;=m).    If P occurs with shift s in T,then we call s a valid shift;otherwise,we calls a invalid shift.   Your task is to calculate the number of vald shifts for the given text T and p attern P.</p>
<h3 id="要点"><strong>要点</strong></h3>
<ol>
<li>
<p><strong>KMP算法</strong>，nextTable构建方式 <strong>（两个函数）</strong></p>
</li>
<li>
<p>返回第一个匹配子串/返回全部匹配子串个数</p>
</li>
</ol>
<h3 id="提交地址">提交地址</h3>
<p><a href="https://www.nowcoder.com/practice/00438b0bc9384ceeb65613346b42e88a?tpId=40&amp;qru=%2Fta%2Ftsing-kaoyan%2Fquestion-ranking&amp;tab=answerKey">https://www.nowcoder.com/practice/00438b0bc9384ceeb65613346b42e88a?tpId=40&amp;qru=%2Fta%2Ftsing-kaoyan%2Fquestion-ranking&amp;tab=answerKey</a></p>
<h3 id="代码">代码</h3>
<pre><code class="language-c++">#include &lt;iostream&gt;
#include &lt;cstdio&gt;
#include &lt;string&gt;

using namespace std;

int text[1000000];
int pattern[1000000];
int nextTable[1000000];

void getNextTable(string pattern)
{
    int m = pattern.size();
    nextTable[0] = -1;
    int i=0, j=-1;
    while(i &lt; m)
    {
        if (j == -1 || pattern[i] == pattern[j])
        {
            i++;
            j++;
            nextTable[i] = j;
        }
        else
        {
            j = nextTable[j];
        }
    }
};

int kmp(string text, string pattern)
{
    int m = text.size();
    int n = pattern.size();
    getNextTable(pattern);
    
    int count = 0;
    int i = 0;
    int j = 0;

    while(i &lt; m)
    {
        //匹配
        if ((j == -1) || (text[i] == pattern[j]))
        {
            i++;
            j++;
        }
        else
        {
            j = nextTable[j];
        }
        
        //判断
        if(j == n)
        {
            count++;
            j = nextTable[j];
        }
    }
    
    return count;
};

int main()
{
    string text, pattern;
    while(cin &gt;&gt; text &gt;&gt; pattern)
    {
        int count = kmp(text,pattern);
        cout &lt;&lt; count &lt;&lt; endl;
    }
    return 0;
}
</code></pre>
<h2 id="2-字符串匹配">2. 字符串匹配</h2>
<h3 id="题目描述-2"><strong>题目描述</strong></h3>
<p>读入数据string[ ]，然后读入一个短字符串。要求查找string[ ]中和短字符串的所有匹配，输出行号、匹配字符串。匹配时不区分大小写，并且可以有一个用中括号表示的模式匹配。如“aa[123]bb”，就是说aa1bb、aa2bb、aa3bb都算匹配。</p>
<h3 id="要点-2"><strong>要点</strong></h3>
<ol>
<li>
<p>注意：题目要求的是完全匹配，即长度完全一样，忽略大小写</p>
</li>
<li>
<p>可以使用<strong>正则表达式</strong></p>
<p><code>#include &lt;regex&gt;</code></p>
<p><code>regex r(st[0], regex::icase); // regex::icase 不区分大小写,建立正则表达式</code></p>
<p><code>regex_match(st[i], r)</code></p>
</li>
</ol>
<h3 id="提交地址-2">提交地址</h3>
<p><a href="https://www.nowcoder.com/practice/fbdc522ef958455687654b38a4ca01e0?tpId=40&amp;qru=%2Fta%2Ftsing-kaoyan%2Fquestion-ranking&amp;tab=answerKey">https://www.nowcoder.com/practice/fbdc522ef958455687654b38a4ca01e0?tpId=40&amp;qru=%2Fta%2Ftsing-kaoyan%2Fquestion-ranking&amp;tab=answerKey</a></p>
<h3 id="代码-2">代码</h3>
<pre><code class="language-C++">#include &lt;cstdio&gt;
#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;regex&gt;

using namespace std;
string st[1001];

int main () {
    int n;
    scanf(&quot;%d &quot;, &amp;n);
    for (int i=1; i&lt;=n; ++i)
        getline(cin, st[i]);
    getline(cin, st[0]);
    regex r(st[0], regex::icase);  // regex::icase 不区分大小写
    for (int i=1; i&lt;=n; ++i)
        if (regex_match(st[i], r))  // 这是完全匹配，部分匹配用regex_search
            cout &lt;&lt; i &lt;&lt; ' ' &lt;&lt; st[i] &lt;&lt; endl;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[VPC对等连接]]></title>
        <id>https://Czardas42.github.io/post/vpc_p2p/</id>
        <link href="https://Czardas42.github.io/post/vpc_p2p/">
        </link>
        <updated>2021-05-05T07:33:40.000Z</updated>
        <content type="html"><![CDATA[<h4 id="概念">概念</h4>
<p>对等连接是指两个VPC之间的网络连接。可以使用私有IP地址在两个VPC之间进行通信，就像两个VPC在同一个网络中一样。同一区域内，可以在自己的VPC之间创建对等连接，也可以在自己的VPC与其他帐户的VPC之间创建对等连接。不同区域间的VPC之间不能创建对等连接。</p>
<figure data-type="image" tabindex="1"><img src="https://Czardas42.github.io//post-images/1620200083815.png" alt="" loading="lazy"></figure>
<h4 id="约束与限制">约束与限制</h4>
<ul>
<li>有重叠子网网段的VPC建立的对等连接，可能不生效。</li>
<li>两个VPC之间不能同时建立多个VPC对等连接。</li>
<li>不同区域的VPC不能创建对等连接。</li>
</ul>
<h4 id="路由配置">路由配置</h4>
<p>如图1所示，VPC1和VPC2需要通过添加路由来建立对等关系。对等连接路由配置如图2所示，配置完成后，VPC1和VPC2就建立了对等关系，可以相互通信。</p>
<p>指向整个VPC的对等连接的路由配置，目的地址为对端VPC的CIDR，下一跳地址为对等连接ID。</p>
<blockquote>
<p>无类域间路由（Classless Inter-Domain Routing，CIDR）可以将路由集中起来，在路由表中更灵活地定义地址。它不区分 A 类、B 类、C 类地址，而是使用 CIDR 前缀的值指定地址中作为网络 ID 的位数。</p>
</blockquote>
<figure data-type="image" tabindex="2"><img src="https://Czardas42.github.io//post-images/1620200105962.png" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="3"><img src="https://Czardas42.github.io//post-images/1620200120934.png" alt="" loading="lazy"></figure>
<h4 id="操作流程以跨用户为例">操作流程（以跨用户为例）</h4>
<p>跨帐户创建VPC对等连接时，一端VPC发起创建对等连接请求，对等连接状态为待接受。待对方接受该创建请求后，对等连接状态变为已接受，请求方和接受方须分别配置对等连接路由信息，才能使两个VPC互通。</p>
<figure data-type="image" tabindex="4"><img src="https://Czardas42.github.io//post-images/1620200145251.png" alt="" loading="lazy"></figure>
<p><a href="https://support.huaweicloud.com/usermanual-vpc/zh-cn_topic_0046655038.html">https://support.huaweicloud.com/usermanual-vpc/zh-cn_topic_0046655038.html</a></p>
<p><u><strong>实验过程中搭建K8s集群所用到VPC对等连接操作实例</strong></u></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[OpenFaaS]]></title>
        <id>https://Czardas42.github.io/post/openfaas/</id>
        <link href="https://Czardas42.github.io/post/openfaas/">
        </link>
        <updated>2021-05-05T07:30:28.000Z</updated>
        <content type="html"><![CDATA[<h4 id="layers-工作流程">Layers &amp; 工作流程</h4>
<figure data-type="image" tabindex="1"><img src="https://Czardas42.github.io//post-images/1620199885176.png" alt="" loading="lazy"></figure>
<p><strong>无服务器函数变得简单</strong></p>
<ul>
<li>推荐的部署OpenFaaS平台都是Kubernetes</li>
<li>OpenFaaS Cloud建立在OpenFaaS的基础上，可通过GitHub.com或自行托管的GitLab交付GitOps</li>
<li>NATS提供异步执行和排队</li>
<li>Prometheus提供指标并通过AlertManager启用自动缩放</li>
<li>容器注册表包含每个可以通过API部署在OpenFaaS上的不可变工件</li>
</ul>
<figure data-type="image" tabindex="2"><img src="https://Czardas42.github.io//post-images/1620199913601.png" alt="" loading="lazy"></figure>
<p>可以通过其REST API，CLI或UI来访问网关。所有服务或功能都会暴露默认路由，但是自定义域也可以用于每个端点。</p>
<h4 id="gateway">Gateway</h4>
<p>OpenFaaS的Gateway是一个golang实现的请求转发的网关，在这个网关服务中，主要有以下几个功能：</p>
<ul>
<li>UI</li>
<li>部署函数</li>
<li>监控</li>
<li>自动伸缩</li>
</ul>
<figure data-type="image" tabindex="3"><img src="https://Czardas42.github.io//post-images/1620199930497.png" alt="" loading="lazy"></figure>
<p>从图中可以发现，当Gateway作为一个入口，当CLI或者web页面发来要部署或者调用一个函数的时候，Gateway会将请求转发给Provider，同时会将监控指标发给Prometheus。AlterManager会根据需求，调用API自动伸缩函数。</p>
<p>Gateway是OpenFaaS最为重要的一个组件。Gateway本质上就是一个rest转发服务，一个一个的handler，每个模块之间的耦合性不是很高，可以很容易的去拆卸，自定义实现相应的模块。</p>
<blockquote>
<p>源码解读：https://zhuanlan.zhihu.com/p/41056766</p>
</blockquote>
<h4 id="watchdog">watchdog</h4>
<p>watchdog提供了一个外部世界和函数之间的非托管的通用接口。它的工作是收集从API网关来的HTTP请求，然后调用程序。watchdog是一个小型的Golang服务</p>
<p>下图展示了它是如何工作的：</p>
<p>一个小型的web服务，可以为每个传入的HTTP请求分配所需要的进程。</p>
<figure data-type="image" tabindex="4"><img src="https://Czardas42.github.io//post-images/1620199949953.png" alt="" loading="lazy"></figure>
<p>每个函数都需要嵌入这个二进制文件并将其作为<code>ENTRYPOINT</code> 或 <code>CMD</code>，实际上是把它作为容器的初始化进程。一旦进程被创建分支，watchdog就会通过<code>stdin</code> 传递HTTP请求并从<code>stdout</code>中读取HTTP响应。这意味着程序无需知道web和HTTP的任何信息。</p>
<h4 id="of-watchdog">of-watchdog</h4>
<p><code>of-watchdog</code>项目于2017年10月启动，该组件适合在生产中使用，并且是<a href="https://github.com/openfaas">openfaas</a> GitHub组织的一部分。</p>
<p>of-watchdog是函数和微服务之间的<strong>反向代理</strong>。</p>
<p>of-watchdog的默认模式是http模式，部署服务时of-watchdog会fork一个进程（假设为进程A），进程A会监听一个端口，of-wahtchdog收到的所有请求都会转发到进程A监听的端口，HTTP模式的官方架构图如下：</p>
<figure data-type="image" tabindex="5"><img src="https://Czardas42.github.io//post-images/1620199965913.png" alt="" loading="lazy"></figure>
<p>如图所示，代码是在右侧的child里面执行的，这个child从3000端口收到of-watchdog转发过来的外部请求，然后内部处理掉。</p>
<p>主要区别在于：经典的看门狗会为每个请求派生一个进程，以提供最高级别的可移植性，<strong>但是of-watchdog启用了一种<code>http</code>模式，在该模式下，该进程可以重复使用，以抵消分叉的延迟</strong>。</p>
<p>of-watchdog的优点：</p>
<ul>
<li>第一，并发性能和吞吐量最优；</li>
<li>第二，相比watchdog，对内存的使用更高效；</li>
<li>第三，建好的数据库连接可以反复使用；</li>
<li>第四，容器操作系统的临时文件夹(/tmp/目录)，是所有请求共用的，例如可以做临时缓存用</li>
</ul>
<h4 id="函数调用流程">函数调用流程</h4>
<p><a href="https://blog.csdn.net/weixin_38616705/article/details/107385293">https://blog.csdn.net/weixin_38616705/article/details/107385293</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Kubernetes]]></title>
        <id>https://Czardas42.github.io/post/kubernetes/</id>
        <link href="https://Czardas42.github.io/post/kubernetes/">
        </link>
        <updated>2021-05-05T07:24:49.000Z</updated>
        <content type="html"><![CDATA[<h3 id="整体架构">整体架构</h3>
<figure data-type="image" tabindex="1"><img src="https://Czardas42.github.io//post-images/1620199629518.png" alt="" loading="lazy"></figure>
<p>Kubernetes属于主从分布式架构，主要由Master Node和Worker Node组成，以及包括客户端命令行工具kubectl和其它附加项。</p>
<ul>
<li>
<p>**Master Node：**作为控制节点，对集群进行调度管理；Master Node由API Server、Scheduler、Cluster State Store和Controller-Manger Server所组成</p>
</li>
<li>
<p>**Worker Node：**作为真正的工作节点，运行业务应用的容器；Worker Node包含kubelet、kube proxy和Container Runtime</p>
</li>
<li>
<p>**kubectl：**用于通过命令行与API Server进行交互，而对Kubernetes进行操作，实现在集群中进行各种资源的增删改查等操作</p>
</li>
</ul>
<h3 id="master-node">Master Node</h3>
<figure data-type="image" tabindex="2"><img src="https://Czardas42.github.io//post-images/1620199664616.png" alt="" loading="lazy"></figure>
<h4 id="1-api-serverapi服务器">1. <strong>API Server（API服务器）</strong></h4>
<p>API Server主要用来处理REST的操作，确保它们生效，并执行相关业务逻辑，以及更新etcd（或者其他存储）中的相关对象。</p>
<h4 id="2-cluster-state-store集群状态存储">2. <strong>Cluster state store（集群状态存储）</strong></h4>
<p>Kubernetes默认使用etcd作为集群整体存储。集群的所有状态都存储在etcd实例中，并具有监控的能力，因此当etcd中的信息发生变化时，就能够快速的通知集群中相关的组件。</p>
<h4 id="3-controller-manager-server控制管理服务器">3. <strong>Controller-Manager Server（控制管理服务器）</strong></h4>
<p>Controller-Manager Serve用于执行大部分的集群层次的功能，它既执行生命周期功能(例如：命名空间创建和生命周期、事件垃圾收集、已终止垃圾收集、级联删除垃圾收集、node垃圾收集)，也执行API业务逻辑（例如：pod的弹性扩容）。</p>
<h4 id="4-scheduler调度器">4. <strong>Scheduler（调度器）</strong></h4>
<p>scheduler组件为容器自动选择运行的主机。依据请求资源的可用性，服务请求的质量等约束条件，scheduler监控未绑定的pod，并将其绑定至特定的node节点。</p>
<h3 id="worker-node">Worker Node</h3>
<figure data-type="image" tabindex="3"><img src="https://Czardas42.github.io//post-images/1620199680953.png" alt="" loading="lazy"></figure>
<h4 id="1-kubelet">1. kubelet</h4>
<p>kubelet负责管理pods和它们上面的容器，images镜像、volumes、etc。</p>
<h4 id="2-kube-proxy">2. kube-proxy</h4>
<p>kube proxy负责为Pod创建代理服务；引到访问至服务；并实现服务到Pod的路由和转发，以及通过应用的负载均衡。每一个Node都会运行一个kube-proxy，kube proxy通过iptables规则引导访问至服务IP，并将重定向至正确的后端应用，通过这种方式kube-proxy提供了一个高可用的负载均衡解决方案。</p>
<h4 id="3-container-runtime">3. Container Runtime</h4>
<p>每一个Node都会运行一个Container Runtime，其负责下载镜像和运行容器。kubelet使用Unix socket之上的gRPC框架与容器运行时进行通信，kubelet作为客户端，而CRI shim作为服务器。</p>
<figure data-type="image" tabindex="4"><img src="https://Czardas42.github.io//post-images/1620199694750.png" alt="" loading="lazy"></figure>
<h4 id="4-fluentd-elasticsearch">4. <strong>Fluentd-elasticsearch</strong></h4>
<p>提供集群日志采集、存储与查询</p>
<h3 id="pod">Pod</h3>
<h4 id="1-定义">1. 定义</h4>
<p>**Pod是可以在 Kubernetes 中创建和管理的、最小的可部署的计算单元。**Pod的设计理念是支持多个容器在一个Pod中共享网络地址和文件系统，可以通过进程间通信和文件共享这种简单高效的方式组合完成服务。</p>
<h4 id="2-pod的调度方法">2. Pod的调度方法</h4>
<p>Scheduler负责根据调度策略自动将Pod部署到合适Node中，调度策略分为预选策略和优选策略，Pod的整个调度过程分为两步：</p>
<p>1）预选Node：遍历集群中所有的Node，按照具体的预选策略筛选出符合要求的Node列表。如没有Node符合预选策略规则，该Pod就会被挂起，直到集群中出现符合要求的Node。</p>
<p>2）优选Node：预选Node列表的基础上，按照优选策略为待选的Node进行打分和排序，从中获取最优Node。</p>
<h3 id="deployment-service-job">Deployment &amp; Service &amp; Job</h3>
<h4 id="1-部署deployment">1. 部署(Deployment)</h4>
<p>部署表示用户对K8s集群的一次更新操作。可以是创建一个新的服务，更新一个新的服务，也可以是滚动升级一个服务。滚动升级一个服务，实际是创建一个新的RS，然后逐渐将新RS中副本数增加到理想状态，将旧RS中的副本数减小到0的复合操作。</p>
<p><u><strong>删除pod的正确方法</strong></u></p>
<h4 id="2-服务service">2. 服务（Service）</h4>
<p>一个Pod只是一个运行服务的实例，随时可能在一个节点上停止，在另一个节点以一个新的IP启动一个新的Pod，因此不能以确定的IP和端口号提供服务。要稳定地提供服务需要服务发现和负载均衡能力。服务发现完成的工作，是针对客户端访问的服务，找到对应的的后端服务实例。在K8s集群中，客户端需要访问的服务就是Service对象。每个Service会对应一个集群内部有效的虚拟IP，集群内部通过虚拟IP访问一个服务。</p>
<p><u><strong>结合Prometheus部署</strong></u></p>
<h4 id="3-任务job">3. 任务（Job）</h4>
<p>Job是K8s用来控制批处理型任务的API对象。Job 会创建一个或者多个 Pods，并将继续重试 Pods 的执行，直到指定数量的 Pods 成功终止。 随着 Pods 成功结束，Job 跟踪记录成功完成的 Pods 个数。 当数量达到指定的成功个数阈值时，任务（即 Job）结束。 删除 Job 的操作会清除所创建的全部 Pods。</p>
]]></content>
    </entry>
</feed>