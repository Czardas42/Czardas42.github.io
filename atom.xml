<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://Czardas42.github.io/</id>
    <title>Czardas</title>
    <updated>2021-05-24T01:21:15.813Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://Czardas42.github.io/"/>
    <link rel="self" href="https://Czardas42.github.io/atom.xml"/>
    <subtitle>世界那么大，我想去看看</subtitle>
    <logo>https://Czardas42.github.io/images/avatar.png</logo>
    <icon>https://Czardas42.github.io/favicon.ico</icon>
    <rights>All rights reserved 2021, Czardas</rights>
    <entry>
        <title type="html"><![CDATA[Chapter9搜索：9.2DFS]]></title>
        <id>https://Czardas42.github.io/post/chapter9_9.2/</id>
        <link href="https://Czardas42.github.io/post/chapter9_9.2/">
        </link>
        <updated>2021-05-24T01:20:14.000Z</updated>
        <content type="html"><![CDATA[<h2 id="dfs">DFS</h2>
<p>常用于搜索存在问题</p>
<p>形式化表示问题，设计合适的状态表示</p>
<p>将搜索问题转化为针对状态的搜索</p>
<p>适当的标记，避免重复搜索</p>
<h2 id="1-a-knights-journey">1.  <strong>A Knight's Journey</strong></h2>
<h3 id="题目描述"><strong>题目描述</strong></h3>
<p>The knight is getting bored of seeing the same black and white squares again and again and has decided to make a journey<br>
around the world. Whenever a knight moves, it is two squares in one direction and one square perpendicular to this. The world of a knight is the chessboard he is living on. Our knight lives on a chessboard that has a smaller area than a regular 8 * 8 board, but it is still rectangular. Can you help this adventurous knight to make travel plans?</p>
<h3 id="要点">要点</h3>
<ol>
<li>
<p><code>memset</code>头文件是<code>&lt;cstring&gt;</code></p>
</li>
<li>
<p>DFS用递归即可,使用<code>bool</code>型函数</p>
</li>
<li>
<p>基本步骤：</p>
<p>初始化，判断终止输出结果 / 计算子节点+合法判断+递归    外部返回</p>
</li>
<li>
<p>visit标记数组，应用递归的前后需要标记、取消标记</p>
</li>
</ol>
<h3 id="提交地址">提交地址</h3>
<p>http://poj.org/problem?id=2488</p>
<h3 id="代码">代码</h3>
<pre><code class="language-c++">#include &lt;iostream&gt;
#include &lt;cstdio&gt;
#include &lt;string&gt;
#include &lt;cstring&gt;

using namespace std;

int p, q; //size
bool visit[30][30]; //record


bool DFS(int x, int y, int step, string ans)
{
	int move[8][2] = {
	{-1, -2}, {1, -2}, {-2, -1}, {2, -1}, {-2, 1}, {2, 1}, {-1, 2}, {1, 2}
	};

	//cout judge
	if (step == p * q)
	{
		cout &lt;&lt; ans &lt;&lt; endl &lt;&lt; endl;
		return true;
	}
	else
	{
		for (int i = 0; i &lt; 8; i++)
		{
			int nx = x + move[i][0];
			int ny = y + move[i][1];
			char col = char(ny + 'A');
			char row = char(nx + '1');

			if (nx &lt; 0 || nx &gt;= p || ny &lt; 0 || ny &gt;= q || visit[nx][ny]) {
				continue;
			}
			visit[nx][ny] = true;
			//这里不可以用ans=ans + col + row！！！
			if (DFS(nx, ny, step + 1, ans + col + row))
			{
				return true;
			}

			visit[nx][ny] = false;

			/*
			if (0 &lt;= nx &amp;&amp; nx &lt; p &amp;&amp; 0 &lt;= ny &amp;&amp; ny &lt; q &amp;&amp; !visit[nx][ny])
			{

			}*/
		}
	}

	return false;
}

int main()
{
	int count = 0;
	cin &gt;&gt; count;
	for (int i=1; i&lt;=count; i++)
	{
		cin &gt;&gt; p &gt;&gt; q;

		memset(visit, false, sizeof(visit));
		string ans = &quot;A1&quot;;
		visit[0][0] = true;

		cout &lt;&lt; &quot;Scenario #&quot; &lt;&lt; i &lt;&lt; &quot;:&quot; &lt;&lt;endl;
		if (!DFS(0, 0, 1, ans))
			cout &lt;&lt; &quot;impossible&quot; &lt;&lt; endl &lt;&lt; endl;

	}
	return 0;
}
</code></pre>
<h2 id="2-square">2.  **<strong>Square</strong></h2>
<h3 id="题目描述-2"><strong>题目描述</strong></h3>
<p>Given a set of sticks of various lengths, is it possible to join them end-to-end to form a square?</p>
<h3 id="要点-2"><strong>要点</strong></h3>
<ol>
<li>DFS函数过程</li>
<li>问题状态的三元组表示（现有长度，已完成边数，当前根数）</li>
<li>优化条件：总长度整除四、单根长度小于边长、降序排列......</li>
<li>注意递归的参数，每完成一条边要从0开始重新遍历</li>
</ol>
<h3 id="提交地址-2">提交地址</h3>
<p>http://poj.org/problem?id=2362</p>
<h3 id="代码-2">代码</h3>
<pre><code class="language-c++">#include &lt;iostream&gt;
#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;string&gt;
#include &lt;algorithm&gt;

using namespace std;

int sticks[20];
int side_length;
int num;
bool visit[20];

bool Compare(int a, int b)
{
	return a &gt; b;
}

bool DFS(int length_now, int side_complete, int stick_now)
{
	if (side_complete == 3)
		return true;
	else
	{
		int sample = 0;
		for (int i = stick_now; i &lt; num; i++)
		{
			int length_stick = sticks[i];
			int length_temp = length_now + length_stick;

			if (!visit[i] &amp;&amp; length_temp &lt;= side_length &amp;&amp; sticks[i] != sample)
			{
				visit[i] = true;

				if (length_temp == side_length)
				{
					if (DFS(0, side_complete + 1, 0)) //从0开始重新遍历
						return true;
					else
						sample = sticks[i];
				}
				else if (length_temp &lt; side_length)
				{
					if (DFS(length_temp, side_complete, i + 1))
						return true;
					else
						sample = sticks[i];
				}

				visit[i] = false;
			}
		}
	}
	return false;

}

int main()
{
	int count = 0;
	cin &gt;&gt; count;
	while (count--)
	{
		memset(sticks, 0, sizeof(sticks));
		memset(visit, false, sizeof(visit));
		int sum=0;
		cin &gt;&gt; num;
		for (int i = 0; i &lt; num; i++)
		{
			cin &gt;&gt; sticks[i];
			sum += sticks[i];
		}

		side_length = sum / 4;

		if (sum % 4 != 0)
		{
			cout &lt;&lt; &quot;no\n&quot;;
			continue;
		}

		sort(sticks, sticks + num, Compare);
		if (sticks[0] &gt; side_length)
		{
			cout &lt;&lt; &quot;no\n&quot;;
			continue;
		}


		if (DFS(0, 0, 0))
			cout &lt;&lt; &quot;yes\n&quot;;
		else
			cout &lt;&lt; &quot;no\n&quot;;
	}
	return 0;
}
</code></pre>
<h2 id="3-神奇的口袋">3.  神奇的口袋</h2>
<h3 id="题目描述-3"><strong>题目描述</strong></h3>
<p>有一个神奇的口袋，总的容积是40，用这个口袋可以变出一些物品，这些物品的总体积必须是40。John现在有n个想要得到的物品，每个物品的体积分别是a1，a2……an。John可以从这些物品中选择一些，如果选出的物体的总体积是40，那么利用这个神奇的口袋，John就可以得到这些物品。现在的问题是，John有多少种不同的选择物品的方式。</p>
<h3 id="要点-3"><strong>要点</strong></h3>
<p>此题求解的个数</p>
<p>把<code>if return</code>结构换为直接的递归求解即可</p>
<h3 id="提交地址-3">提交地址</h3>
<p>https://www.nowcoder.com/practice/9aaea0b82623466a8b29a9f1a00b5d35?tpId=40&amp;tqId=21390&amp;rp=1&amp;ru=%2Fta%2Fkaoyan&amp;qru=%2Fta%2Fkaoyan%2Fquestion-ranking&amp;tab=answerKey</p>
<h3 id="代码-3">代码</h3>
<pre><code class="language-c++">#include &lt;iostream&gt;
#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
using namespace std;

int total;
bool visit[20];
int volume[20];
int ans;

bool Compare(int a, int b)
{
    return a &gt; b;
}

bool DFS(int leave, int id)
{
    if (leave == 0)
    {
        ans++;
        return true;
    }
    else
    {
        for (int i=id; i&lt;total; i++)
        {
            if (!visit[i] &amp;&amp; volume[i] &lt;= leave)
            {
                visit[i]  = true;
                DFS(leave-volume[i], i); //此处注意，是遍历，不是找到解就返回
                visit[i] = false;
            }
        }
    }
    
    return false;
}

int main()
{
    while (cin &gt;&gt; total)
    {
        for (int i=0; i&lt;total; i++)
            cin &gt;&gt; volume[i];
        
        sort(volume, volume+total, Compare);
        memset(visit, false, sizeof(visit));
        ans = 0;
        
        DFS(40, 0); 
        cout &lt;&lt; ans &lt;&lt; endl;
    }
        
    return 0;
}
</code></pre>
<h2 id="4-八皇后">4.  八皇后</h2>
<h3 id="题目描述-4"><strong>题目描述</strong></h3>
<p>会下国际象棋的人都很清楚：皇后可以在横、竖、斜线上不限步数地吃掉其他棋子。如何将8个皇后放在棋盘上（有8 * 8个方格），使它们谁也不能被吃掉！这就是著名的八皇后问题。<br>
对于某个满足要求的8皇后的摆放方法，定义一个皇后串a与之对应，即a=b1b2...b8，其中bi为相应摆法中第i行皇后所处的列数。已经知道8皇后问题一共有92组解（即92个不同的皇后串）。<br>
给出一个数b，要求输出第b个串。串的比较是这样的：皇后串x置于皇后串y之前，当且仅当将x视为整数时比y小。</p>
<h3 id="要点-4"><strong>要点</strong></h3>
<ol>
<li>
<p>本质为八皇后求解问题</p>
</li>
<li>
<p><code>check()函数</code></p>
</li>
</ol>
<h3 id="提交地址-4">提交地址</h3>
<p>http://bailian.openjudge.cn/practice/2754</p>
<h3 id="代码-4">代码</h3>
<pre><code class="language-c++">#include &lt;iostream&gt;
#include &lt;cstdio&gt;
#include &lt;algorithm&gt;

using namespace std;

int ans[100][10];
int a[10];
int times = 1;

bool check(int n)
{
    for (int i = 1; i&lt;n; i++)
    {
        if ((abs(a[i] - a[n]) == n-i) || (a[i] == a[n])) //对角线或者同一列
            return false;  
    }   
    return true;
}

bool DFS(int n) //求解八皇后问题
{
    if (n &gt; 8)
    {
        for (int i=1; i&lt;=8; i++)
            ans[times][i] = a[i];
        
        times++;
        return true;
    }
    else
    {
        for (int i=1; i&lt;=8; i++)
        {
            a[n] = i;
            if(check(n))
            {
                DFS(n+1);
            }
        }
    }
    
}

int main()
{
    int num;
    while (cin &gt;&gt; num)
    {
        times = 1;
        DFS(1);
        for (int i=1; i&lt;=8; i++)
            cout &lt;&lt; ans[num][i];
        cout &lt;&lt; endl;
    }
    
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Chapter9搜索：9.1BFS]]></title>
        <id>https://Czardas42.github.io/post/chapter9_9.1/</id>
        <link href="https://Czardas42.github.io/post/chapter9_9.1/">
        </link>
        <updated>2021-05-24T01:18:37.000Z</updated>
        <content type="html"><![CDATA[<h2 id="bfs">BFS</h2>
<p>常用于搜索最优值问题，关键字“最短”“最优”“最小”</p>
<p>形式化表示问题，设计合适的状态表示</p>
<p>将搜索问题转化为针对状态的搜索</p>
<p>适当的标记，避免重复搜索</p>
<h2 id="1-catch-that-cow">1.  <strong>Catch That Cow</strong></h2>
<h3 id="题目描述"><strong>题目描述</strong></h3>
<p>Farmer John has been informed of the location of a fugitive cow and wants to catch her immediately. He starts at a point <em>N</em> (0 ≤ <em>N</em> ≤ 100,000) on a number line and the cow is at a point <em>K</em> (0 ≤ <em>K</em> ≤ 100,000) on the same number line. Farmer John has two modes of transportation: walking and teleporting.</p>
<p>* Walking: FJ can move from any point <em>X</em> to the points <em>X</em> - 1 or <em>X</em> + 1 in a single minute<br>
* Teleporting: FJ can move from any point <em>X</em> to the point 2 × <em>X</em> in a single minute.</p>
<p>If the cow, unaware of its pursuit, does not move at all, how long does it take for Farmer John to retrieve it?</p>
<h3 id="要点">要点</h3>
<ol>
<li>
<p>BFS用queue即可</p>
</li>
<li>
<p>基本步骤：</p>
<p>初始化，循环（pop，判断终止输出结果/加入子节点+合法判断）</p>
</li>
<li>
<p>数组初始化：</p>
<p><code>memset(visit, false, sizeof(visit));</code></p>
</li>
<li>
<p>visit标记数组提高运行效率</p>
</li>
</ol>
<h3 id="提交地址">提交地址</h3>
<p>http://poj.org/problem?id=3278</p>
<h3 id="代码">代码</h3>
<pre><code class="language-c++">#include &lt;iostream&gt;
#include &lt;cstdio&gt;
#include &lt;queue&gt;
#include &lt;string&gt;

using namespace std;

struct status
{
	int n;//位置
	int t;//时间

	//构造函数
	status(int position, int time)
	{
		n = position;
		t = time;
	}
};

int BFS(int n, int k) //返回花费时间
{
	queue&lt;status&gt; Q;//搜索队列

	bool visit[100001];//标记数组
	memset(visit, false, sizeof(visit));

	//初始化起点
	status start = status(n, 0);
	Q.push(start);
	visit[start.n] = true; //标记已到达

	while (!Q.empty())
	{
		status now = Q.front();
		Q.pop();
		visit[now.n] = true;

		if (now.n == k) //已经到达终点
		{
			return now.t;
		}
		else
		{
			for (int i = 0; i &lt; 3; i++) //子节点入列
			{
				status next = status(0, 0);
				if (i == 0)
				{
					next = status(now.n - 1, now.t + 1);
				}
				else if (i == 1)
				{
					next = status(now.n + 1, now.t + 1);
				}
				else
				{
					next = status(now.n * 2, now.t + 1);
				}

				//判断是否合法
				if (next.n &gt;= 0 &amp;&amp; next.n &lt;= 100000 &amp;&amp; !visit[next.n])
				{
					Q.push(next);
					visit[next.n] = true;
				}			
			}
		}
	}
};

int main()
{
	int n, k;
	while (cin &gt;&gt; n &gt;&gt; k)
	{
		cout &lt;&lt; BFS(n, k) &lt;&lt; endl;
	}
	return 0;
}
</code></pre>
<h2 id="2-find-the-multiple">2.  <strong>Find The Multiple</strong></h2>
<h3 id="题目描述-2"><strong>题目描述</strong></h3>
<p>Given a positive integer n, write a program to find out a nonzero multiple m of n whose decimal representation contains only the digits 0 and 1. You may assume that n is not greater than 200 and there is a corresponding m containing no more than 100 decimal digits.</p>
<h3 id="要点-2"><strong>要点</strong></h3>
<ol>
<li>不是遍历倍数，而是遍历0/1组成的数</li>
<li>不是为啥BFS里直接<code>cout</code>就AC，return就报错？？？</li>
</ol>
<h3 id="提交地址-2">提交地址</h3>
<p>http://poj.org/problem?id=1426</p>
<h3 id="代码-2">代码</h3>
<pre><code class="language-c++">#include &lt;iostream&gt;
#include &lt;cstdio&gt;
#include &lt;queue&gt;

using namespace std;

void BFS(int num)
{
	queue&lt;long long&gt; Q;
	long long start = 1;
	Q.push(start);

	while (!Q.empty())
	{
		long long now = Q.front();
		Q.pop();

		if (now % num == 0)
		{
			cout &lt;&lt; now &lt;&lt; endl;
			return;
		}

		Q.push(now * 10);
		Q.push(now * 10 + 1);

	}
}

int main()
{
	int num;
	while (cin &gt;&gt; num)
	{
		if (num == 0)
			break;

		BFS(num);
	}
	return 0;
}
</code></pre>
<h2 id="3-玛雅人的密码">3.  玛雅人的密码</h2>
<h3 id="题目描述-3"><strong>题目描述</strong></h3>
<p>玛雅人有一种密码，如果字符串中出现连续的2012四个数字就能解开密码。给一个长度为N的字符串，（2=&lt;N&lt;=13）该字符串中只含有0,1,2三种数字，问这个字符串要移位几次才能解开密码，每次只能移动相邻的两个数字。例如02120经过一次移位，可以得到20120,01220,02210,02102，其中20120符合要求，因此输出为1.如果无论移位多少次都解不开密码，输出-1。</p>
<h3 id="要点-3"><strong>要点</strong></h3>
<ol>
<li>
<p>使用一个vector来记录已遍历的字符串</p>
</li>
<li>
<p><strong>移动次数相当于BFS树的层数，而不是遍历次数</strong></p>
<p>解决方法：构建结构体Status，储存对应层数</p>
</li>
<li>
<p>判断是否包含子串：</p>
<p><code>now.s.find(&quot;2012&quot;) != string::npos</code></p>
</li>
</ol>
<h3 id="提交地址-3">提交地址</h3>
<p>https://www.nowcoder.com/practice/761fc1e2f03742c2aa929c19ba96dbb0?tpId=40&amp;tab=answerKey</p>
<h3 id="代码-3">代码</h3>
<pre><code class="language-c++">#include &lt;bits/stdc++.h&gt;

using namespace std;

struct Status
{
    string s;
    int t;
    Status(string str, int count)
    {
        s = str;
        t = count;
    }
};

void BFS(int length, string str)
{
    queue&lt;Status&gt; Q;
    vector&lt;Status&gt; visit;
    //初始化
    Status start = Status(str, 0);
    Q.push(start);
    visit.push_back(start);

    //循环
    while (!Q.empty())
    {
        //pop
        Status now = Q.front();
        Q.pop();
        visit.push_back(now);
        //判断输出
        if (now.s.find(&quot;2012&quot;) != string::npos)
        {
            cout &lt;&lt; now.t &lt;&lt; endl;
            return;
        }

        //加入子节点+避免重复
        for (int i=0; i&lt;length-1; i++)
        {
            Status next =now;
            next.s[i] = now.s[i+1];
            next.s[i+1] = now.s[i];
            next.t++;
        
            //判断是否已出现
            bool flag = false;
            for (int i=0; i&lt;sizeof(visit); i++)
            {
                if (visit[i].s == next.s)
                {
                    flag = true;
                    break;
                }
            }
            
            //合法就加入
            if(flag == false)
            {
                Q.push(next);
            }
        }
    }
    
    cout &lt;&lt; -1 &lt;&lt; endl;
    return;    
};

int main()
{
    int length;
    string str;
    while(cin &gt;&gt; length)
    {
        cin &gt;&gt; str;
        BFS(length, str);
    }
    return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Rank-Emotion-Cause]]></title>
        <id>https://Czardas42.github.io/post/rank-emotion-cause-2020/</id>
        <link href="https://Czardas42.github.io/post/rank-emotion-cause-2020/">
        </link>
        <updated>2021-05-23T07:59:30.000Z</updated>
        <content type="html"><![CDATA[<p>阅读笔记：</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Chapter8递归与分治：8.2分治]]></title>
        <id>https://Czardas42.github.io/post/chapter8_8.2/</id>
        <link href="https://Czardas42.github.io/post/chapter8_8.2/">
        </link>
        <updated>2021-05-19T03:23:06.000Z</updated>
        <content type="html"><![CDATA[<h2 id="分治法">分治法</h2>
<p>不断把问题分为规模更小的问题</p>
<h2 id="1-斐波那契额数列">1.  斐波那契额数列</h2>
<h3 id="题目描述"><strong>题目描述</strong></h3>
<p>The Fibonacci Numbers{0,1,1,2,3,5,8,13,21,34,55...} are defined by the recurrence:   F0=0 F1=1 Fn=Fn-1+Fn-2,n&gt;=2   Write a program to calculate the Fibonacci Numbers.</p>
<h3 id="要点">要点</h3>
<p>递归的写法</p>
<h3 id="提交地址">提交地址</h3>
<p>https://www.nowcoder.com/practice/17ad6908e36a49f4b06ea96936e8bb25?tpId=40&amp;tab=answerKey</p>
<h3 id="代码">代码</h3>
<pre><code class="language-c++">#include &lt;bits/stdc++.h&gt;

using namespace std;

int Fibonacci(int i)
{
    if (i == 0)
        return 0;
    else if (i == 1)
        return 1;
    else
        return Fibonacci(i-1) + Fibonacci(i-2);
    
}

int main()
{
    int num;
    while (cin &gt;&gt; num)
    {
        cout &lt;&lt; Fibonacci(num) &lt;&lt; endl;
    }
    return 0;
}

</code></pre>
<h2 id="2-二叉树">2.  二叉树</h2>
<h3 id="题目描述-2"><strong>题目描述</strong></h3>
<figure data-type="image" tabindex="1"><img src="https://Czardas42.github.io//post-images/1621394733656.png" alt="" loading="lazy"></figure>
<p>如上所示，由正整数1，2，3……组成了一颗特殊二叉树。我们已知这个二叉树的最后一个结点是n。现在的问题是，结点m所在的子树中一共包括多少个结点。   比如，n = 12，m = 3那么上图中的结点13，14，15以及后面的结点都是不存在的，结点m所在子树中包括的结点有3，6，7，12，因此结点m的所在子树中共有4个结点。</p>
<h3 id="要点-2"><strong>要点</strong></h3>
<ol>
<li>二叉树的规律：左子节点id = 父节点id*2</li>
<li>递归的终止条件：<code>m &gt; n</code></li>
</ol>
<h3 id="提交地址-2">提交地址</h3>
<p>https://www.nowcoder.com/practice/f74c7506538b44399f2849eba2f050b5?tpId=40&amp;tab=answerKey</p>
<h3 id="代码-2">代码</h3>
<pre><code class="language-c++">#include &lt;bits/stdc++.h&gt;

using namespace std;

int nodeCount(int m, int n)
{
    if (m &gt; n)
        return 0;
    else
        return nodeCount(2*m, n) + nodeCount(2*m+1, n) + 1;
}

int main()
{
    int m, n;
    while (cin &gt;&gt; m &gt;&gt;n)
    {
        if (m==0)
            break;        
        cout &lt;&lt; nodeCount(m, n) &lt;&lt; endl;
    }
    
    return 0;
}
</code></pre>
<h2 id="3-2的幂次方">3.  2的幂次方</h2>
<h3 id="题目描述-3"><strong>题目描述</strong></h3>
<p>Every positive number can be presented by the exponential form.For example, 137 = 2^7 + 2^3 + 2^0。   Let's present a^b by the form a(b).Then 137 is presented by 2(7)+2(3)+2(0). Since 7 = 2^2 + 2 + 2^0 and 3 = 2 + 2^0 , 137 is finally presented by 2(2(2)+2 +2(0))+2(2+2(0))+2(0).    Given a positive number n,your task is to present n with the exponential form which only contains the digits 0 and 2.</p>
<h3 id="要点-3"><strong>要点</strong></h3>
<ol>
<li>
<p>十进制到二进制的转换</p>
<p>停止条件<code>num == 0</code>, 不是<code>num / 2 == 0</code></p>
</li>
<li>
<p>递归的思想：</p>
<p>输入，转换为二进制，有效位+位置序号判断</p>
</li>
<li>
<p>“+”位置的出现</p>
</li>
</ol>
<h3 id="提交地址-3">提交地址</h3>
<p>https://www.nowcoder.com/practice/7cf7b0706d7e4b439481f53e5fdac6e7?tpId=40&amp;tab=answerKey</p>
<h3 id="代码-3">代码</h3>
<pre><code class="language-c++">#include &lt;bits/stdc++.h&gt;

using namespace std;

vector&lt;int&gt; convert(int num)
{
    vector&lt;int&gt; res;
    while(num != 0)
    {
        res.push_back(num % 2);
        num = num / 2;
    }
    
    return res;
}

void print(int num)
{
    vector&lt;int&gt; res = convert(num);
    bool begin = true;
    for(int i=res.size()-1; i&gt;=0; i--)
    {
        if (res[i] == 1)//有效位
        {
            if (begin == true)
                begin = false;
            else
                cout &lt;&lt; &quot;+&quot;;
            
            if (i == 0)
                cout &lt;&lt; &quot;2(0)&quot;;
            else if (i == 1)
                cout &lt;&lt; &quot;2&quot;;
            else if (i == 2)
                cout &lt;&lt; &quot;2(2)&quot;;
            else
            {
                cout &lt;&lt; &quot;2(&quot;;
                print(i);
                cout &lt;&lt; &quot;)&quot;;
            }
        }
    }
}

int main()
{
    int num;
    while (cin &gt;&gt; num)
    {
        print(num);
        cout &lt;&lt; endl;
    }
    return 0;  
}
    
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Chapter8递归与分治：8.1递归]]></title>
        <id>https://Czardas42.github.io/post/chapter8_8.1/</id>
        <link href="https://Czardas42.github.io/post/chapter8_8.1/">
        </link>
        <updated>2021-05-19T03:22:13.000Z</updated>
        <content type="html"><![CDATA[<h2 id="递归策略">递归策略</h2>
<h2 id="1-n的阶乘">1.  n的阶乘</h2>
<h3 id="题目描述"><strong>题目描述</strong></h3>
<p>输入一个整数n，输出n的阶乘（每组测试用例可能包含多组数据，请注意处理）</p>
<h3 id="要点"><strong>要点</strong></h3>
<ol>
<li>递归思想</li>
<li>结果的数据范围：<code>long long</code>类型</li>
</ol>
<h3 id="提交地址">提交地址</h3>
<p>https://www.nowcoder.com/practice/97be22ee50b14cccad2787998ca628c8?tpId=40&amp;tab=answerKey</p>
<h3 id="代码">代码</h3>
<pre><code class="language-c++">#include &lt;bits/stdc++.h&gt;

using namespace std;

long long Factorial(int n)
{
    if (n == 1)
        return 1;
    else
    {
        return n * Factorial(n-1);
    }
}
int main()
{
    int num;
    while(cin &gt;&gt; num)
    {
        cout &lt;&lt; Factorial(num) &lt;&lt; endl;
    }
    
    return 0;
}
</code></pre>
<h2 id="2-汉诺塔问题">2.  汉诺塔问题</h2>
<p>移动规律：</p>
<p><code>F(n) = F(n-1) + 1 + F(n-1) + 1 + F(n-1)</code></p>
<p><code>F(n) = 3 * F(n-1) + 2</code></p>
<p>终止条件：<code>n=1</code>时，的移动次数</p>
<h2 id="3-杨辉三角形">3.  杨辉三角形</h2>
<h3 id="题目描述-2"><strong>题目描述</strong></h3>
<p>使用代理服务器能够在一定程度上隐藏客户端信息，从而保护用户在互联网上的隐私。我们知道n个代理服务器的IP地址，现在要用它们去访问m个服务器。这 m 个服务器的 IP 地址和访问顺序也已经给出。系统在同一时刻只能使用一个代理服务器，并要求不能用代理服务器去访问和它 IP地址相同的服务器（不然客户端信息很有可能就会被泄露）。在这样的条件下，找到一种使用代理服务器的方案，使得代理服务器切换的次数尽可能得少。</p>
<h3 id="要点-2"><strong>要点</strong></h3>
<ol>
<li>杨辉三角性质：<code>func(m, n) = func(m-1, n-1) + func(m-1, n);</code></li>
<li>递归函数：返回杨辉三角指定行列的值</li>
</ol>
<h3 id="提交地址-2">提交地址</h3>
<p>https://www.nowcoder.com/practice/1284469ee94a4762848816a42281a9e0?tpId=40&amp;tab=answerKey</p>
<h3 id="代码-2">代码</h3>
<pre><code class="language-c++">#include &lt;bits/stdc++.h&gt;

using namespace std;

int func(int m, int n)
{
    if(n==0)
        return 1;
    else if(m==n)
        return 1;
    else
        return func(m-1, n-1) + func(m-1, n);
}

int main()
{
    int num;
    while (cin &gt;&gt; num)
    {
        for(int i=0; i&lt;num; i++)
        {
            for (int j=0; j&lt;=i; j++)
            {
                if(j==i)
                    cout &lt;&lt; func(i, j) &lt;&lt; endl;
                else
                    cout &lt;&lt; func(i, j) &lt;&lt; &quot; &quot;;
            }
        }
    }
    
    return 0;
}
</code></pre>
<h2 id="3-全排列">3.  全排列</h2>
<h3 id="题目描述-3"><strong>题目描述</strong></h3>
<p>给定一个由不同的小写字母组成的字符串，输出这个字符串的所有全排列。 我们假设对于小写字母有'a' &lt; 'b' &lt; ... &lt; 'y' &lt; 'z'，而且给定的字符串中的字母已经按照从小到大的顺序排列。</p>
<h3 id="要点-3"><strong>要点</strong></h3>
<ol>
<li>STL库的使用：<code>next_permutation(str.begin(),str.end())</code></li>
<li><code>do while</code></li>
</ol>
<h3 id="提交地址-3">提交地址</h3>
<p>https://www.nowcoder.com/practice/5632c23d0d654aecbc9315d1720421c1?tpId=40&amp;tab=answerKey</p>
<h3 id="代码-3">代码</h3>
<pre><code class="language-c++">#include &lt;bits/stdc++.h&gt;

using namespace std;

int main ()
{
    string str;
    while(cin &gt;&gt; str)
    {
        sort(str.begin(), str.end());
        do{
            cout &lt;&lt; str &lt;&lt; endl;
        }
        while(next_permutation(str.begin(),str.end()));
    }
    
    return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Chapter7贪心算法：7.2区间贪心]]></title>
        <id>https://Czardas42.github.io/post/chapter7_7.2/</id>
        <link href="https://Czardas42.github.io/post/chapter7_7.2/">
        </link>
        <updated>2021-05-19T03:21:09.000Z</updated>
        <content type="html"><![CDATA[<h2 id="贪心策略">贪心策略</h2>
<h2 id="1-今年暑假不ac">1.  今年暑假不AC</h2>
<h3 id="题目描述"><strong>题目描述</strong></h3>
<p>“今年暑假不AC？”<br>
“是的。”<br>
“那你干什么呢？”<br>
“看世界杯呀，笨蛋！”<br>
“@#$%^&amp;*%...”</p>
<p>确实如此，世界杯来了，球迷的节日也来了，估计很多ACMer也会抛开电脑，奔向电视了。<br>
作为球迷，一定想看尽量多的完整的比赛，当然，作为新时代的好青年，你一定还会看一些其它的节目，比如新闻联播（永远不要忘记关心国家大事）、非常6+7、超级女生，以及王小丫的《开心辞典》等等，假设你已经知道了所有你喜欢看的电视节目的转播时间表，你会合理安排吗？（目标是能看尽量多的完整节目）</p>
<p>输入数据包含多个测试实例，每个测试实例的第一行只有一个整数n(n&lt;=100)，表示你喜欢看的节目的总数，然后是n行数据，每行包括两个数据Ti_s,Ti_e (1&lt;=i&lt;=n)，分别表示第i个节目的开始和结束时间，为了简化问题，每个时间都用一个正整数表示。n=0表示输入结束，不做处理。</p>
<h3 id="要点"><strong>要点</strong></h3>
<ol>
<li>贪心策略：以节目结束时间为标准</li>
<li>排序的写法</li>
<li>判断条件：该节目开始时间晚于或<strong>等于</strong>标记时间</li>
</ol>
<h3 id="提交地址">提交地址</h3>
<p>http://acm.hdu.edu.cn/showproblem.php?pid=2037</p>
<h3 id="代码">代码</h3>
<pre><code class="language-c++">#include &lt;iostream&gt;
#include &lt;cstdio&gt;
#include &lt;algorithm&gt;

using namespace std;

struct program
{
	int begin;
	int end;
};

program list[100];

bool Compare(program a, program b)
{
	return a.end &lt; b.end;
};

int main()
{
	int count;
	while (cin &gt;&gt; count)
	{
		if (count == 0)
			break;

		for (int i = 0; i &lt; count; i++)
		{
			cin &gt;&gt; list[i].begin &gt;&gt; list[i].end;
		}
		//完成输入

		//排序
		sort(list, list + count, Compare);

		//判断
		int time = 0; //当前标记时间
		int result = 0; //结果记录
		for (int i = 0; i &lt; count; i++)
		{
			if (list[i].begin &gt;= time) //若该节目开始时间晚于或等于标记时间
			{
				result++; //观看节目+1
				time = list[i].end; //标记时间变为该节目的结束时间
			}
		}
		cout &lt;&lt; result &lt;&lt; endl;	
	}
	return 0;
}

</code></pre>
<h2 id="2-to-fill-or-not-to-fill">2.  To Fill or Not to Fill</h2>
<h3 id="题目描述-2"><strong>题目描述</strong></h3>
<p>With highways available, driving a car from Hangzhou to any other city is easy. But since the tank capacity of a car is limited, we have to find gas stations on the way from time to time. Different gas station may give different price. You are asked to carefully design the cheapest route to go.</p>
<h3 id="要点-2"><strong>要点</strong></h3>
<p>倦了，一个下午没通过。。。。。。</p>
<h3 id="提交地址-2">提交地址</h3>
<p>https://www.nowcoder.com/practice/f7eba38f7cd24c45982831e0f38518f9?tpId=40&amp;tab=answerKey</p>
<h3 id="代码-2">代码</h3>
<pre><code class="language-c++">/*
核心思路:利用贪心策略,从最便宜的加油站开始,每个加油站加的油最多能走cmax*davg路程.
利用一个30000大小的flag数组记录是否有重合区域
*/
#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
using namespace std;

struct sta{
    double pi;
    int di;
    bool operator &lt; (const sta&amp; b) const{
        return pi&lt;b.pi;
    }
}a[501];

int main(){
    int cmax, d, davg, n;
    double sum;
    while(scanf(&quot;%d %d %d %d&quot;, &amp;cmax, &amp;d, &amp;davg, &amp;n)!=EOF){
        for(int i=0; i&lt;n; i++) scanf(&quot;%lf %d&quot;, &amp;a[i].pi, &amp;a[i].di);
        sort(a, a+n);
        //
        sum = 0;//记录花费
        int flag[30001]={0}, max = cmax*davg, tmp, cnt;
        for(int i=0; i&lt;n; i++){
            tmp = (a[i].di+max&lt;d?max:d-a[i].di);    //如果到终点距离&lt;max,只需加上足够走到终点的油
            cnt = 0;    //记录有多长距离需要该加油站的油
            for(int j=a[i].di; j&lt;a[i].di+tmp; j++){
                if(flag[j]==0){
                    flag[j] = 1;
                    cnt++;
                }
            }
            sum += cnt/(davg*1.0)*a[i].pi;    //加上在该加油站的花销
        }
        //check
        int i;
        for(i=0; i&lt;d; i++){
            //有的路程没有被覆盖到说明走不到这里
            if(flag[i]==0){
                printf(&quot;The maximum travel distance = %.2lf\n&quot;, (double)i);
                break;
            }
        }
        if(i==d){
            printf(&quot;%.2lf\n&quot;,sum);
        }
    }
    return 0;
}

</code></pre>
<h2 id="3-代理服务器">3.  代理服务器</h2>
<h3 id="题目描述-3"><strong>题目描述</strong></h3>
<p>使用代理服务器能够在一定程度上隐藏客户端信息，从而保护用户在互联网上的隐私。我们知道n个代理服务器的IP地址，现在要用它们去访问m个服务器。这 m 个服务器的 IP 地址和访问顺序也已经给出。系统在同一时刻只能使用一个代理服务器，并要求不能用代理服务器去访问和它 IP地址相同的服务器（不然客户端信息很有可能就会被泄露）。在这样的条件下，找到一种使用代理服务器的方案，使得代理服务器切换的次数尽可能得少。</p>
<h3 id="要点-3"><strong>要点</strong></h3>
<ol>
<li><code>#include&lt;bits/stdc++.h&gt;</code></li>
<li><code>strcmp(proxy[i], server[j])</code></li>
</ol>
<h3 id="提交地址-3">提交地址</h3>
<p>https://www.nowcoder.com/practice/1284469ee94a4762848816a42281a9e0?tpId=40&amp;tab=answerKey</p>
<h3 id="代码-3">代码</h3>
<pre><code class="language-c++">#include&lt;bits/stdc++.h&gt;
using namespace std;

int main(){
    int n;
    while(cin &gt;&gt; n){
        char proxy[n][16];  // proxy服务器
        for(int i = 0; i &lt; n; i++)
            cin &gt;&gt; proxy[i];
        int m;
        cin &gt;&gt; m;
        char server[m][16];
        for(int i = 0; i &lt; m; i++)
            cin &gt;&gt; server[i];  // 被访问的服务器
        //以上都是输入的内容
        int index=0, count=0, flag=1;  //flag用来标志代li失败的状况
        while(flag &amp;&amp; index != m)
        {  //当游标index遍历到m时表示遍历结束
            int max = 0;
            for(int i = 0; i &lt; n; i++){  //这个for是让每个proxy服务器尽可能大的遍历服务器
                int j = index;  //每次从游标开始遍历服务器
                while(strcmp(proxy[i], server[j]) &amp;&amp; j &lt; m)  //尽可能的访问服务器
                    j++;
                if(j - index &gt; max)
                    max = j - index;  //最大访问服务器个数
            }
            if(max == 0)  //遍历失败
                flag = 0;
            count++;
            index += max;
        }
        if(flag)
            cout &lt;&lt; count - 1 &lt;&lt; endl;  //因为第一次不算转换
        else cout &lt;&lt; &quot;-1&quot; &lt;&lt; endl;
    }
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Chapter7贪心算法：7.1简单贪心]]></title>
        <id>https://Czardas42.github.io/post/chapter7_7.1/</id>
        <link href="https://Czardas42.github.io/post/chapter7_7.1/">
        </link>
        <updated>2021-05-19T03:20:11.000Z</updated>
        <content type="html"><![CDATA[<h2 id="贪心策略">贪心策略</h2>
<h2 id="1-鸡兔同笼">1.  鸡兔同笼</h2>
<h3 id="题目描述"><strong>题目描述</strong></h3>
<p>一个笼子里面关了鸡和兔子（鸡有2只脚，兔子有4只脚，没有例外）。已经知道了笼子里面脚的总数a，问笼子里面至少有多少只动物，至多有多少只动物。</p>
<h3 id="要点"><strong>要点</strong></h3>
<p>只有偶数脚时，答案才不是0 0</p>
<h3 id="提交地址">提交地址</h3>
<p>https://www.nowcoder.com/practice/fda725b4d9a14010bb145272cababef1?tpId=40&amp;tab=answerKey</p>
<h3 id="代码">代码</h3>
<pre><code class="language-c++">#include &lt;iostream&gt;
#include &lt;cstdio&gt;

using namespace std;

int Find_least(int num)
{
    int rabbit, chicken;
    rabbit = num / 4;
    int temp = num % 4;
    if (temp != 0)
        chicken = temp / 2;
    
    return rabbit + chicken;
};

int Find_most(int num)
{
    int rabbit = 0, chicken = 0;
    chicken = num / 2;
    
    return rabbit + chicken;
};

int main()
{

    int num;
    while (cin &gt;&gt; num)
    {
        if (num % 2 != 0)
        {
            cout &lt;&lt; &quot;0 0&quot; &lt;&lt; endl;
            continue;
        }
        else
        {
            int most = Find_most(num);
            int least = Find_least(num);
            cout &lt;&lt; least &lt;&lt; &quot; &quot; &lt;&lt; most &lt;&lt; endl;
        }
           
    }
    
    return 0;
}
</code></pre>
<h2 id="2-fatmouse-trade">2.  FatMouse' Trade</h2>
<h3 id="题目描述-2"><strong>题目描述</strong></h3>
<p>FatMouse prepared M pounds of cat food, ready to trade with the cats guarding the warehouse containing his favorite food, JavaBean.<br>
The warehouse has N rooms. The i-th room contains J[i] pounds of JavaBeans and requires F[i] pounds of cat food. FatMouse does not have to trade for all the JavaBeans in the room, instead, he may get J[i]* a% pounds of JavaBeans if he pays F[i]* a% pounds of cat food. Here a is a real number. Now he is assigning this homework to you: tell him the maximum amount of JavaBeans he can obtain.</p>
<h3 id="要点-2"><strong>要点</strong></h3>
<ol>
<li>
<p>计算性价比</p>
</li>
<li>
<p>排序</p>
<pre><code class="language-c++">sort(arr, srr+n, Compare);
bool Compare(a, b) //降序
{
	return a &gt; b;
}
</code></pre>
</li>
</ol>
<h3 id="提交地址-2">提交地址</h3>
<p>暂无</p>
<h3 id="代码-2">代码</h3>
<pre><code class="language-c++">
</code></pre>
<h2 id="2-代理服务器">2.  代理服务器</h2>
<h3 id="题目描述-3"><strong>题目描述</strong></h3>
<p>使用代理服务器能够在一定程度上隐藏客户端信息，从而保护用户在互联网上的隐私。我们知道n个代理服务器的IP地址，现在要用它们去访问m个服务器。这 m 个服务器的 IP 地址和访问顺序也已经给出。系统在同一时刻只能使用一个代理服务器，并要求不能用代理服务器去访问和它 IP地址相同的服务器（不然客户端信息很有可能就会被泄露）。在这样的条件下，找到一种使用代理服务器的方案，使得代理服务器切换的次数尽可能得少。</p>
<h3 id="要点-3"><strong>要点</strong></h3>
<ol>
<li><code>#include&lt;bits/stdc++.h&gt;</code></li>
<li><code>strcmp(proxy[i], server[j])</code></li>
</ol>
<h3 id="提交地址-3">提交地址</h3>
<p>https://www.nowcoder.com/practice/1284469ee94a4762848816a42281a9e0?tpId=40&amp;tab=answerKey</p>
<h3 id="代码-3">代码</h3>
<pre><code class="language-c++">#include&lt;bits/stdc++.h&gt;
using namespace std;

int main(){
    int n;
    while(cin &gt;&gt; n){
        char proxy[n][16];  // proxy服务器
        for(int i = 0; i &lt; n; i++)
            cin &gt;&gt; proxy[i];
        int m;
        cin &gt;&gt; m;
        char server[m][16];
        for(int i = 0; i &lt; m; i++)
            cin &gt;&gt; server[i];  // 被访问的服务器
        //以上都是输入的内容
        int index=0, count=0, flag=1;  //flag用来标志代li失败的状况
        while(flag &amp;&amp; index != m)
        {  //当游标index遍历到m时表示遍历结束
            int max = 0;
            for(int i = 0; i &lt; n; i++){  //这个for是让每个proxy服务器尽可能大的遍历服务器
                int j = index;  //每次从游标开始遍历服务器
                while(strcmp(proxy[i], server[j]) &amp;&amp; j &lt; m)  //尽可能的访问服务器
                    j++;
                if(j - index &gt; max)
                    max = j - index;  //最大访问服务器个数
            }
            if(max == 0)  //遍历失败
                flag = 0;
            count++;
            index += max;
        }
        if(flag)
            cout &lt;&lt; count - 1 &lt;&lt; endl;  //因为第一次不算转换
        else cout &lt;&lt; &quot;-1&quot; &lt;&lt; endl;
    }
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Chapter6数学问题：6.4分解质因数]]></title>
        <id>https://Czardas42.github.io/post/chapter6_6.4/</id>
        <link href="https://Czardas42.github.io/post/chapter6_6.4/">
        </link>
        <updated>2021-05-19T03:18:29.000Z</updated>
        <content type="html"><![CDATA[<h2 id="质因数分解">质因数分解</h2>
<p><strong>把一个合数用质因数相乘的形式表示出来，叫做分解质因数</strong>。</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi><mo>=</mo><msubsup><mi>p</mi><mn>1</mn><mrow><mi>e</mi><mn>1</mn></mrow></msubsup><mo>∗</mo><msubsup><mi>p</mi><mn>2</mn><mrow><mi>e</mi><mn>2</mn></mrow></msubsup><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><msubsup><mi>p</mi><mi>n</mi><mrow><mi>e</mi><mi>n</mi></mrow></msubsup></mrow><annotation encoding="application/x-tex">x = p_1^{e1} * p_2^{e2} ...p_n^{en}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.1111079999999998em;vertical-align:-0.247em;"></span><span class="mord"><span class="mord mathdefault">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8641079999999999em;"><span style="top:-2.4530000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">e</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.247em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.1111079999999998em;vertical-align:-0.247em;"></span><span class="mord"><span class="mord mathdefault">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8641079999999999em;"><span style="top:-2.4530000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">e</span><span class="mord mtight">2</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.247em;"><span></span></span></span></span></span></span><span class="mord">.</span><span class="mord">.</span><span class="mord">.</span><span class="mord"><span class="mord mathdefault">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.7143919999999999em;"><span style="top:-2.4530000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">e</span><span class="mord mathdefault mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.247em;"><span></span></span></span></span></span></span></span></span></span></span></p>
<h2 id="1-质因数个数">1.  质因数个数</h2>
<h3 id="题目描述"><strong>题目描述</strong></h3>
<p>求正整数N(N&gt;1)的质因数的个数。 相同的质因数需要重复计算。如120=2<em>2</em>2<em>3</em>5，共有5个质因数。</p>
<h3 id="要点"><strong>要点</strong></h3>
<p>算法步骤：（输入1&lt;N&lt;M）</p>
<p><code>MAXN = sqrt(M) + 1</code></p>
<ol>
<li>
<p>素数筛法求出0-MAXN所有素数，存好；</p>
<p><strong>（N至多只存在一个大于MAXN的质因数，否则两个相乘会大于N）</strong></p>
</li>
<li>
<p>输入N；</p>
</li>
<li>
<p>依次遍历素数组，判断是否能整除；</p>
</li>
<li>
<p>不断用该素数除N，直到不能被整除为止，记录幂次；</p>
</li>
<li>
<p>遍历完成之后，若N&gt;1，则证明存在一个大于MAXN且幂次为1的质因数</p>
</li>
</ol>
<h3 id="提交地址">提交地址</h3>
<p>https://www.nowcoder.com/practice/20426b85f7fc4ba8b0844cc04807fbd9?tpId=40&amp;qru=%2Fta%2Ftsing-kaoyan%2Fquestion-ranking&amp;tab=answerKey</p>
<h3 id="代码">代码</h3>
<pre><code class="language-c++">#include &lt;iostream&gt;
#include &lt;cmath&gt;
#include &lt;cstdio&gt;
#include &lt;vector&gt;

using namespace std;

const int MAXN = 31623; // sqrt(1e9) + 1

bool isPrime[MAXN];
vector&lt;int&gt; prime;

void Initial() //素数筛法
{
    for(int i=0; i&lt;MAXN; i++)
        isPrime[i] = true;
    isPrime[0] = false;
    isPrime[1] = false;
    
    for (int i=0; i&lt;MAXN; i++)
    {
        if (isPrime[i] == true)
        {
            prime.push_back(i);
            for (int j=i*i; j&lt;MAXN; j=j+i)
                isPrime[j] = false;
        }
    }
};

int main()
{
    Initial();
    
    int num;
    while (cin &gt;&gt; num)
    {
        int result = 0;
        for (int i=0; i&lt;prime.size(); i++)
        {
            int temp = prime[i];
            while (num % temp == 0)
            {
                result++;
                num = num / temp;
            }
            
            if (num == 1) //除尽就跳出循环
                break;
        }
        
        if (num &gt; 1) //存在一个大于sqrt(1e9) + 1的素因数，且幂次为1
            result++;
        
        cout &lt;&lt; result &lt;&lt; endl;
    }
}
</code></pre>
<h2 id="2-约数的个数">2.  约数的个数</h2>
<h3 id="题目描述-2"><strong>题目描述</strong></h3>
<p>输入n个整数,依次输出每个数的约数的个数</p>
<h3 id="要点-2"><strong>要点</strong></h3>
<figure data-type="image" tabindex="1"><img src="D:%5CTJU%5C%E4%BF%9D%E7%A0%94%5C%E6%9C%BA%E8%AF%95%5Cimage-20210506133135936.png" alt="image-20210506133135936" loading="lazy"></figure>
<p>也就是求出质因数之后前面的组合乘上现在的因子加1</p>
<h3 id="提交地址-2">提交地址</h3>
<p>https://www.nowcoder.com/practice/04c8a5ea209d41798d23b59f053fa4d6?tpId=40&amp;qru=%2Fta%2Ftsing-kaoyan%2Fquestion-ranking&amp;tab=answerKey</p>
<h3 id="代码-2">代码</h3>
<pre><code class="language-c++">#include &lt;iostream&gt;
#include &lt;cstdio&gt;
#include &lt;cmath&gt;
#include &lt;vector&gt;

using namespace std;

vector&lt;bool&gt; isPrime;
vector&lt;int&gt; prime;
const int MAXN = sqrt(1e9) + 1;

void Initial()
{
    for (int i=0; i&lt;MAXN; i++)
        isPrime.push_back(true);
    isPrime[0] = false;
    isPrime[1] = false;
    
    for (int i=0; i&lt;MAXN; i++)
    {
        if (isPrime[i] == true)
        {
            prime.push_back(i);
            for (int j = i*i; j&lt;MAXN; j+=i)
                isPrime[j] = false;
        }
    }
};

int main()
{
    int count;
    Initial();
    while (cin &gt;&gt; count)
    {
        int num;
        for (int i=0; i&lt;count; i++)
        {
            cin &gt;&gt; num;           
            int answer = 1;           

            for (int i=0; i&lt;prime.size(); i++)
            {
                int temp = prime[i];
                int result = 0;
                                
                while (num % temp == 0)
                {
                    num = num / temp;
                    result++;
                }
                
                answer = (result+1) * answer;
                
                if (num == 1)
                    break;
            }
            
            if (num &gt; 1)
                answer *= 2;
            
            cout &lt;&lt; answer &lt;&lt; endl;                  
        }
    }
    return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Prometheus]]></title>
        <id>https://Czardas42.github.io/post/prometheus/</id>
        <link href="https://Czardas42.github.io/post/prometheus/">
        </link>
        <updated>2021-05-06T11:59:16.000Z</updated>
        <content type="html"><![CDATA[<h4 id="集群监控策略">集群监控策略：</h4>
<p>Prometheus监控Kubernetes集群监控的各个维度以及策略：</p>
<table>
<thead>
<tr>
<th>目标</th>
<th>服务发现模式</th>
<th><strong>监控方法</strong></th>
<th><strong>数据源</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>从集群各节点kubelet组件中获取节点kubelet的基本运行状态的监控指标</td>
<td>node</td>
<td>白盒监控</td>
<td>kubelet</td>
</tr>
<tr>
<td>从集群各节点kubelet内置的cAdvisor中获取，节点中运行的容器的监控指标</td>
<td>node</td>
<td>白盒监控</td>
<td>kubelet</td>
</tr>
<tr>
<td><strong>从部署到各个节点的Node Exporter中采集主机资源相关的运行资源</strong>（本次实验使用方法）</td>
<td><strong>node</strong></td>
<td><strong>白盒监控</strong></td>
<td><strong>node exporter</strong></td>
</tr>
<tr>
<td>对于内置了Promthues支持的应用，需要从Pod实例中采集其自定义监控指标</td>
<td>pod</td>
<td>白盒监控</td>
<td>custom pod</td>
</tr>
<tr>
<td>获取API Server组件的访问地址，并从中获取Kubernetes集群相关的运行监控指标</td>
<td>endpoints</td>
<td>白盒监控</td>
<td>api server</td>
</tr>
<tr>
<td>获取集群中Service<u>的访问地址</u>，并通过Blackbox Exporter获取网络探测指标</td>
<td>service</td>
<td>黑盒监控</td>
<td>blackbox exporter</td>
</tr>
<tr>
<td>获取集群中Ingress的访问信息，并通过Blackbox Exporter获取网络探测指标</td>
<td>ingress</td>
<td>黑盒监控</td>
<td>blackbox exporter</td>
</tr>
</tbody>
</table>
<h4 id="prometheus部署">Prometheus部署</h4>
<p><u><em>详细说一说，因为直接动了系统自带的配置文件</em></u></p>
<h4 id="node-exporter部署">Node Exporter部署</h4>
<h5 id="方法">方法：</h5>
<ol>
<li>
<p>创建自定义的Node Exporter服务，然后将服务器配置为Prometheus上的Target（本次实验使用方法）</p>
<p>【参考】<a href="https://devopscube.com/monitor-linux-servers-prometheus-node-exporter/">https://devopscube.com/monitor-linux-servers-prometheus-node-exporter/</a></p>
</li>
<li>
<p>还可以使用Daemonset控制器部署Node Exporter</p>
<p>为了能够采集集群中各个节点的资源使用情况，需要在各节点中部署一个Node Exporter实例。在部署Prometheus时，我们使用了Kubernetes内置的控制器之一Deployment。Deployment能够确保Prometheus的Pod能够按照预期的状态在集群中运行，而Pod实例可能随机运行在任意节点上。</p>
<p>而与Prometheus的部署不同的是，<strong>对于Node Exporter而言每个节点只需要运行一个唯一的实例</strong>，所以需要使用Kubernetes的另外一种控制器Daemonset。Daemonset的管理方式类似于操作系统中的守护进程。Daemonset会确保在集群中所有（也可以指定）节点上运行一个唯一的Pod实例。</p>
</li>
</ol>
<h5 id="daemonset-与-deployment-的区别">DaemonSet 与 Deployment 的区别</h5>
<ul>
<li><strong>Deployment</strong> 部署的副本 <strong>Pod</strong> 会分布在各个 <strong>Node</strong> 上，每个 <strong>Node</strong> 都可能运行好几个副本。</li>
<li><strong>DaemonSet</strong> 的不同之处在于：每个 <strong>Node</strong> 上最多只能运行一个副本。</li>
</ul>
<h5 id="daemonset-的典型应用场景">DaemonSet 的典型应用场景</h5>
<ul>
<li>在集群的每个节点上运行存储 <strong>Daemon</strong>，比如：<strong>glusterd</strong> 或 <strong>ceph</strong>。</li>
<li>在每个节点上运行日志收集 <strong>Daemon</strong>，比如：<strong>flunentd</strong> 或 <strong>logstash</strong>。</li>
<li>在每个节点上运行监控 <strong>Daemon</strong>，比如：<strong>Prometheus Node Exporter</strong> 或 <strong>collectd</strong>。</li>
</ul>
<h5 id="查看k8s-的-daemonset">查看k8s 的 DaemonSet</h5>
<p><strong>Kubernetes</strong> 自己就在用 <strong>DaemonSet</strong> 运行系统组件。执行如下命令查看：</p>
<p><code>kubectl get daemonset --``namespace``=kube-system</code></p>
<p><em><u>(配一张截图)</u></em></p>
<h4 id="promql概念应用实例">PromQL概念&amp;应用实例</h4>
<h5 id="概念">概念</h5>
<p>Prometheus通过指标名称（metrics name）以及对应的一组标签（labelset）唯一定义一条时间序列。指标名称反映了监控样本的基本标识，而label则在这个基本特征上为采集到的数据提供了多种特征维度。用户可以基于这些特征维度过滤，聚合，统计从而产生新的计算后的一条时间序列。</p>
<h5 id="应用实例">应用实例</h5>
<ol>
<li>各节点磁盘使用率</li>
</ol>
<p><code>node_filesystem_size_bytes{fstype=~\&quot;xfs|ext4\&quot;} - node_filesystem_free_bytes) / node_filesystem_size_bytes</code></p>
<ol start="2">
<li>各节点内存使用率</li>
</ol>
<p><code>node_memory_MemTotal_bytes - node_memory_MemAvailable_bytes) / node_memory_MemTotal_bytes</code></p>
<ol start="3">
<li>各节点磁盘IO读速率(MiB/s)</li>
</ol>
<p><code>irate(node_disk_read_bytes_total{}[5m]) / 1024 / 1024</code></p>
<ol start="4">
<li>各节点磁盘IO写速率(MiB/s)</li>
</ol>
<p><code>irate(node_disk_written_bytes_total{}[5m]) / 1024 / 1024</code></p>
<ol start="5">
<li>某节点网络IO速率:入速率(MiB/s)</li>
</ol>
<p><code>irate(node_network_receive_bytes_total{job=\&quot;节点名称_node_exporter_metrics\&quot;}[5m]) / 1024 / 1024</code></p>
<ol start="6">
<li>某节点网络IO速率:出速率(MiB/s)</li>
</ol>
<p><code>irate(node_network_transmit_bytes_total{job=\&quot;节点名称_node_exporter_metrics\&quot;}[5m]) / 1024 / 1024</code></p>
<ol start="7">
<li><strong>某节点CPU使用率</strong></li>
</ol>
<p><code>100 - (avg by(instance) (irate(node_cpu_seconds_total{mode=\&quot;idle\&quot;, job=\&quot;节点名称_node_exporter_metrics\&quot;}[5m])) * 100)</code></p>
<p><strong>CPU使用率的计算公式：</strong></p>
<ol>
<li>
<p>CPU0在5分钟内处于空闲状态的时间：<code>increase(node_cpu_seconds_total{cpu=&quot;0&quot;,mode=&quot;idle&quot;}[5m])</code>，increase 的意思是表示增量，刚才说了 <code>node_cpu_seconds_total</code>是单调递增的，这个公式的结果是当前时点的 <code>node_cpu_seconds_total</code> 减去5分钟之前的 <code>node_cpu_seconds_total</code>，也就是这5分钟之内处于<code>idle</code>状态的 CPU时间。</p>
</li>
<li>
<p>CPU0在5分钟内处于空闲状态的时间占比：<code>increase(node_cpu_seconds_total{cpu=&quot;0&quot;,mode=&quot;idle&quot;}[5m]) / increase(node_cpu_seconds_total{cpu=&quot;0&quot;}[5m])</code>，分母其实就是5分钟=300秒。</p>
</li>
<li>
<p>一台主机所有CPU在5分钟内处于空闲状态的时间占比</p>
<p>用 <code>sum()</code>函数累加各核数值：</p>
<p><code>sum (increase(node_cpu_seconds_total{mode=&quot;idle&quot;}[5m])) / sum (increase(node_cpu_seconds_total{mode=&quot;idle&quot;}[5m]))</code></p>
</li>
<li>
<p>如果 Prometheus 监控多台主机，要根据每台主机做 sum：</p>
<p><code>sum by (instance)(increase(node_cpu_seconds_total{mode=&quot;idle&quot;}[5m])) / sum by (instance)(increase(node_cpu_seconds_total[5m]))</code></p>
</li>
<li>
<p>CPU使用率 = 1 - CPU空闲率：</p>
<p><code>100 * (1 - sum by (instance)(increase(node_cpu_seconds_total{mode=&quot;idle&quot;}[5m])) / sum by (instance)(increase(node_cpu_seconds_total[5m])))</code></p>
</li>
<li>
<p>PromQL 有计算比率的函数：<code>rate()</code> 和 <code>irate()</code>，可以简化计算公式为:</p>
<p><strong><code>100 - (avg by(instance) (irate(node_cpu_seconds_total{mode=&quot;idle&quot;}[5m])) * 100)</code></strong></p>
</li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Chapter6数学问题：6.3质数]]></title>
        <id>https://Czardas42.github.io/post/chapter6_6.3/</id>
        <link href="https://Czardas42.github.io/post/chapter6_6.3/">
        </link>
        <updated>2021-05-05T07:52:58.000Z</updated>
        <content type="html"><![CDATA[<h2 id="判断记录质数的方法">判断/记录质数的方法</h2>
<ol>
<li><code>sqrt(n)</code></li>
<li>素数筛法</li>
</ol>
<h2 id="1-素数判定">1.  素数判定</h2>
<h3 id="题目描述"><strong>题目描述</strong></h3>
<p>给定一个数n，要求判断其是否为素数（0,1，负数都是非素数）。</p>
<h3 id="要点"><strong>要点</strong></h3>
<p>对于负数、0、1要特别处理</p>
<h3 id="提交地址">提交地址</h3>
<p><a href="https://www.nowcoder.com/practice/5fd9c28b1ce746dd99287a04d8fa9002?tpId=40&amp;qru=%2Fta%2Ftsing-kaoyan%2Fquestion-ranking&amp;tab=answerKey">https://www.nowcoder.com/practice/5fd9c28b1ce746dd99287a04d8fa9002?tpId=40&amp;qru=%2Fta%2Ftsing-kaoyan%2Fquestion-ranking&amp;tab=answerKey</a></p>
<h3 id="代码">代码</h3>
<pre><code class="language-c++">#include &lt;iostream&gt;
#include &lt;cstdio&gt;
#include &lt;cmath&gt;
using namespace std;

int main()
{
    int num;
    while (cin &gt;&gt; num)
    {
        if (num&lt;=1)
        {
            cout &lt;&lt; &quot;no&quot; &lt;&lt; endl;
            continue;
        }
        
        bool flag = true;
        for (int i=num-1; i&gt;=sqrt(num); i--)
        {
            if (num % i ==0)
            {
                flag = false;
                break;
            }
        }
        
        if (flag == true)
        {
            cout &lt;&lt; &quot;yes&quot; &lt;&lt; endl;
        }
        else
        {
            cout &lt;&lt; &quot;no&quot; &lt;&lt; endl;
        }
    }
}
</code></pre>
<h2 id="2-素数">2.  素数</h2>
<h3 id="题目描述-2"><strong>题目描述</strong></h3>
<p>输入一个整数n(2&lt;=n&lt;=10000)，要求输出所有从1到这个整数之间(不包括1和这个整数)个位为1的素数，如果没有则输出-1。</p>
<h3 id="要点-2"><strong>要点</strong></h3>
<p>方法一：穷举</p>
<p><strong>方法二【素数筛法】：找到一个素数，就要标记其所有倍数为非负数无需再针对每个数字进行判断</strong></p>
<p><strong>（实际操作中，只需从平方开始标记即可）</strong></p>
<h3 id="提交地址-2">提交地址</h3>
<p><a href="https://www.nowcoder.com/practice/7f4be54b37a04fdaa4ee545819151114?tpId=40&amp;qru=%2Fta%2Ftsing-kaoyan%2Fquestion-ranking&amp;tab=answerKey">https://www.nowcoder.com/practice/7f4be54b37a04fdaa4ee545819151114?tpId=40&amp;qru=%2Fta%2Ftsing-kaoyan%2Fquestion-ranking&amp;tab=answerKey</a></p>
<h3 id="代码穷举">代码（穷举）</h3>
<pre><code class="language-c++">#include &lt;iostream&gt;
#include &lt;cstdio&gt;
#include &lt;cmath&gt;

using namespace std;

int main()
{
    int range;
    while (cin &gt;&gt; range)
    {
        if (range &lt;= 11)
        {
            cout &lt;&lt; &quot;-1&quot; &lt;&lt; endl;
            continue;
        }
        
        for (int num =11; num&lt;range; num++)
        {
            bool flag = true;
            for (int i=num-1; i&gt;=sqrt(num); i--)
            {
                if (num % i == 0)
                {
                    flag = false;
                    break;
                }
            }
            
            if ((flag == true) &amp;&amp; (num%10 == 1))
            {
                if (num == 11)
                    cout &lt;&lt; num;
                else
                    cout &lt;&lt; &quot; &quot; &lt;&lt; num ;
            }
        }
        cout &lt;&lt; endl;
    }
    
    return 0;
}
</code></pre>
<h3 id="代码素数筛法">代码（素数筛法）</h3>
<pre><code class="language-c++">#include &lt;iostream&gt;
#include &lt;cstdio&gt;
#include &lt;cmath&gt;
#include &lt;vector&gt;

using namespace std;

int main()
{
    int range;
    while (cin &gt;&gt; range)
    {
        if (range &lt;=11)
        {
            cout &lt;&lt; &quot;-1\n&quot;;
            break;
        }
        
        bool num[10000];
        vector&lt;int&gt; prime;
        //初始化
        num[0] = false;
        num[1] = false;
        for (int i=2; i&lt;10000; i++)
            num[i] = true;
        
        for (int temp=2; temp&lt;range; temp++)
        {           
            if (num[temp] == true)
            {
                prime.push_back(temp);//加入素数组
                //标记之后temp的倍数不是素数
                for (int j=temp*temp; j&lt;range; j=j+temp)
                    num[j] = false;
            }
        }
        
        //输出
        for (int i=0; i&lt;prime.size(); i++)
        {
            if(prime[i] % 10 == 1)
            {
                if (prime[i] == 11)
                    cout &lt;&lt; prime[i];
                else                
                    cout &lt;&lt; &quot; &quot; &lt;&lt; prime[i];
            }
        }
        cout &lt;&lt; endl;        
    }
    
    return 0;
}
</code></pre>
<h2 id="3-prime-number">3.  Prime Number</h2>
<h3 id="题目描述-3"><strong>题目描述</strong></h3>
<p>Output the k-th prime number.</p>
<h3 id="要点-3"><strong>要点</strong></h3>
<ol>
<li>素数筛法</li>
<li>提前存好10000个素数：范围开到1000000就够用，或者可以记录素数个数</li>
<li><strong>适当可以使用void函数，让main函数看起来更加简洁</strong></li>
</ol>
<h3 id="提交地址-3">提交地址</h3>
<p><a href="https://www.nowcoder.com/practice/c5f8688cea8a4a9a88edbd67d1358415?tpId=40&amp;qru=%2Fta%2Ftsing-kaoyan%2Fquestion-ranking&amp;tab=answerKey">https://www.nowcoder.com/practice/c5f8688cea8a4a9a88edbd67d1358415?tpId=40&amp;qru=%2Fta%2Ftsing-kaoyan%2Fquestion-ranking&amp;tab=answerKey</a></p>
<pre><code class="language-c++">#include &lt;iostream&gt;
#include &lt;cstdio&gt;
#include &lt;vector&gt;

using namespace std;

int order;
vector&lt;int&gt; prime;
const int range = 1000000;

void Initial()
{
    bool num[range];
    for (int i=0; i&lt;range; i++)
        num[i] = true;
    num[0] = false;
    num[1] = false;
    
    for (int temp=0; temp&lt;range; temp++)
    {
        if (num[temp] == true)
        {
            prime.push_back(temp);
            
            for (int j=temp*temp; j&lt;range; j=j+temp)
                num[j] = false;
        }
    }
};

int main()
{
    Initial();      
    while (cin &gt;&gt; order)
    {
        cout &lt;&lt; prime[order-1] &lt;&lt; endl;
    }
    return 0;
}
</code></pre>
]]></content>
    </entry>
</feed>