<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://Czardas42.github.io/</id>
    <title>Czardas</title>
    <updated>2021-05-23T08:00:11.709Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://Czardas42.github.io/"/>
    <link rel="self" href="https://Czardas42.github.io/atom.xml"/>
    <subtitle>世界那么大，我想去看看</subtitle>
    <logo>https://Czardas42.github.io/images/avatar.png</logo>
    <icon>https://Czardas42.github.io/favicon.ico</icon>
    <rights>All rights reserved 2021, Czardas</rights>
    <entry>
        <title type="html"><![CDATA[2020-Rank-Emotion-Cause]]></title>
        <id>https://Czardas42.github.io/post/2020-rank-emotion-cause/</id>
        <link href="https://Czardas42.github.io/post/2020-rank-emotion-cause/">
        </link>
        <updated>2021-05-23T07:59:30.000Z</updated>
        <content type="html"><![CDATA[<p>阅读笔记：</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Chapter8递归与分治：8.2分治]]></title>
        <id>https://Czardas42.github.io/post/chapter8_8.2/</id>
        <link href="https://Czardas42.github.io/post/chapter8_8.2/">
        </link>
        <updated>2021-05-19T03:23:06.000Z</updated>
        <content type="html"><![CDATA[<h2 id="分治法">分治法</h2>
<p>不断把问题分为规模更小的问题</p>
<h2 id="1-斐波那契额数列">1.  斐波那契额数列</h2>
<h3 id="题目描述"><strong>题目描述</strong></h3>
<p>The Fibonacci Numbers{0,1,1,2,3,5,8,13,21,34,55...} are defined by the recurrence:   F0=0 F1=1 Fn=Fn-1+Fn-2,n&gt;=2   Write a program to calculate the Fibonacci Numbers.</p>
<h3 id="要点">要点</h3>
<p>递归的写法</p>
<h3 id="提交地址">提交地址</h3>
<p>https://www.nowcoder.com/practice/17ad6908e36a49f4b06ea96936e8bb25?tpId=40&amp;tab=answerKey</p>
<h3 id="代码">代码</h3>
<pre><code class="language-c++">#include &lt;bits/stdc++.h&gt;

using namespace std;

int Fibonacci(int i)
{
    if (i == 0)
        return 0;
    else if (i == 1)
        return 1;
    else
        return Fibonacci(i-1) + Fibonacci(i-2);
    
}

int main()
{
    int num;
    while (cin &gt;&gt; num)
    {
        cout &lt;&lt; Fibonacci(num) &lt;&lt; endl;
    }
    return 0;
}

</code></pre>
<h2 id="2-二叉树">2.  二叉树</h2>
<h3 id="题目描述-2"><strong>题目描述</strong></h3>
<figure data-type="image" tabindex="1"><img src="https://Czardas42.github.io//post-images/1621394733656.png" alt="" loading="lazy"></figure>
<p>如上所示，由正整数1，2，3……组成了一颗特殊二叉树。我们已知这个二叉树的最后一个结点是n。现在的问题是，结点m所在的子树中一共包括多少个结点。   比如，n = 12，m = 3那么上图中的结点13，14，15以及后面的结点都是不存在的，结点m所在子树中包括的结点有3，6，7，12，因此结点m的所在子树中共有4个结点。</p>
<h3 id="要点-2"><strong>要点</strong></h3>
<ol>
<li>二叉树的规律：左子节点id = 父节点id*2</li>
<li>递归的终止条件：<code>m &gt; n</code></li>
</ol>
<h3 id="提交地址-2">提交地址</h3>
<p>https://www.nowcoder.com/practice/f74c7506538b44399f2849eba2f050b5?tpId=40&amp;tab=answerKey</p>
<h3 id="代码-2">代码</h3>
<pre><code class="language-c++">#include &lt;bits/stdc++.h&gt;

using namespace std;

int nodeCount(int m, int n)
{
    if (m &gt; n)
        return 0;
    else
        return nodeCount(2*m, n) + nodeCount(2*m+1, n) + 1;
}

int main()
{
    int m, n;
    while (cin &gt;&gt; m &gt;&gt;n)
    {
        if (m==0)
            break;        
        cout &lt;&lt; nodeCount(m, n) &lt;&lt; endl;
    }
    
    return 0;
}
</code></pre>
<h2 id="3-2的幂次方">3.  2的幂次方</h2>
<h3 id="题目描述-3"><strong>题目描述</strong></h3>
<p>Every positive number can be presented by the exponential form.For example, 137 = 2^7 + 2^3 + 2^0。   Let's present a^b by the form a(b).Then 137 is presented by 2(7)+2(3)+2(0). Since 7 = 2^2 + 2 + 2^0 and 3 = 2 + 2^0 , 137 is finally presented by 2(2(2)+2 +2(0))+2(2+2(0))+2(0).    Given a positive number n,your task is to present n with the exponential form which only contains the digits 0 and 2.</p>
<h3 id="要点-3"><strong>要点</strong></h3>
<ol>
<li>
<p>十进制到二进制的转换</p>
<p>停止条件<code>num == 0</code>, 不是<code>num / 2 == 0</code></p>
</li>
<li>
<p>递归的思想：</p>
<p>输入，转换为二进制，有效位+位置序号判断</p>
</li>
<li>
<p>“+”位置的出现</p>
</li>
</ol>
<h3 id="提交地址-3">提交地址</h3>
<p>https://www.nowcoder.com/practice/7cf7b0706d7e4b439481f53e5fdac6e7?tpId=40&amp;tab=answerKey</p>
<h3 id="代码-3">代码</h3>
<pre><code class="language-c++">#include &lt;bits/stdc++.h&gt;

using namespace std;

vector&lt;int&gt; convert(int num)
{
    vector&lt;int&gt; res;
    while(num != 0)
    {
        res.push_back(num % 2);
        num = num / 2;
    }
    
    return res;
}

void print(int num)
{
    vector&lt;int&gt; res = convert(num);
    bool begin = true;
    for(int i=res.size()-1; i&gt;=0; i--)
    {
        if (res[i] == 1)//有效位
        {
            if (begin == true)
                begin = false;
            else
                cout &lt;&lt; &quot;+&quot;;
            
            if (i == 0)
                cout &lt;&lt; &quot;2(0)&quot;;
            else if (i == 1)
                cout &lt;&lt; &quot;2&quot;;
            else if (i == 2)
                cout &lt;&lt; &quot;2(2)&quot;;
            else
            {
                cout &lt;&lt; &quot;2(&quot;;
                print(i);
                cout &lt;&lt; &quot;)&quot;;
            }
        }
    }
}

int main()
{
    int num;
    while (cin &gt;&gt; num)
    {
        print(num);
        cout &lt;&lt; endl;
    }
    return 0;  
}
    
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Chapter8递归与分治：8.1递归]]></title>
        <id>https://Czardas42.github.io/post/chapter8_8.1/</id>
        <link href="https://Czardas42.github.io/post/chapter8_8.1/">
        </link>
        <updated>2021-05-19T03:22:13.000Z</updated>
        <content type="html"><![CDATA[<h2 id="递归策略">递归策略</h2>
<h2 id="1-n的阶乘">1.  n的阶乘</h2>
<h3 id="题目描述"><strong>题目描述</strong></h3>
<p>输入一个整数n，输出n的阶乘（每组测试用例可能包含多组数据，请注意处理）</p>
<h3 id="要点"><strong>要点</strong></h3>
<ol>
<li>递归思想</li>
<li>结果的数据范围：<code>long long</code>类型</li>
</ol>
<h3 id="提交地址">提交地址</h3>
<p>https://www.nowcoder.com/practice/97be22ee50b14cccad2787998ca628c8?tpId=40&amp;tab=answerKey</p>
<h3 id="代码">代码</h3>
<pre><code class="language-c++">#include &lt;bits/stdc++.h&gt;

using namespace std;

long long Factorial(int n)
{
    if (n == 1)
        return 1;
    else
    {
        return n * Factorial(n-1);
    }
}
int main()
{
    int num;
    while(cin &gt;&gt; num)
    {
        cout &lt;&lt; Factorial(num) &lt;&lt; endl;
    }
    
    return 0;
}
</code></pre>
<h2 id="2-汉诺塔问题">2.  汉诺塔问题</h2>
<p>移动规律：</p>
<p><code>F(n) = F(n-1) + 1 + F(n-1) + 1 + F(n-1)</code></p>
<p><code>F(n) = 3 * F(n-1) + 2</code></p>
<p>终止条件：<code>n=1</code>时，的移动次数</p>
<h2 id="3-杨辉三角形">3.  杨辉三角形</h2>
<h3 id="题目描述-2"><strong>题目描述</strong></h3>
<p>使用代理服务器能够在一定程度上隐藏客户端信息，从而保护用户在互联网上的隐私。我们知道n个代理服务器的IP地址，现在要用它们去访问m个服务器。这 m 个服务器的 IP 地址和访问顺序也已经给出。系统在同一时刻只能使用一个代理服务器，并要求不能用代理服务器去访问和它 IP地址相同的服务器（不然客户端信息很有可能就会被泄露）。在这样的条件下，找到一种使用代理服务器的方案，使得代理服务器切换的次数尽可能得少。</p>
<h3 id="要点-2"><strong>要点</strong></h3>
<ol>
<li>杨辉三角性质：<code>func(m, n) = func(m-1, n-1) + func(m-1, n);</code></li>
<li>递归函数：返回杨辉三角指定行列的值</li>
</ol>
<h3 id="提交地址-2">提交地址</h3>
<p>https://www.nowcoder.com/practice/1284469ee94a4762848816a42281a9e0?tpId=40&amp;tab=answerKey</p>
<h3 id="代码-2">代码</h3>
<pre><code class="language-c++">#include &lt;bits/stdc++.h&gt;

using namespace std;

int func(int m, int n)
{
    if(n==0)
        return 1;
    else if(m==n)
        return 1;
    else
        return func(m-1, n-1) + func(m-1, n);
}

int main()
{
    int num;
    while (cin &gt;&gt; num)
    {
        for(int i=0; i&lt;num; i++)
        {
            for (int j=0; j&lt;=i; j++)
            {
                if(j==i)
                    cout &lt;&lt; func(i, j) &lt;&lt; endl;
                else
                    cout &lt;&lt; func(i, j) &lt;&lt; &quot; &quot;;
            }
        }
    }
    
    return 0;
}
</code></pre>
<h2 id="3-全排列">3.  全排列</h2>
<h3 id="题目描述-3"><strong>题目描述</strong></h3>
<p>给定一个由不同的小写字母组成的字符串，输出这个字符串的所有全排列。 我们假设对于小写字母有'a' &lt; 'b' &lt; ... &lt; 'y' &lt; 'z'，而且给定的字符串中的字母已经按照从小到大的顺序排列。</p>
<h3 id="要点-3"><strong>要点</strong></h3>
<ol>
<li>STL库的使用：<code>next_permutation(str.begin(),str.end())</code></li>
<li><code>do while</code></li>
</ol>
<h3 id="提交地址-3">提交地址</h3>
<p>https://www.nowcoder.com/practice/5632c23d0d654aecbc9315d1720421c1?tpId=40&amp;tab=answerKey</p>
<h3 id="代码-3">代码</h3>
<pre><code class="language-c++">#include &lt;bits/stdc++.h&gt;

using namespace std;

int main ()
{
    string str;
    while(cin &gt;&gt; str)
    {
        sort(str.begin(), str.end());
        do{
            cout &lt;&lt; str &lt;&lt; endl;
        }
        while(next_permutation(str.begin(),str.end()));
    }
    
    return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Chapter7贪心算法：7.2区间贪心]]></title>
        <id>https://Czardas42.github.io/post/chapter7_7.2/</id>
        <link href="https://Czardas42.github.io/post/chapter7_7.2/">
        </link>
        <updated>2021-05-19T03:21:09.000Z</updated>
        <content type="html"><![CDATA[<h2 id="贪心策略">贪心策略</h2>
<h2 id="1-今年暑假不ac">1.  今年暑假不AC</h2>
<h3 id="题目描述"><strong>题目描述</strong></h3>
<p>“今年暑假不AC？”<br>
“是的。”<br>
“那你干什么呢？”<br>
“看世界杯呀，笨蛋！”<br>
“@#$%^&amp;*%...”</p>
<p>确实如此，世界杯来了，球迷的节日也来了，估计很多ACMer也会抛开电脑，奔向电视了。<br>
作为球迷，一定想看尽量多的完整的比赛，当然，作为新时代的好青年，你一定还会看一些其它的节目，比如新闻联播（永远不要忘记关心国家大事）、非常6+7、超级女生，以及王小丫的《开心辞典》等等，假设你已经知道了所有你喜欢看的电视节目的转播时间表，你会合理安排吗？（目标是能看尽量多的完整节目）</p>
<p>输入数据包含多个测试实例，每个测试实例的第一行只有一个整数n(n&lt;=100)，表示你喜欢看的节目的总数，然后是n行数据，每行包括两个数据Ti_s,Ti_e (1&lt;=i&lt;=n)，分别表示第i个节目的开始和结束时间，为了简化问题，每个时间都用一个正整数表示。n=0表示输入结束，不做处理。</p>
<h3 id="要点"><strong>要点</strong></h3>
<ol>
<li>贪心策略：以节目结束时间为标准</li>
<li>排序的写法</li>
<li>判断条件：该节目开始时间晚于或<strong>等于</strong>标记时间</li>
</ol>
<h3 id="提交地址">提交地址</h3>
<p>http://acm.hdu.edu.cn/showproblem.php?pid=2037</p>
<h3 id="代码">代码</h3>
<pre><code class="language-c++">#include &lt;iostream&gt;
#include &lt;cstdio&gt;
#include &lt;algorithm&gt;

using namespace std;

struct program
{
	int begin;
	int end;
};

program list[100];

bool Compare(program a, program b)
{
	return a.end &lt; b.end;
};

int main()
{
	int count;
	while (cin &gt;&gt; count)
	{
		if (count == 0)
			break;

		for (int i = 0; i &lt; count; i++)
		{
			cin &gt;&gt; list[i].begin &gt;&gt; list[i].end;
		}
		//完成输入

		//排序
		sort(list, list + count, Compare);

		//判断
		int time = 0; //当前标记时间
		int result = 0; //结果记录
		for (int i = 0; i &lt; count; i++)
		{
			if (list[i].begin &gt;= time) //若该节目开始时间晚于或等于标记时间
			{
				result++; //观看节目+1
				time = list[i].end; //标记时间变为该节目的结束时间
			}
		}
		cout &lt;&lt; result &lt;&lt; endl;	
	}
	return 0;
}

</code></pre>
<h2 id="2-to-fill-or-not-to-fill">2.  To Fill or Not to Fill</h2>
<h3 id="题目描述-2"><strong>题目描述</strong></h3>
<p>With highways available, driving a car from Hangzhou to any other city is easy. But since the tank capacity of a car is limited, we have to find gas stations on the way from time to time. Different gas station may give different price. You are asked to carefully design the cheapest route to go.</p>
<h3 id="要点-2"><strong>要点</strong></h3>
<p>倦了，一个下午没通过。。。。。。</p>
<h3 id="提交地址-2">提交地址</h3>
<p>https://www.nowcoder.com/practice/f7eba38f7cd24c45982831e0f38518f9?tpId=40&amp;tab=answerKey</p>
<h3 id="代码-2">代码</h3>
<pre><code class="language-c++">/*
核心思路:利用贪心策略,从最便宜的加油站开始,每个加油站加的油最多能走cmax*davg路程.
利用一个30000大小的flag数组记录是否有重合区域
*/
#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
using namespace std;

struct sta{
    double pi;
    int di;
    bool operator &lt; (const sta&amp; b) const{
        return pi&lt;b.pi;
    }
}a[501];

int main(){
    int cmax, d, davg, n;
    double sum;
    while(scanf(&quot;%d %d %d %d&quot;, &amp;cmax, &amp;d, &amp;davg, &amp;n)!=EOF){
        for(int i=0; i&lt;n; i++) scanf(&quot;%lf %d&quot;, &amp;a[i].pi, &amp;a[i].di);
        sort(a, a+n);
        //
        sum = 0;//记录花费
        int flag[30001]={0}, max = cmax*davg, tmp, cnt;
        for(int i=0; i&lt;n; i++){
            tmp = (a[i].di+max&lt;d?max:d-a[i].di);    //如果到终点距离&lt;max,只需加上足够走到终点的油
            cnt = 0;    //记录有多长距离需要该加油站的油
            for(int j=a[i].di; j&lt;a[i].di+tmp; j++){
                if(flag[j]==0){
                    flag[j] = 1;
                    cnt++;
                }
            }
            sum += cnt/(davg*1.0)*a[i].pi;    //加上在该加油站的花销
        }
        //check
        int i;
        for(i=0; i&lt;d; i++){
            //有的路程没有被覆盖到说明走不到这里
            if(flag[i]==0){
                printf(&quot;The maximum travel distance = %.2lf\n&quot;, (double)i);
                break;
            }
        }
        if(i==d){
            printf(&quot;%.2lf\n&quot;,sum);
        }
    }
    return 0;
}

</code></pre>
<h2 id="2-代理服务器">2.  代理服务器</h2>
<h3 id="题目描述-3"><strong>题目描述</strong></h3>
<p>使用代理服务器能够在一定程度上隐藏客户端信息，从而保护用户在互联网上的隐私。我们知道n个代理服务器的IP地址，现在要用它们去访问m个服务器。这 m 个服务器的 IP 地址和访问顺序也已经给出。系统在同一时刻只能使用一个代理服务器，并要求不能用代理服务器去访问和它 IP地址相同的服务器（不然客户端信息很有可能就会被泄露）。在这样的条件下，找到一种使用代理服务器的方案，使得代理服务器切换的次数尽可能得少。</p>
<h3 id="要点-3"><strong>要点</strong></h3>
<ol>
<li><code>#include&lt;bits/stdc++.h&gt;</code></li>
<li><code>strcmp(proxy[i], server[j])</code></li>
</ol>
<h3 id="提交地址-3">提交地址</h3>
<p>https://www.nowcoder.com/practice/1284469ee94a4762848816a42281a9e0?tpId=40&amp;tab=answerKey</p>
<h3 id="代码-3">代码</h3>
<pre><code class="language-c++">#include&lt;bits/stdc++.h&gt;
using namespace std;

int main(){
    int n;
    while(cin &gt;&gt; n){
        char proxy[n][16];  // proxy服务器
        for(int i = 0; i &lt; n; i++)
            cin &gt;&gt; proxy[i];
        int m;
        cin &gt;&gt; m;
        char server[m][16];
        for(int i = 0; i &lt; m; i++)
            cin &gt;&gt; server[i];  // 被访问的服务器
        //以上都是输入的内容
        int index=0, count=0, flag=1;  //flag用来标志代li失败的状况
        while(flag &amp;&amp; index != m)
        {  //当游标index遍历到m时表示遍历结束
            int max = 0;
            for(int i = 0; i &lt; n; i++){  //这个for是让每个proxy服务器尽可能大的遍历服务器
                int j = index;  //每次从游标开始遍历服务器
                while(strcmp(proxy[i], server[j]) &amp;&amp; j &lt; m)  //尽可能的访问服务器
                    j++;
                if(j - index &gt; max)
                    max = j - index;  //最大访问服务器个数
            }
            if(max == 0)  //遍历失败
                flag = 0;
            count++;
            index += max;
        }
        if(flag)
            cout &lt;&lt; count - 1 &lt;&lt; endl;  //因为第一次不算转换
        else cout &lt;&lt; &quot;-1&quot; &lt;&lt; endl;
    }
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Chapter7贪心算法：7.1简单贪心]]></title>
        <id>https://Czardas42.github.io/post/chapter7_7.1/</id>
        <link href="https://Czardas42.github.io/post/chapter7_7.1/">
        </link>
        <updated>2021-05-19T03:20:11.000Z</updated>
        <content type="html"><![CDATA[<h2 id="贪心策略">贪心策略</h2>
<h2 id="1-鸡兔同笼">1.  鸡兔同笼</h2>
<h3 id="题目描述"><strong>题目描述</strong></h3>
<p>一个笼子里面关了鸡和兔子（鸡有2只脚，兔子有4只脚，没有例外）。已经知道了笼子里面脚的总数a，问笼子里面至少有多少只动物，至多有多少只动物。</p>
<h3 id="要点"><strong>要点</strong></h3>
<p>只有偶数脚时，答案才不是0 0</p>
<h3 id="提交地址">提交地址</h3>
<p>https://www.nowcoder.com/practice/fda725b4d9a14010bb145272cababef1?tpId=40&amp;tab=answerKey</p>
<h3 id="代码">代码</h3>
<pre><code class="language-c++">#include &lt;iostream&gt;
#include &lt;cstdio&gt;

using namespace std;

int Find_least(int num)
{
    int rabbit, chicken;
    rabbit = num / 4;
    int temp = num % 4;
    if (temp != 0)
        chicken = temp / 2;
    
    return rabbit + chicken;
};

int Find_most(int num)
{
    int rabbit = 0, chicken = 0;
    chicken = num / 2;
    
    return rabbit + chicken;
};

int main()
{

    int num;
    while (cin &gt;&gt; num)
    {
        if (num % 2 != 0)
        {
            cout &lt;&lt; &quot;0 0&quot; &lt;&lt; endl;
            continue;
        }
        else
        {
            int most = Find_most(num);
            int least = Find_least(num);
            cout &lt;&lt; least &lt;&lt; &quot; &quot; &lt;&lt; most &lt;&lt; endl;
        }
           
    }
    
    return 0;
}
</code></pre>
<h2 id="2-fatmouse-trade">2.  FatMouse' Trade</h2>
<h3 id="题目描述-2"><strong>题目描述</strong></h3>
<p>FatMouse prepared M pounds of cat food, ready to trade with the cats guarding the warehouse containing his favorite food, JavaBean.<br>
The warehouse has N rooms. The i-th room contains J[i] pounds of JavaBeans and requires F[i] pounds of cat food. FatMouse does not have to trade for all the JavaBeans in the room, instead, he may get J[i]* a% pounds of JavaBeans if he pays F[i]* a% pounds of cat food. Here a is a real number. Now he is assigning this homework to you: tell him the maximum amount of JavaBeans he can obtain.</p>
<h3 id="要点-2"><strong>要点</strong></h3>
<ol>
<li>
<p>计算性价比</p>
</li>
<li>
<p>排序</p>
<pre><code class="language-c++">sort(arr, srr+n, Compare);
bool Compare(a, b) //降序
{
	return a &gt; b;
}
</code></pre>
</li>
</ol>
<h3 id="提交地址-2">提交地址</h3>
<p>暂无</p>
<h3 id="代码-2">代码</h3>
<pre><code class="language-c++">
</code></pre>
<h2 id="2-代理服务器">2.  代理服务器</h2>
<h3 id="题目描述-3"><strong>题目描述</strong></h3>
<p>使用代理服务器能够在一定程度上隐藏客户端信息，从而保护用户在互联网上的隐私。我们知道n个代理服务器的IP地址，现在要用它们去访问m个服务器。这 m 个服务器的 IP 地址和访问顺序也已经给出。系统在同一时刻只能使用一个代理服务器，并要求不能用代理服务器去访问和它 IP地址相同的服务器（不然客户端信息很有可能就会被泄露）。在这样的条件下，找到一种使用代理服务器的方案，使得代理服务器切换的次数尽可能得少。</p>
<h3 id="要点-3"><strong>要点</strong></h3>
<ol>
<li><code>#include&lt;bits/stdc++.h&gt;</code></li>
<li><code>strcmp(proxy[i], server[j])</code></li>
</ol>
<h3 id="提交地址-3">提交地址</h3>
<p>https://www.nowcoder.com/practice/1284469ee94a4762848816a42281a9e0?tpId=40&amp;tab=answerKey</p>
<h3 id="代码-3">代码</h3>
<pre><code class="language-c++">#include&lt;bits/stdc++.h&gt;
using namespace std;

int main(){
    int n;
    while(cin &gt;&gt; n){
        char proxy[n][16];  // proxy服务器
        for(int i = 0; i &lt; n; i++)
            cin &gt;&gt; proxy[i];
        int m;
        cin &gt;&gt; m;
        char server[m][16];
        for(int i = 0; i &lt; m; i++)
            cin &gt;&gt; server[i];  // 被访问的服务器
        //以上都是输入的内容
        int index=0, count=0, flag=1;  //flag用来标志代li失败的状况
        while(flag &amp;&amp; index != m)
        {  //当游标index遍历到m时表示遍历结束
            int max = 0;
            for(int i = 0; i &lt; n; i++){  //这个for是让每个proxy服务器尽可能大的遍历服务器
                int j = index;  //每次从游标开始遍历服务器
                while(strcmp(proxy[i], server[j]) &amp;&amp; j &lt; m)  //尽可能的访问服务器
                    j++;
                if(j - index &gt; max)
                    max = j - index;  //最大访问服务器个数
            }
            if(max == 0)  //遍历失败
                flag = 0;
            count++;
            index += max;
        }
        if(flag)
            cout &lt;&lt; count - 1 &lt;&lt; endl;  //因为第一次不算转换
        else cout &lt;&lt; &quot;-1&quot; &lt;&lt; endl;
    }
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Chapter6数学问题：6.4分解质因数]]></title>
        <id>https://Czardas42.github.io/post/chapter6_6.4/</id>
        <link href="https://Czardas42.github.io/post/chapter6_6.4/">
        </link>
        <updated>2021-05-19T03:18:29.000Z</updated>
        <content type="html"><![CDATA[<h2 id="质因数分解">质因数分解</h2>
<p><strong>把一个合数用质因数相乘的形式表示出来，叫做分解质因数</strong>。</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi><mo>=</mo><msubsup><mi>p</mi><mn>1</mn><mrow><mi>e</mi><mn>1</mn></mrow></msubsup><mo>∗</mo><msubsup><mi>p</mi><mn>2</mn><mrow><mi>e</mi><mn>2</mn></mrow></msubsup><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><msubsup><mi>p</mi><mi>n</mi><mrow><mi>e</mi><mi>n</mi></mrow></msubsup></mrow><annotation encoding="application/x-tex">x = p_1^{e1} * p_2^{e2} ...p_n^{en}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.1111079999999998em;vertical-align:-0.247em;"></span><span class="mord"><span class="mord mathdefault">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8641079999999999em;"><span style="top:-2.4530000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">e</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.247em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.1111079999999998em;vertical-align:-0.247em;"></span><span class="mord"><span class="mord mathdefault">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8641079999999999em;"><span style="top:-2.4530000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">e</span><span class="mord mtight">2</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.247em;"><span></span></span></span></span></span></span><span class="mord">.</span><span class="mord">.</span><span class="mord">.</span><span class="mord"><span class="mord mathdefault">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.7143919999999999em;"><span style="top:-2.4530000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">e</span><span class="mord mathdefault mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.247em;"><span></span></span></span></span></span></span></span></span></span></span></p>
<h2 id="1-质因数个数">1.  质因数个数</h2>
<h3 id="题目描述"><strong>题目描述</strong></h3>
<p>求正整数N(N&gt;1)的质因数的个数。 相同的质因数需要重复计算。如120=2<em>2</em>2<em>3</em>5，共有5个质因数。</p>
<h3 id="要点"><strong>要点</strong></h3>
<p>算法步骤：（输入1&lt;N&lt;M）</p>
<p><code>MAXN = sqrt(M) + 1</code></p>
<ol>
<li>
<p>素数筛法求出0-MAXN所有素数，存好；</p>
<p><strong>（N至多只存在一个大于MAXN的质因数，否则两个相乘会大于N）</strong></p>
</li>
<li>
<p>输入N；</p>
</li>
<li>
<p>依次遍历素数组，判断是否能整除；</p>
</li>
<li>
<p>不断用该素数除N，直到不能被整除为止，记录幂次；</p>
</li>
<li>
<p>遍历完成之后，若N&gt;1，则证明存在一个大于MAXN且幂次为1的质因数</p>
</li>
</ol>
<h3 id="提交地址">提交地址</h3>
<p>https://www.nowcoder.com/practice/20426b85f7fc4ba8b0844cc04807fbd9?tpId=40&amp;qru=%2Fta%2Ftsing-kaoyan%2Fquestion-ranking&amp;tab=answerKey</p>
<h3 id="代码">代码</h3>
<pre><code class="language-c++">#include &lt;iostream&gt;
#include &lt;cmath&gt;
#include &lt;cstdio&gt;
#include &lt;vector&gt;

using namespace std;

const int MAXN = 31623; // sqrt(1e9) + 1

bool isPrime[MAXN];
vector&lt;int&gt; prime;

void Initial() //素数筛法
{
    for(int i=0; i&lt;MAXN; i++)
        isPrime[i] = true;
    isPrime[0] = false;
    isPrime[1] = false;
    
    for (int i=0; i&lt;MAXN; i++)
    {
        if (isPrime[i] == true)
        {
            prime.push_back(i);
            for (int j=i*i; j&lt;MAXN; j=j+i)
                isPrime[j] = false;
        }
    }
};

int main()
{
    Initial();
    
    int num;
    while (cin &gt;&gt; num)
    {
        int result = 0;
        for (int i=0; i&lt;prime.size(); i++)
        {
            int temp = prime[i];
            while (num % temp == 0)
            {
                result++;
                num = num / temp;
            }
            
            if (num == 1) //除尽就跳出循环
                break;
        }
        
        if (num &gt; 1) //存在一个大于sqrt(1e9) + 1的素因数，且幂次为1
            result++;
        
        cout &lt;&lt; result &lt;&lt; endl;
    }
}
</code></pre>
<h2 id="2-约数的个数">2.  约数的个数</h2>
<h3 id="题目描述-2"><strong>题目描述</strong></h3>
<p>输入n个整数,依次输出每个数的约数的个数</p>
<h3 id="要点-2"><strong>要点</strong></h3>
<figure data-type="image" tabindex="1"><img src="D:%5CTJU%5C%E4%BF%9D%E7%A0%94%5C%E6%9C%BA%E8%AF%95%5Cimage-20210506133135936.png" alt="image-20210506133135936" loading="lazy"></figure>
<p>也就是求出质因数之后前面的组合乘上现在的因子加1</p>
<h3 id="提交地址-2">提交地址</h3>
<p>https://www.nowcoder.com/practice/04c8a5ea209d41798d23b59f053fa4d6?tpId=40&amp;qru=%2Fta%2Ftsing-kaoyan%2Fquestion-ranking&amp;tab=answerKey</p>
<h3 id="代码-2">代码</h3>
<pre><code class="language-c++">#include &lt;iostream&gt;
#include &lt;cstdio&gt;
#include &lt;cmath&gt;
#include &lt;vector&gt;

using namespace std;

vector&lt;bool&gt; isPrime;
vector&lt;int&gt; prime;
const int MAXN = sqrt(1e9) + 1;

void Initial()
{
    for (int i=0; i&lt;MAXN; i++)
        isPrime.push_back(true);
    isPrime[0] = false;
    isPrime[1] = false;
    
    for (int i=0; i&lt;MAXN; i++)
    {
        if (isPrime[i] == true)
        {
            prime.push_back(i);
            for (int j = i*i; j&lt;MAXN; j+=i)
                isPrime[j] = false;
        }
    }
};

int main()
{
    int count;
    Initial();
    while (cin &gt;&gt; count)
    {
        int num;
        for (int i=0; i&lt;count; i++)
        {
            cin &gt;&gt; num;           
            int answer = 1;           

            for (int i=0; i&lt;prime.size(); i++)
            {
                int temp = prime[i];
                int result = 0;
                                
                while (num % temp == 0)
                {
                    num = num / temp;
                    result++;
                }
                
                answer = (result+1) * answer;
                
                if (num == 1)
                    break;
            }
            
            if (num &gt; 1)
                answer *= 2;
            
            cout &lt;&lt; answer &lt;&lt; endl;                  
        }
    }
    return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Prometheus]]></title>
        <id>https://Czardas42.github.io/post/prometheus/</id>
        <link href="https://Czardas42.github.io/post/prometheus/">
        </link>
        <updated>2021-05-06T11:59:16.000Z</updated>
        <content type="html"><![CDATA[<h4 id="集群监控策略">集群监控策略：</h4>
<p>Prometheus监控Kubernetes集群监控的各个维度以及策略：</p>
<table>
<thead>
<tr>
<th>目标</th>
<th>服务发现模式</th>
<th><strong>监控方法</strong></th>
<th><strong>数据源</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>从集群各节点kubelet组件中获取节点kubelet的基本运行状态的监控指标</td>
<td>node</td>
<td>白盒监控</td>
<td>kubelet</td>
</tr>
<tr>
<td>从集群各节点kubelet内置的cAdvisor中获取，节点中运行的容器的监控指标</td>
<td>node</td>
<td>白盒监控</td>
<td>kubelet</td>
</tr>
<tr>
<td><strong>从部署到各个节点的Node Exporter中采集主机资源相关的运行资源</strong>（本次实验使用方法）</td>
<td><strong>node</strong></td>
<td><strong>白盒监控</strong></td>
<td><strong>node exporter</strong></td>
</tr>
<tr>
<td>对于内置了Promthues支持的应用，需要从Pod实例中采集其自定义监控指标</td>
<td>pod</td>
<td>白盒监控</td>
<td>custom pod</td>
</tr>
<tr>
<td>获取API Server组件的访问地址，并从中获取Kubernetes集群相关的运行监控指标</td>
<td>endpoints</td>
<td>白盒监控</td>
<td>api server</td>
</tr>
<tr>
<td>获取集群中Service<u>的访问地址</u>，并通过Blackbox Exporter获取网络探测指标</td>
<td>service</td>
<td>黑盒监控</td>
<td>blackbox exporter</td>
</tr>
<tr>
<td>获取集群中Ingress的访问信息，并通过Blackbox Exporter获取网络探测指标</td>
<td>ingress</td>
<td>黑盒监控</td>
<td>blackbox exporter</td>
</tr>
</tbody>
</table>
<h4 id="prometheus部署">Prometheus部署</h4>
<p><u><em>详细说一说，因为直接动了系统自带的配置文件</em></u></p>
<h4 id="node-exporter部署">Node Exporter部署</h4>
<h5 id="方法">方法：</h5>
<ol>
<li>
<p>创建自定义的Node Exporter服务，然后将服务器配置为Prometheus上的Target（本次实验使用方法）</p>
<p>【参考】<a href="https://devopscube.com/monitor-linux-servers-prometheus-node-exporter/">https://devopscube.com/monitor-linux-servers-prometheus-node-exporter/</a></p>
</li>
<li>
<p>还可以使用Daemonset控制器部署Node Exporter</p>
<p>为了能够采集集群中各个节点的资源使用情况，需要在各节点中部署一个Node Exporter实例。在部署Prometheus时，我们使用了Kubernetes内置的控制器之一Deployment。Deployment能够确保Prometheus的Pod能够按照预期的状态在集群中运行，而Pod实例可能随机运行在任意节点上。</p>
<p>而与Prometheus的部署不同的是，<strong>对于Node Exporter而言每个节点只需要运行一个唯一的实例</strong>，所以需要使用Kubernetes的另外一种控制器Daemonset。Daemonset的管理方式类似于操作系统中的守护进程。Daemonset会确保在集群中所有（也可以指定）节点上运行一个唯一的Pod实例。</p>
</li>
</ol>
<h5 id="daemonset-与-deployment-的区别">DaemonSet 与 Deployment 的区别</h5>
<ul>
<li><strong>Deployment</strong> 部署的副本 <strong>Pod</strong> 会分布在各个 <strong>Node</strong> 上，每个 <strong>Node</strong> 都可能运行好几个副本。</li>
<li><strong>DaemonSet</strong> 的不同之处在于：每个 <strong>Node</strong> 上最多只能运行一个副本。</li>
</ul>
<h5 id="daemonset-的典型应用场景">DaemonSet 的典型应用场景</h5>
<ul>
<li>在集群的每个节点上运行存储 <strong>Daemon</strong>，比如：<strong>glusterd</strong> 或 <strong>ceph</strong>。</li>
<li>在每个节点上运行日志收集 <strong>Daemon</strong>，比如：<strong>flunentd</strong> 或 <strong>logstash</strong>。</li>
<li>在每个节点上运行监控 <strong>Daemon</strong>，比如：<strong>Prometheus Node Exporter</strong> 或 <strong>collectd</strong>。</li>
</ul>
<h5 id="查看k8s-的-daemonset">查看k8s 的 DaemonSet</h5>
<p><strong>Kubernetes</strong> 自己就在用 <strong>DaemonSet</strong> 运行系统组件。执行如下命令查看：</p>
<p><code>kubectl get daemonset --``namespace``=kube-system</code></p>
<p><em><u>(配一张截图)</u></em></p>
<h4 id="promql概念应用实例">PromQL概念&amp;应用实例</h4>
<h5 id="概念">概念</h5>
<p>Prometheus通过指标名称（metrics name）以及对应的一组标签（labelset）唯一定义一条时间序列。指标名称反映了监控样本的基本标识，而label则在这个基本特征上为采集到的数据提供了多种特征维度。用户可以基于这些特征维度过滤，聚合，统计从而产生新的计算后的一条时间序列。</p>
<h5 id="应用实例">应用实例</h5>
<ol>
<li>各节点磁盘使用率</li>
</ol>
<p><code>node_filesystem_size_bytes{fstype=~\&quot;xfs|ext4\&quot;} - node_filesystem_free_bytes) / node_filesystem_size_bytes</code></p>
<ol start="2">
<li>各节点内存使用率</li>
</ol>
<p><code>node_memory_MemTotal_bytes - node_memory_MemAvailable_bytes) / node_memory_MemTotal_bytes</code></p>
<ol start="3">
<li>各节点磁盘IO读速率(MiB/s)</li>
</ol>
<p><code>irate(node_disk_read_bytes_total{}[5m]) / 1024 / 1024</code></p>
<ol start="4">
<li>各节点磁盘IO写速率(MiB/s)</li>
</ol>
<p><code>irate(node_disk_written_bytes_total{}[5m]) / 1024 / 1024</code></p>
<ol start="5">
<li>某节点网络IO速率:入速率(MiB/s)</li>
</ol>
<p><code>irate(node_network_receive_bytes_total{job=\&quot;节点名称_node_exporter_metrics\&quot;}[5m]) / 1024 / 1024</code></p>
<ol start="6">
<li>某节点网络IO速率:出速率(MiB/s)</li>
</ol>
<p><code>irate(node_network_transmit_bytes_total{job=\&quot;节点名称_node_exporter_metrics\&quot;}[5m]) / 1024 / 1024</code></p>
<ol start="7">
<li><strong>某节点CPU使用率</strong></li>
</ol>
<p><code>100 - (avg by(instance) (irate(node_cpu_seconds_total{mode=\&quot;idle\&quot;, job=\&quot;节点名称_node_exporter_metrics\&quot;}[5m])) * 100)</code></p>
<p><strong>CPU使用率的计算公式：</strong></p>
<ol>
<li>
<p>CPU0在5分钟内处于空闲状态的时间：<code>increase(node_cpu_seconds_total{cpu=&quot;0&quot;,mode=&quot;idle&quot;}[5m])</code>，increase 的意思是表示增量，刚才说了 <code>node_cpu_seconds_total</code>是单调递增的，这个公式的结果是当前时点的 <code>node_cpu_seconds_total</code> 减去5分钟之前的 <code>node_cpu_seconds_total</code>，也就是这5分钟之内处于<code>idle</code>状态的 CPU时间。</p>
</li>
<li>
<p>CPU0在5分钟内处于空闲状态的时间占比：<code>increase(node_cpu_seconds_total{cpu=&quot;0&quot;,mode=&quot;idle&quot;}[5m]) / increase(node_cpu_seconds_total{cpu=&quot;0&quot;}[5m])</code>，分母其实就是5分钟=300秒。</p>
</li>
<li>
<p>一台主机所有CPU在5分钟内处于空闲状态的时间占比</p>
<p>用 <code>sum()</code>函数累加各核数值：</p>
<p><code>sum (increase(node_cpu_seconds_total{mode=&quot;idle&quot;}[5m])) / sum (increase(node_cpu_seconds_total{mode=&quot;idle&quot;}[5m]))</code></p>
</li>
<li>
<p>如果 Prometheus 监控多台主机，要根据每台主机做 sum：</p>
<p><code>sum by (instance)(increase(node_cpu_seconds_total{mode=&quot;idle&quot;}[5m])) / sum by (instance)(increase(node_cpu_seconds_total[5m]))</code></p>
</li>
<li>
<p>CPU使用率 = 1 - CPU空闲率：</p>
<p><code>100 * (1 - sum by (instance)(increase(node_cpu_seconds_total{mode=&quot;idle&quot;}[5m])) / sum by (instance)(increase(node_cpu_seconds_total[5m])))</code></p>
</li>
<li>
<p>PromQL 有计算比率的函数：<code>rate()</code> 和 <code>irate()</code>，可以简化计算公式为:</p>
<p><strong><code>100 - (avg by(instance) (irate(node_cpu_seconds_total{mode=&quot;idle&quot;}[5m])) * 100)</code></strong></p>
</li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Chapter6数学问题：6.3质数]]></title>
        <id>https://Czardas42.github.io/post/chapter6_6.3/</id>
        <link href="https://Czardas42.github.io/post/chapter6_6.3/">
        </link>
        <updated>2021-05-05T07:52:58.000Z</updated>
        <content type="html"><![CDATA[<h2 id="判断记录质数的方法">判断/记录质数的方法</h2>
<ol>
<li><code>sqrt(n)</code></li>
<li>素数筛法</li>
</ol>
<h2 id="1-素数判定">1.  素数判定</h2>
<h3 id="题目描述"><strong>题目描述</strong></h3>
<p>给定一个数n，要求判断其是否为素数（0,1，负数都是非素数）。</p>
<h3 id="要点"><strong>要点</strong></h3>
<p>对于负数、0、1要特别处理</p>
<h3 id="提交地址">提交地址</h3>
<p><a href="https://www.nowcoder.com/practice/5fd9c28b1ce746dd99287a04d8fa9002?tpId=40&amp;qru=%2Fta%2Ftsing-kaoyan%2Fquestion-ranking&amp;tab=answerKey">https://www.nowcoder.com/practice/5fd9c28b1ce746dd99287a04d8fa9002?tpId=40&amp;qru=%2Fta%2Ftsing-kaoyan%2Fquestion-ranking&amp;tab=answerKey</a></p>
<h3 id="代码">代码</h3>
<pre><code class="language-c++">#include &lt;iostream&gt;
#include &lt;cstdio&gt;
#include &lt;cmath&gt;
using namespace std;

int main()
{
    int num;
    while (cin &gt;&gt; num)
    {
        if (num&lt;=1)
        {
            cout &lt;&lt; &quot;no&quot; &lt;&lt; endl;
            continue;
        }
        
        bool flag = true;
        for (int i=num-1; i&gt;=sqrt(num); i--)
        {
            if (num % i ==0)
            {
                flag = false;
                break;
            }
        }
        
        if (flag == true)
        {
            cout &lt;&lt; &quot;yes&quot; &lt;&lt; endl;
        }
        else
        {
            cout &lt;&lt; &quot;no&quot; &lt;&lt; endl;
        }
    }
}
</code></pre>
<h2 id="2-素数">2.  素数</h2>
<h3 id="题目描述-2"><strong>题目描述</strong></h3>
<p>输入一个整数n(2&lt;=n&lt;=10000)，要求输出所有从1到这个整数之间(不包括1和这个整数)个位为1的素数，如果没有则输出-1。</p>
<h3 id="要点-2"><strong>要点</strong></h3>
<p>方法一：穷举</p>
<p><strong>方法二【素数筛法】：找到一个素数，就要标记其所有倍数为非负数无需再针对每个数字进行判断</strong></p>
<p><strong>（实际操作中，只需从平方开始标记即可）</strong></p>
<h3 id="提交地址-2">提交地址</h3>
<p><a href="https://www.nowcoder.com/practice/7f4be54b37a04fdaa4ee545819151114?tpId=40&amp;qru=%2Fta%2Ftsing-kaoyan%2Fquestion-ranking&amp;tab=answerKey">https://www.nowcoder.com/practice/7f4be54b37a04fdaa4ee545819151114?tpId=40&amp;qru=%2Fta%2Ftsing-kaoyan%2Fquestion-ranking&amp;tab=answerKey</a></p>
<h3 id="代码穷举">代码（穷举）</h3>
<pre><code class="language-c++">#include &lt;iostream&gt;
#include &lt;cstdio&gt;
#include &lt;cmath&gt;

using namespace std;

int main()
{
    int range;
    while (cin &gt;&gt; range)
    {
        if (range &lt;= 11)
        {
            cout &lt;&lt; &quot;-1&quot; &lt;&lt; endl;
            continue;
        }
        
        for (int num =11; num&lt;range; num++)
        {
            bool flag = true;
            for (int i=num-1; i&gt;=sqrt(num); i--)
            {
                if (num % i == 0)
                {
                    flag = false;
                    break;
                }
            }
            
            if ((flag == true) &amp;&amp; (num%10 == 1))
            {
                if (num == 11)
                    cout &lt;&lt; num;
                else
                    cout &lt;&lt; &quot; &quot; &lt;&lt; num ;
            }
        }
        cout &lt;&lt; endl;
    }
    
    return 0;
}
</code></pre>
<h3 id="代码素数筛法">代码（素数筛法）</h3>
<pre><code class="language-c++">#include &lt;iostream&gt;
#include &lt;cstdio&gt;
#include &lt;cmath&gt;
#include &lt;vector&gt;

using namespace std;

int main()
{
    int range;
    while (cin &gt;&gt; range)
    {
        if (range &lt;=11)
        {
            cout &lt;&lt; &quot;-1\n&quot;;
            break;
        }
        
        bool num[10000];
        vector&lt;int&gt; prime;
        //初始化
        num[0] = false;
        num[1] = false;
        for (int i=2; i&lt;10000; i++)
            num[i] = true;
        
        for (int temp=2; temp&lt;range; temp++)
        {           
            if (num[temp] == true)
            {
                prime.push_back(temp);//加入素数组
                //标记之后temp的倍数不是素数
                for (int j=temp*temp; j&lt;range; j=j+temp)
                    num[j] = false;
            }
        }
        
        //输出
        for (int i=0; i&lt;prime.size(); i++)
        {
            if(prime[i] % 10 == 1)
            {
                if (prime[i] == 11)
                    cout &lt;&lt; prime[i];
                else                
                    cout &lt;&lt; &quot; &quot; &lt;&lt; prime[i];
            }
        }
        cout &lt;&lt; endl;        
    }
    
    return 0;
}
</code></pre>
<h2 id="3-prime-number">3.  Prime Number</h2>
<h3 id="题目描述-3"><strong>题目描述</strong></h3>
<p>Output the k-th prime number.</p>
<h3 id="要点-3"><strong>要点</strong></h3>
<ol>
<li>素数筛法</li>
<li>提前存好10000个素数：范围开到1000000就够用，或者可以记录素数个数</li>
<li><strong>适当可以使用void函数，让main函数看起来更加简洁</strong></li>
</ol>
<h3 id="提交地址-3">提交地址</h3>
<p><a href="https://www.nowcoder.com/practice/c5f8688cea8a4a9a88edbd67d1358415?tpId=40&amp;qru=%2Fta%2Ftsing-kaoyan%2Fquestion-ranking&amp;tab=answerKey">https://www.nowcoder.com/practice/c5f8688cea8a4a9a88edbd67d1358415?tpId=40&amp;qru=%2Fta%2Ftsing-kaoyan%2Fquestion-ranking&amp;tab=answerKey</a></p>
<pre><code class="language-c++">#include &lt;iostream&gt;
#include &lt;cstdio&gt;
#include &lt;vector&gt;

using namespace std;

int order;
vector&lt;int&gt; prime;
const int range = 1000000;

void Initial()
{
    bool num[range];
    for (int i=0; i&lt;range; i++)
        num[i] = true;
    num[0] = false;
    num[1] = false;
    
    for (int temp=0; temp&lt;range; temp++)
    {
        if (num[temp] == true)
        {
            prime.push_back(temp);
            
            for (int j=temp*temp; j&lt;range; j=j+temp)
                num[j] = false;
        }
    }
};

int main()
{
    Initial();      
    while (cin &gt;&gt; order)
    {
        cout &lt;&lt; prime[order-1] &lt;&lt; endl;
    }
    return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Chapter6数学问题：6.2 最大公约数和最小公倍数]]></title>
        <id>https://Czardas42.github.io/post/chapter6_6.2/</id>
        <link href="https://Czardas42.github.io/post/chapter6_6.2/">
        </link>
        <updated>2021-05-05T07:51:36.000Z</updated>
        <content type="html"><![CDATA[<h2 id="辗转相除法">辗转相除法</h2>
<h2 id="1-最大公约数">1.  最大公约数</h2>
<h3 id="题目描述"><strong>题目描述</strong></h3>
<p>输入两个正整数，求其最大公约数。</p>
<h3 id="要点"><strong>要点</strong></h3>
<p>递归实现辗转相除法GCD</p>
<h3 id="提交地址">提交地址</h3>
<p><a href="https://www.nowcoder.com/practice/20216f2c84bc438eb5ef05e382536fd3?tpId=40&amp;qru=%2Fta%2Ftsing-kaoyan%2Fquestion-ranking&amp;tab=answerKey">https://www.nowcoder.com/practice/20216f2c84bc438eb5ef05e382536fd3?tpId=40&amp;qru=%2Fta%2Ftsing-kaoyan%2Fquestion-ranking&amp;tab=answerKey</a></p>
<h3 id="代码">代码</h3>
<pre><code class="language-c++">#include &lt;iostream&gt;
#include &lt;cstdio&gt;

using namespace std;

int GCD(int a, int b)
{
    if(a%b == 0) //a可以整除b：b是最大公约数
    {
        return b;
    }
    else
    {
        return GCD(b, a%b);
    }
}

int main()
{
    int num1, num2;
    while(cin &gt;&gt; num1 &gt;&gt; num2)
    {
        cout &lt;&lt; GCD(num1, num2) &lt;&lt; endl;
    }
    
    return 0;
}
</code></pre>
<h2 id="2-最小公倍数">2.  最小公倍数</h2>
<h3 id="题目描述-2"><strong>题目描述</strong></h3>
<p>输入两个正整数，求其最小公约数。</p>
<h3 id="要点-2"><strong>要点</strong></h3>
<ol>
<li>
<p><strong>最小公倍数 = 两数乘积 / 最大公约数</strong></p>
</li>
<li>
<p>递归实现辗转相除法</p>
</li>
</ol>
<h3 id="提交地址-2">提交地址</h3>
<p><a href="https://www.nowcoder.com/practice/22948c2cad484e0291350abad86136c3?tpId=37&amp;qru=%2Fta%2Ftsing-kaoyan%2Fquestion-ranking&amp;tab=answerKey">https://www.nowcoder.com/practice/22948c2cad484e0291350abad86136c3?tpId=37&amp;qru=%2Fta%2Ftsing-kaoyan%2Fquestion-ranking&amp;tab=answerKey</a></p>
<h3 id="代码-2">代码</h3>
<pre><code class="language-c++">#include &lt;iostream&gt;
#include &lt;cstdio&gt;

using namespace std;

int GCD(int a, int b)
{
    if(a%b == 0)
    {
        return b;
    }
    else
    {
        return GCD(b, a%b);
    }
}

int main()
{
    int num1, num2;
    while (cin &gt;&gt; num1 &gt;&gt; num2)
    {
        int temp = num1 * num2;
        int result = temp / GCD(num1, num2);
        cout &lt;&lt; result &lt;&lt; endl;
    }
}
</code></pre>
<h2 id="3-最简真分数">3.  最简真分数</h2>
<h3 id="题目描述-3"><strong>题目描述</strong></h3>
<p>给出n个正整数，任取两个数分别作为分子和分母组成最简真分数，编程求共有几个这样的组合。</p>
<h3 id="要点-3"><strong>要点</strong></h3>
<ol>
<li>
<p><strong>最简真分数：分子&lt;分母；分子分母最大公约数为1</strong></p>
</li>
<li>
<p>因为真分数的要求，最终结果/2</p>
</li>
</ol>
<h3 id="提交地址-3">提交地址</h3>
<p><a href="https://www.nowcoder.com/practice/1f1db273eeb745c6ac83e91ff14d2ec9?tpId=40&amp;qru=%2Fta%2Ftsing-kaoyan%2Fquestion-ranking&amp;tab=answerKey">https://www.nowcoder.com/practice/1f1db273eeb745c6ac83e91ff14d2ec9?tpId=40&amp;qru=%2Fta%2Ftsing-kaoyan%2Fquestion-ranking&amp;tab=answerKey</a></p>
<h3 id="代码-3">代码</h3>
<pre><code class="language-c++">#include &lt;iostream&gt;
#include &lt;cstdio&gt;
#include &lt;vector&gt;

using namespace std;

int GCD(int a, int b)
{
    if(a%b == 0)
        return b;
    else
        return GCD(b, a%b);
};

int main()
{
    int count;
    while(cin &gt;&gt; count)
    {
        if (count == 0)
            break;
        //存入数据
        vector&lt;int&gt; number;
        int num;
        for (int i=0; i&lt;count; i++)
        {
            cin &gt;&gt; num;
            number.push_back(num);
        }
        //遍历
        int result = 0;
        for (int i=0; i&lt;number.size(); i++)
        {
            for (int j=0; j&lt;number.size(); j++)
            {
                int temp = GCD(number[i], number[j]);
                if (temp==1)
                {//两数最大公约数是1
                    result++;
                }
            }
        }
        cout &lt;&lt; result/2 &lt;&lt; endl;  //真分数&lt;1,所以结果/2         
    }
    
    return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Chapter6数学问题：6.1 进制转换]]></title>
        <id>https://Czardas42.github.io/post/chapter6_6.1/</id>
        <link href="https://Czardas42.github.io/post/chapter6_6.1/">
        </link>
        <updated>2021-05-05T07:48:49.000Z</updated>
        <content type="html"><![CDATA[<h2 id="进制转换原理">进制转换原理</h2>
<h2 id="1-二进制数">1.  二进制数</h2>
<h3 id="题目描述"><strong>题目描述</strong></h3>
<p>大家都知道，数据在计算机里中存储是以二进制的形式存储的。 有一天，小明学了C语言之后，他想知道一个类型为unsigned int 类型的数字，存储在计算机中的二进制串是什么样子的。 你能帮帮小明吗？并且，小明不想要二进制串中前面的没有意义的0串，即要去掉前导0。</p>
<h3 id="要点"><strong>要点</strong></h3>
<ol>
<li>进制转换标准公式</li>
<li>以及while循环判断条件<code>while (num != 0)</code></li>
</ol>
<h3 id="提交地址">提交地址</h3>
<p><a href="https://www.nowcoder.com/practice/103dd589fed14457a673c613d8de3841?tpId=40&amp;qru=%2Fta%2Ftsing-kaoyan%2Fquestion-ranking&amp;tab=answerKey">https://www.nowcoder.com/practice/103dd589fed14457a673c613d8de3841?tpId=40&amp;qru=%2Fta%2Ftsing-kaoyan%2Fquestion-ranking&amp;tab=answerKey</a></p>
<h3 id="代码">代码</h3>
<pre><code class="language-c++">#include &lt;iostream&gt;
#include &lt;cstdio&gt;
#include &lt;string&gt;

using namespace std;

int main()
{
    int num;
    while (cin &gt;&gt; num)
    {
        string result = &quot;&quot;;
        
        while (num != 0)
        {
            int temp = num % 2;
            char num_now = char('0'+temp);
            result = num_now + result;
            num = num / 2;
        }
        
        cout  &lt;&lt; result &lt;&lt; endl;
    }
}
</code></pre>
<h2 id="2-进制转换">2. <strong>进制转换</strong></h2>
<h3 id="题目描述-2"><strong>题目描述</strong></h3>
<p>将一个长度最多为30位数字的十进制非负整数转换为二进制数输出。</p>
<h3 id="要点-2"><strong>要点</strong></h3>
<ol>
<li>
<p>数字长度：https://www.runoob.com/cplusplus/cpp-data-types.html</p>
<table>
<thead>
<tr>
<th>unsigned long int</th>
<th>0 到 18,446,744,073,709,551,615（20位）</th>
</tr>
</thead>
<tbody></tbody>
</table>
<p><strong>超过20位的数字运算就只能通过字符串实现</strong></p>
</li>
<li>
<p>字符串类型计算乘除法的方法：模仿手动计算</p>
</li>
<li>
<p><strong>从第一个非0位开始输出：</strong></p>
<p>设置flag，在第一次遇到非0时将其变为true；</p>
<p>提前获得非0位的编号</p>
</li>
</ol>
<h3 id="提交地址-2">提交地址</h3>
<p><a href="https://www.nowcoder.com/practice/53447aa04f32460aa20ee11d02416e3b?tpId=40&amp;qru=%2Fta%2Ftsing-kaoyan%2Fquestion-ranking&amp;tab=answerKey">https://www.nowcoder.com/practice/53447aa04f32460aa20ee11d02416e3b?tpId=40&amp;qru=%2Fta%2Ftsing-kaoyan%2Fquestion-ranking&amp;tab=answerKey</a></p>
<h3 id="代码-2">代码</h3>
<pre><code class="language-c++">#include &lt;iostream&gt;
#include &lt;cstdio&gt;
#include &lt;string&gt;

using namespace std;

char GetTemp(string num)//取得字符串num的%2结果
{   //num%2结果 = num最后一位%2的结果
    int temp0 = int(num[num.size()-1] - '0') % 2;
    char temp = char(temp0 + '0');
    return temp;
};

string GetNum(string num)//取得字符串num的/2结果
{
    int m = 0;
    string result = num;
    for (int i=0; i&lt;num.size(); i++)
    {   //模仿手动计算除法的过程
        int num_now = int(num[i] - '0') + m*10;
        result[i] = char(num_now / 2 + '0');
        m = num_now % 2;
    }
    
    return result;
};

int main()
{
    string num;
    while (cin &gt;&gt; num)
    {
        string result = &quot;&quot;;
        
        //flag：和num位数相同的全零串
        string flag = num;
        for (int i=0; i&lt;flag.size(); i++)
            flag[i] = '0';
        
        while(num != flag)
        {
            result = GetTemp(num) + result;
            num = GetNum(num);
        }

        //输出：从首个非零位开始
        bool flag2 = false;
        for (int j=0; j&lt;result.size(); j++)
        {
            if (result[j] != '0')
                flag2 = true;
            
            if (flag2 == true)
                cout &lt;&lt; result[j];
        }
        cout &lt;&lt; endl;        
    }
}
</code></pre>
<h2 id="3-十进制vs二进制">3. <strong>十进制VS二进制</strong></h2>
<h3 id="题目描述-3"><strong>题目描述</strong></h3>
<p>对于一个十进制数A，将A转换为二进制数，然后按位逆序排列，再转换为十进制数B，我们称B为A的二进制逆序数。   例如对于十进制数173，它的二进制形式为10101101，逆序排列得到10110101，其十进制数为181，181即为173的二进制逆序数。</p>
<p><strong>注意：一个1000位(即10^999)以内的十进制数。</strong></p>
<h3 id="要点-3"><strong>要点</strong></h3>
<ol>
<li>
<p><strong>法一：字符串类型的加法，乘法，除法，取余</strong></p>
</li>
<li>
<p><strong>法二：大数进制转换</strong></p>
<p>参考：<a href="https://blog.csdn.net/StrongerL/article/details/92702052">https://blog.csdn.net/StrongerL/article/details/92702052</a></p>
</li>
</ol>
<h3 id="提交地址-3">提交地址</h3>
<p><a href="https://www.nowcoder.com/practice/53447aa04f32460aa20ee11d02416e3b?tpId=40&amp;qru=%2Fta%2Ftsing-kaoyan%2Fquestion-ranking&amp;tab=answerKey">https://www.nowcoder.com/practice/53447aa04f32460aa20ee11d02416e3b?tpId=40&amp;qru=%2Fta%2Ftsing-kaoyan%2Fquestion-ranking&amp;tab=answerKey</a></p>
<h3 id="代码-3">代码</h3>
]]></content>
    </entry>
</feed>